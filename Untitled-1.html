<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0f172a" />
  <meta name="description" content="釣行の記録、釣果の管理、潮汐情報の自動取得ができるPWAアプリケーション" />
  <link rel="manifest" href="./manifest.json">
  <link rel="apple-touch-icon" href="./icon-192.png">
  <link rel="icon" type="image/png" href="./icon-192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="./icon-512.png" sizes="512x512">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="FishTrip">
  <title>釣行記録（PWAフロント / コンパクトUI）</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="min-h-screen bg-slate-950 text-slate-50">
  <header class="sticky top-0 z-10 backdrop-blur bg-slate-950/70 border-b border-slate-800">
    <div class="max-w-4xl mx-auto px-4 py-3">
      <div class="mb-3 text-center">
        <h1 class="text-3xl font-bold">Fishing_Log</h1>
      </div>
      <nav class="flex gap-2 text-sm items-center justify-between">
        <div class="flex gap-2">
          <button id="navHome" class="px-3 py-1.5 rounded-xl border border-slate-700 hover:bg-slate-800">ホーム</button>
          <button id="navRecord" class="px-3 py-1.5 rounded-xl bg-emerald-600 hover:bg-emerald-500 font-semibold">釣行の記録</button>
          <button id="navTrips" class="px-3 py-1.5 rounded-xl bg-amber-700 hover:bg-amber-600 font-semibold">釣行の確認</button>
          <button id="navCatches" class="px-3 py-1.5 rounded-xl bg-sky-700 hover:bg-sky-600 font-semibold">釣果の確認</button>
        </div>
        <button id="navSettings" class="px-3 py-1.5 rounded-xl hover:bg-slate-700 text-xl">⚙️</button>
      </nav>
    </div>
  </header>

  <!-- ★追加：釣行編集用モーダル（<main> の外に配置） -->
  <div id="tripEditModal" class="hidden fixed inset-0 z-30 bg-black/60 grid place-items-center p-4">
    <div class="w-full max-w-2xl rounded-2xl bg-slate-900 border border-slate-800 p-4" onclick="event.stopPropagation()">
      <div class="flex items-center justify-between mb-4">
        <h3 class="font-semibold text-lg">釣行データ編集</h3>
        <button id="btnCloseTripEdit" class="text-slate-400 hover:text-slate-200">×</button>
      </div>
      
      <div class="space-y-4 max-h-[65vh] overflow-auto">
        <!-- 釣行基本情報 -->
        <div class="border-b border-slate-700 pb-4">
          <h4 class="text-sm font-semibold text-slate-300 mb-3">釣行情報</h4>
          
          <label class="block mb-3"><span class="text-sm text-slate-300">開始日時</span>
            <input id="editTripStarted" type="text" placeholder="yyyy-mm-dd hh:mm" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm" />
          </label>
          
          <label class="block mb-3"><span class="text-sm text-slate-300">終了日時</span>
            <input id="editTripEnded" type="text" placeholder="yyyy-mm-dd hh:mm" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm" />
          </label>
          
          <label class="block mb-3"><span class="text-sm text-slate-300">釣場位置（緯度）</span>
            <input id="editTripLat" type="number" step="0.00001" placeholder="34.68173" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm" />
          </label>
          
          <label class="block mb-3"><span class="text-sm text-slate-300">釣場位置（経度）</span>
            <input id="editTripLng" type="number" step="0.00001" placeholder="135.18006" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm" />
          </label>

          <label class="block mb-3"><span class="text-sm text-slate-300">メモ</span>
            <textarea id="editTripMemo" placeholder="釣行のメモを入力..." class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm h-24 resize-none"></textarea>
          </label>
        </div>

        <!-- 補完データ表示 -->
        <div class="border-b border-slate-700 pb-4">
          <h4 class="text-sm font-semibold text-slate-300 mb-3">補完データ</h4>
          
          <div class="grid grid-cols-2 gap-3">
            <div class="bg-slate-950 rounded-lg p-3">
              <div class="text-xs text-slate-500">天気</div>
              <div id="editTripWeather" class="text-sm text-slate-200 mt-1 break-words">未設定</div>
            </div>
            <div class="bg-slate-950 rounded-lg p-3">
              <div class="text-xs text-slate-500">潮汐</div>
              <div id="editTripTide" class="text-sm text-slate-200 mt-1 break-words">未設定</div>
            </div>
            <div class="bg-slate-950 rounded-lg p-3">
              <div class="text-xs text-slate-500">水温</div>
              <div id="editTripWaterTemp" class="text-sm text-slate-200 mt-1 break-words">未設定</div>
            </div>
          </div>
          
          <!-- ★追加：データ再取得ボタン -->
          <button id="btnRefetchCompData" class="mt-3 w-full py-2 rounded-lg bg-slate-700 hover:bg-slate-600 text-sm font-semibold">🔄 データ再取得（天気・潮汐）</button>
        </div>

        <!-- 釣果リスト -->
        <div class="border-b border-slate-700 pb-4">
          <div class="flex items-center justify-between mb-3">
            <h4 class="text-sm font-semibold text-slate-300">釣果（<span id="editCatchCount">0</span>件）</h4>
            <button id="btnAddCatchInEdit" class="text-xs py-1 px-3 rounded-lg bg-sky-600 hover:bg-sky-500 font-semibold">＋釣果追加</button>
          </div>
          <div id="editCatchList" class="space-y-2"></div>
        </div>

        <!-- ★追加：編集モーダル内の釣果追加フォーム -->
        <div id="editCatchFormSection" class="hidden border-b border-slate-700 pb-4">
          <div class="flex items-center justify-between mb-3">
            <h4 class="text-sm font-semibold text-slate-300">釣果を追加</h4>
            <button id="btnCloseCatchFormInEdit" class="text-xs text-slate-400 hover:text-slate-200">閉じる</button>
          </div>
          
          <div class="space-y-2 max-h-80 overflow-auto">
            <label class="block"><span class="text-xs text-slate-400">日時</span>
              <input id="editFormCatchTime" type="text" placeholder="YYYY-MM-DDTHH:MM" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-lg px-2 py-1 text-sm" />
            </label>
            
            <label class="block"><span class="text-xs text-slate-400">魚種</span>
              <input id="editFormCatchSpecies" type="text" placeholder="例：ヒラメ" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-lg px-2 py-1 text-sm" />
            </label>
            
            <div class="grid grid-cols-2 gap-2">
              <label class="block"><span class="text-xs text-slate-400">サイズ（cm）</span>
                <input id="editFormCatchSize" type="number" inputmode="decimal" placeholder="50" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-lg px-2 py-1 text-sm" />
              </label>
              
              <label class="block"><span class="text-xs text-slate-400">重量（g）</span>
                <input id="editFormCatchWeight" type="number" inputmode="decimal" placeholder="500" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-lg px-2 py-1 text-sm" />
              </label>
            </div>
            
            <label class="block"><span class="text-xs text-slate-400">方法</span>
              <input id="editFormCatchMethod" type="text" placeholder="例：メタルジグ 20g" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-lg px-2 py-1 text-sm" />
            </label>
            
            <label class="block"><span class="text-xs text-slate-400">写真</span>
              <input id="editFormCatchPhoto" type="file" accept="image/*" class="mt-1 w-full text-xs" />
              <img id="editFormCatchPhotoPreview" class="hidden mt-2 w-full rounded-lg max-h-40 object-cover" />
            </label>
            
            <div class="flex gap-2 mt-3">
              <button id="btnSaveCatchFormInEdit" class="flex-1 py-1 rounded-lg bg-green-600 hover:bg-green-500 text-xs font-semibold">追加</button>
              <button id="btnCancelCatchFormInEdit" class="flex-1 py-1 rounded-lg bg-slate-700 hover:bg-slate-600 text-xs font-semibold">キャンセル</button>
            </div>
          </div>
        </div>
      </div>

      <div class="flex gap-2 mt-4">
        <button id="btnCancelTripEdit" class="flex-1 py-2 rounded-xl border border-slate-700 hover:bg-slate-800">キャンセル</button>
        <button id="btnSaveTripEdit" class="flex-1 py-2 rounded-2xl bg-purple-600 hover:bg-purple-500 font-semibold">上書き保存</button>
      </div>
    </div>
  </div>

  <main class="max-w-4xl mx-auto px-4 pb-28 pt-4">
    <!-- ホーム -->
    <section id="homeView" class="space-y-4">
      <!-- 釣行記録（1列、最上段） -->
      <div class="rounded-2xl bg-slate-900 border border-slate-800 p-4 flex flex-col gap-3">
        <div class="text-lg font-semibold">釣行の記録</div>
        <button id="homeGoRecord" class="w-full py-8 rounded-xl bg-emerald-600 hover:bg-emerald-500 font-semibold">釣行記録</button>
      </div>
      <!-- 確認Menu と 登録Menu を縦並びで表示 -->
      <div class="pt-4"></div>
      <div class="space-y-4">
        <!-- 確認 -->
        <div class="rounded-2xl bg-slate-900 border border-slate-800 p-4">
          <div class="text-lg font-semibold text-slate-50 mb-3">確認</div>
          <div class="flex flex-row gap-2">
            <button id="homeGoTrips" class="flex-1 py-2 rounded-xl bg-amber-700 hover:bg-amber-600 font-semibold text-sm sm:text-base">釣行の確認</button>
            <button id="homeGoCatches" class="flex-1 py-2 rounded-xl bg-sky-700 hover:bg-sky-600 font-semibold text-sm sm:text-base">釣果の確認</button>
          </div>
        </div>
        <!-- 登録 -->
        <div class="rounded-2xl bg-slate-900 border border-slate-800 p-4">
          <div class="text-lg font-semibold text-slate-50 mb-3">登録</div>
          <div class="flex flex-row gap-2">
            <button id="btnManualTripHome" class="flex-1 py-2 rounded-xl bg-amber-700 hover:bg-amber-600 font-semibold text-sm sm:text-base">手動で釣行を登録</button>
            <button id="homeAddManualCatch" class="flex-1 py-2 rounded-xl bg-sky-700 hover:bg-sky-600 font-semibold text-sm sm:text-base">手動で釣果を追加</button>
          </div>
        </div>
      </div>
    </section>

    <!-- ★新規：シート設定（ホーム画面の直後） -->
    <section id="settingsView" class="hidden">
      <div class="rounded-2xl bg-slate-900 border border-slate-800 p-4 mb-4">
        <h2 class="text-xl font-semibold">設定</h2>
        <p class="text-sm text-slate-400 mt-1">スプレッドシートの設定</p>
      </div>

      <!-- スプレッドシート ID 設定（統合） -->
      <div class="rounded-2xl bg-slate-900 border border-slate-800 p-4 mb-4">
        <h3 class="text-base font-semibold mb-3">スプレッドシート ID</h3>
        <div class="space-y-3">
          <label class="block">
            <span class="text-xs text-slate-400">スプレッドシートID（Trips/Catches 両方で使用）</span>
            <input id="sheetId" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm" placeholder="スプレッドシートID を入力してください" />
          </label>
          <div class="flex gap-2">
            <button id="btnSaveSheetConfig" class="px-3 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500 font-semibold text-sm">保存</button>
            <div id="sheetConfigStatus" class="text-sm text-slate-300 self-center"></div>
          </div>
        </div>
      </div>
      
      <!-- 列マッピング（設定画面に移動） -->
      <details class="rounded-2xl bg-slate-900 border border-slate-800 p-4 mb-4">
        <summary class="cursor-pointer text-base font-semibold">列マッピング設定</summary>
        <div class="mt-3">
          <div class="grid sm:grid-cols-3 gap-3">
            <label class="block text-sm">写真<select id="mapPhoto" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">日付<select id="mapDate" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">時刻<select id="mapTime" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">魚種<select id="mapSpecies" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">サイズ(cm)<select id="mapSize" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">地点名<select id="mapPlace" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">緯度<select id="mapLat" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">経度<select id="mapLng" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">潮<select id="mapTideName" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">潮位<select id="mapTideLevel" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">潮位傾向<select id="mapTideTrend" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">満潮<select id="mapHighTide" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">干潮<select id="mapLowTide" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">メモ<select id="mapNotes" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
          </div>
          <div class="mt-3 flex gap-2">
            <button id="btnSaveMapping" class="px-3 py-1.5 rounded-xl bg-sky-600 hover:bg-sky-500 text-sm font-semibold">
              マッピングを保存
            </button>
            <button id="btnResetMapping" class="px-3 py-1.5 rounded-xl border border-slate-700 hover:bg-slate-800 text-sm">
              保存をクリア
            </button>
            <span id="mappingStatus" class="text-sm text-slate-300 ml-auto"></span>
          </div>
        </div>
      </details>

      <!-- ★追加：秘密情報設定（トークン・キー） -->
      <div class="rounded-2xl bg-slate-900 border border-slate-800 p-4 mb-4">
        <h3 class="text-base font-semibold mb-3">認証情報</h3>
        <p class="text-xs text-slate-400 mb-3">API 認証に必要な秘密情報を設定してください</p>
        <div class="space-y-3">
          <!-- Worker 認証トークン -->
          <label class="block">
            <span class="text-xs text-slate-400">Worker 認証トークン</span>
            <input id="workersAuthTokenEl" type="password" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm" placeholder="Worker 認証トークンを入力してください" />
          </label>

          <div class="flex gap-2">
            <button id="btnSaveSecrets" class="px-3 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500 font-semibold text-sm">保存</button>
            <div id="secretsStatus" class="text-sm text-slate-300 self-center"></div>
          </div>
        </div>
      </div>
    </section>

    <!-- 釣行の確認（Trips / GViz） -->
    <section id="tripsView" class="hidden">
      <div class="rounded-2xl bg-slate-900 border border-slate-800 p-4 mb-4">
        <h2 class="text-base font-semibold">釣行の確認</h2>
        <div id="tripStatus" class="text-sm text-slate-300 mt-2"></div>
        <div class="mt-3 flex gap-2">
          <button id="btnLoadTrips" class="px-3 py-2 rounded-xl bg-amber-700 hover:bg-amber-600 font-semibold text-sm">読込</button>
          <button id="btnClearTrips" class="px-3 py-2 rounded-xl border border-slate-700 hover:bg-slate-800 text-sm">クリア</button>
        </div>
      </div>

      <!-- 一覧 -->
      <div class="grid grid-cols-1 gap-3" id="tripList"></div>

      <!-- 詳細 -->
      <div id="tripDetail" class="hidden mt-4 rounded-2xl bg-slate-900 border border-slate-800 p-4">
        <div class="flex items-center justify-between mb-3">
          <h3 class="font-semibold">釣行の詳細</h3>
          <button id="btnCloseTripDetail" class="text-sm px-3 py-1.5 rounded-xl border border-slate-700 hover:bg-slate-800">閉じる</button>
        </div>
        <div id="tripDetailBody" class="space-y-4"></div>
        <button id="tripEditBtn" class="w-full mt-4 px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded font-semibold text-white text-sm">✎ 編集</button>
      </div>
    </section>

    <!-- 釣果の確認（GViz） -->
    <section id="catchesView" class="hidden">
      <div class="rounded-2xl bg-slate-900 border border-slate-800 p-4 mb-4">
        <h2 class="text-base font-semibold">釣果の確認</h2>
        <div id="catchesStatus" class="text-sm text-slate-300 mt-2"></div>
        <div class="mt-3 flex gap-2">
          <button id="btnLoadSheet" class="px-3 py-2 rounded-xl bg-sky-600 hover:bg-sky-500 font-semibold text-sm">読込</button>
          <button id="btnClearSheet" class="px-3 py-2 rounded-xl border border-slate-700 hover:bg-slate-800 text-sm">クリア</button>
        </div>
      </div>

      </div>

        <!-- 一覧 -->
        <div class="grid grid-cols-1 gap-3" id="remoteCatchList"></div>

        <!-- 詳細パネル -->
        <div id="remoteCatchDetail" class="hidden mt-4 rounded-2xl bg-slate-900 border border-slate-800 p-4">
          <div class="flex items-center justify-between mb-3">
            <h3 class="font-semibold">詳細</h3>
            <button id="btnCloseDetail" class="text-sm px-3 py-1.5 rounded-xl border border-slate-700 hover:bg-slate-800">閉じる</button>
          </div>
          <div id="detailBody" class="space-y-4"></div>
        </div>
      </section>

    <!-- 釣行の記録 -->
    <section id="recordView" class="hidden">
      <div class="rounded-2xl bg-slate-900 border border-slate-800 p-4 flex flex-col gap-2 mb-4">
        <div class="flex items-center justify-between">
          <div>
            <div class="text-slate-400 text-sm">現在のステータス</div>
            <div id="txtStatus" class="text-xl font-bold">未開始</div>
          </div>
          <div class="text-right text-sm text-slate-400">
            <div>Trip ID: <span id="txtTripId">—</span></div>
            <div id="txtPos" class="hidden">位置: <span id="txtLat"></span>, <span id="txtLng"></span></div>
          </div>
        </div>

        <!-- 開始時間と天気を2カラム -->
        <div class="grid grid-cols-2 gap-2 mt-2">
          <div class="rounded-xl bg-slate-800/40 p-3">
            <div class="text-xs text-slate-400">開始</div>
            <div id="txtStartedAt" class="text-sm break-all">—</div>
          </div>
          <div id="tripWeatherBoxTop" class="rounded-xl bg-slate-800/40 p-3">
            <div class="text-xs text-slate-400">天気</div>
            <div id="tripWeatherTop" class="text-sm">—</div>
          </div>
        </div>

        <!-- 潮情報・水温を1カラムでまとめる -->
        <div id="tripWeatherRow" class="grid grid-cols-1 gap-2 mt-2"></div>

        <div id="buttonRow" class="flex gap-2 mt-2"></div>
      </div>

      <section>
        <div class="flex items-baseline gap-3 mb-2">
          <h2 class="text-base font-semibold">釣果</h2>
          <div id="txtCatchCount" class="text-2xl font-bold text-sky-300">0 件</div>
        </div>
        <div id="catchListEmpty" class="text-slate-400 text-sm">まだ登録がありません。<span id="hintAddWhenActive" class="hidden">「＋釣果」から追加できます。</span></div>
        <ul id="catchList" class="space-y-2"></ul>
      </section>

      <div id="bottomBar" class="hidden fixed bottom-0 left-0 right-0 border-t border-slate-800 bg-slate-950/80 backdrop-blur">
        <div class="max-w-4xl mx-auto px-4 py-3 grid grid-cols-3 gap-2">
          <button id="btnAddCatchBottom" class="py-3 rounded-2xl bg-sky-600 hover:bg-sky-500 font-semibold">＋釣果</button>
          <button id="btnCancelTrip" class="py-3 rounded-2xl bg-slate-700 hover:bg-slate-600 font-semibold">キャンセル</button>
          <button id="btnEndBottom" class="py-3 rounded-2xl bg-rose-600 hover:bg-rose-500 font-semibold">釣行終了</button>
        </div>
      </div>

      <!-- 釣果モーダル -->
      <div id="catchModal" class="hidden fixed inset-0 z-20 bg-black/60 grid place-items-center p-4">
        <div class="w-full max-w-md rounded-2xl bg-slate-900 border border-slate-800 p-4" onclick="event.stopPropagation()">
          <div class="flex items-center justify-between mb-2">
            <h3 id="modalTitle" class="font-semibold">釣果を追加</h3>
            <button id="btnCloseModal" class="text-slate-400 hover:text-slate-200">×</button>
          </div>
          <div class="space-y-3">
            <label class="block"><span class="text-sm text-slate-300">時刻</span>
              <input id="inpCatchTime" type="text" placeholder="YYYY-MM-DDTHH:MM" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" />
            </label>
            <label class="block"><span class="text-sm text-slate-300">魚種</span>
              <input id="inpSpecies" type="text" placeholder="例：アジ" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" />
            </label>
            <div class="grid grid-cols-2 gap-3">
              <label class="block"><span class="text-sm text-slate-300">サイズ(cm)</span>
                <input id="inpSize" type="number" inputmode="decimal" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" />
              </label>
              <label class="block"><span class="text-sm text-slate-300">重量(g)</span>
                <input id="inpWeight" type="number" inputmode="decimal" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" />
              </label>
            </div>
            <label class="block"><span class="text-sm text-slate-300">方法（ルアー/リグ 等）</span>
              <input id="inpMethod" type="text" placeholder="例：メタルジグ 20g" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" />
            </label>
            <label class="block"><span class="text-sm text-slate-300">写真</span>
              <input id="inpPhoto" type="file" accept="image/*" class="mt-1 w-full text-sm" />
              <img id="imgPreview" alt="preview" class="hidden mt-2 h-32 w-full object-cover rounded-xl border border-slate-800" />
            </label>
          </div>
          <div class="flex gap-2 mt-4">
            <button id="btnCancelCatch" class="flex-1 py-2 rounded-xl border border-slate-700 hover:bg-slate-800">キャンセル</button>
            <button id="btnSaveCatch" class="flex-1 py-2 rounded-2xl bg-sky-600 hover:bg-sky-500 font-semibold">保存</button>
          </div>
        </div>
      </div>

      <!-- ★追加: 手動釣行登録モーダル -->
      <div id="tripModal" class="hidden fixed inset-0 z-20 bg-black/60 grid place-items-center p-4">
        <div class="w-full max-w-lg rounded-2xl bg-slate-900 border border-slate-800 p-4" onclick="event.stopPropagation()">
          <div class="flex items-center justify-between mb-2">
            <h3 class="font-semibold">手動で釣行を登録</h3>
            <button id="btnCloseTripModal" class="text-slate-400 hover:text-slate-200">×</button>
          </div>
          <div class="space-y-3">
            <label class="block"><span class="text-sm text-slate-300">開始日時（空ならEXIFから補完）</span>
              <input id="inpTripStart" type="text" placeholder="YYYY-MM-DDTHH:MM" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" />
            </label>
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
              <label class="block">
                <span class="text-sm text-slate-300">緯度（任意）</span>
                <input id="inpTripLat" type="number" step="any" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" />
              </label>
              <label class="block">
                <span class="text-sm text-slate-300">経度（任意）</span>
                <input id="inpTripLng" type="number" step="any" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" />
              </label>
            </div>
            <p class="text-xs text-slate-400">※ 緯度・経度があると、開始天気・開始潮汐・水温を自動取得します。</p>
          </div>
          <div class="flex gap-2 mt-4">
            <button id="btnCancelTripModal" class="flex-1 py-2 rounded-2xl bg-slate-700 hover:bg-slate-600 font-semibold">キャンセル</button>
            <button id="btnSaveTrip" class="flex-1 py-2 rounded-2xl bg-indigo-600 hover:bg-indigo-500 font-semibold">登録</button>
          </div>
        </div>
      </div>


      <!-- 釣行アップロード確認モーダル -->
      <div id="uploadReviewModal" class="hidden fixed inset-0 z-30 bg-black/60 grid place-items-center p-4">
        <div class="w-full max-w-lg rounded-2xl bg-slate-900 border border-slate-800 p-4" onclick="event.stopPropagation()">
          <div class="flex items-center justify-between mb-2">
            <h3 class="font-semibold">アップロードの確認</h3>
            <button id="btnCloseUploadReview" class="text-slate-400 hover:text-slate-200">×</button>
          </div>
          <div id="uploadReviewBody" class="text-sm text-slate-200 space-y-2 max-h-[45vh] overflow-auto"></div>
          
          <!-- ★追加：メモ入力欄 -->
          <div class="mt-4 pt-4 border-t border-slate-800">
            <label class="block">
              <span class="text-sm text-slate-300 mb-2 block">メモ（オプション）</span>
              <textarea id="tripMemoInput" 
                class="w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm text-slate-100 placeholder-slate-600"
                placeholder="この釣行についてのメモを入力してください..."
                rows="3"></textarea>
            </label>
          </div>
          
          <div class="flex gap-2 mt-4">
            <button id="btnCancelUpload" class="flex-1 py-2 rounded-xl border border-slate-700 hover:bg-slate-800">釣行を続ける</button>
            <button id="btnConfirmUpload" class="flex-1 py-2 rounded-2xl bg-sky-600 hover:bg-sky-500 font-semibold">アップロード</button>
          </div>
        </div>
      </div>

    </section>
  </main>

  <!-- ★修正：オーバーレイを main の外に移動（z-index が効くようにするため） -->
  <div id="uploadingOverlay" class="hidden fixed inset-0 z-[9999] bg-black/80 flex items-center justify-center" style="pointer-events: auto;">
    <div class="text-center pointer-events-none">
      <div class="mb-4">
        <div class="inline-block">
          <div class="animate-spin rounded-full h-12 w-12 border-4 border-slate-600 border-t-sky-500"></div>
        </div>
      </div>
      <div id="uploadingMessage" class="text-slate-100 text-lg font-semibold">処理中...</div>
      <div class="text-slate-400 text-sm mt-2">しばらくお待ちください</div>
    </div>
  </div>

  <script>
    // ===== Development: Initialize localStorage for testing =====
    // ★修正：秘密情報（トークン、キー）をハードコードから削除
    const devConfig = {
      // 公開情報のみ（秘密情報は設定画面で入力）
      'FISHING_TRIP_API_WORKER': 'https://fishing-trip-api.yuji-fallline2999m.workers.dev',
      'WORKER_PROXY_URL': 'https://noisy-grass-c7e9.yuji-fallline2999m.workers.dev',
      'TIDE_PROXY_URL': 'https://jolly-voice-b254.yuji-fallline2999m.workers.dev',
      'WATER_WORKER_URL': 'https://rough-math-5fec.yuji-fallline2999m.workers.dev',
      'CLOUDINARY_CLOUD_NAME': 'drcaeidmm',
      'CLOUDINARY_UPLOAD_PRESET': 'unsigned'
      // ★削除：WORKERS_AUTH_TOKEN（ユーザーが設定画面で入力）
      // ★削除：RAPIDAPI_KEY（ユーザーが設定画面で入力）
    };

    // ★追加：ローカルホスト環境かを判定
    const isLocalhost = () => {
      return window.location.hostname === 'localhost' || 
             window.location.hostname === '127.0.0.1' ||
             window.location.hostname === '::1';
    };

    // ★追加：ローカルホストのみ devConfig を初期化（ハイブリッドストレージ経由）
    const initializeDevConfig = async () => {
      if (!isLocalhost()) return;
      for (const [key, value] of Object.entries(devConfig)) {
        const existing = await configStorage.getItem(key);
        if (!existing) {
          await configStorage.setItem(key, value);
        }
      }
      console.log('[DevConfig] defaults ensured for localhost');
    };

    // ===== ハイブリッドストレージ（localStorage + IndexedDB） =====
    class ConfigStorage {
      constructor() {
        this.db = null;
        this.isIndexedDBAvailable = 'indexedDB' in window;
      }

      async init() {
        if (!this.isIndexedDBAvailable) return;
        return new Promise((resolve) => {
          const req = indexedDB.open('FishLogConfig', 1);
          req.onupgradeneeded = (e) => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains('config')) {
              db.createObjectStore('config', { keyPath: 'key' });
              console.log('[ConfigStorage] IndexedDB initialized');
            }
          };
          req.onsuccess = () => {
            this.db = req.result;
            console.log('[ConfigStorage] IndexedDB ready');
            resolve();
          };
          req.onerror = () => {
            console.warn('[ConfigStorage] IndexedDB init failed');
            resolve();
          };
        });
      }

      async getItem(key) {
        try {
          const value = localStorage.getItem(key);
          if (value !== null) {
            console.log('[ConfigStorage] loaded from localStorage:', key);
            return value;
          }
        } catch (e) {
          console.warn('[ConfigStorage] localStorage unavailable:', e.message);
        }

        // IndexedDB にフォールバック
        if (this.db) {
          return new Promise((resolve) => {
            const tx = this.db.transaction('config', 'readonly');
            const req = tx.objectStore('config').get(key);
            req.onsuccess = () => {
              const value = req.result?.value;
              if (value) {
                console.log('[ConfigStorage] loaded from IndexedDB:', key);
              }
              resolve(value || null);
            };
            req.onerror = () => resolve(null);
          });
        }

        return null;
      }

      async setItem(key, value) {
        try {
          localStorage.setItem(key, value);
          console.log('[ConfigStorage] saved to localStorage:', key);
        } catch (e) {
          console.warn('[ConfigStorage] localStorage unavailable:', e.message);
        }

        // IndexedDB にも保存
        if (this.db) {
          return new Promise((resolve) => {
            const tx = this.db.transaction('config', 'readwrite');
            const req = tx.objectStore('config').put({ key, value });
            req.onsuccess = () => {
              console.log('[ConfigStorage] saved to IndexedDB:', key);
              resolve();
            };
            req.onerror = () => {
              console.warn('[ConfigStorage] IndexedDB save failed:', key);
              resolve();
            };
          });
        }
      }

      async removeItem(key) {
        try {
          localStorage.removeItem(key);
          console.log('[ConfigStorage] removed from localStorage:', key);
        } catch (e) {
          console.warn('[ConfigStorage] localStorage unavailable');
        }

        if (this.db) {
          return new Promise((resolve) => {
            const tx = this.db.transaction('config', 'readwrite');
            tx.objectStore('config').delete(key);
            resolve();
          });
        }
      }
    }

    const configStorage = new ConfigStorage();
    
    // ===== Configuration (環境変数から読み込み、デフォルト値を使用) =====
    let CONFIG = {
      API: {
        FISHING_TRIP_API_WORKER: 'https://fishing-trip-api.yuji-fallline2999m.workers.dev',
        WORKERS_AUTH_TOKEN: "",
        WORKER_PROXY_URL: "",
        TIDE_PROXY_URL: "",
        WATER_WORKER_URL: "",
        CLOUDINARY_CLOUD_NAME: "drcaeidmm",
        CLOUDINARY_UPLOAD_PRESET: "unsigned"
      },
      TIMEOUT: {
        WEATHER: 10000,
        TIDE: 8000,
        WATER: 8000,
        GAS: 15000
      }
    };

    // 非同期で設定値を読み込み
    const loadConfigFromStorage = async () => {
      CONFIG.API.FISHING_TRIP_API_WORKER = await configStorage.getItem('FISHING_TRIP_API_WORKER') || 'https://fishing-trip-api.yuji-fallline2999m.workers.dev';
      CONFIG.API.WORKERS_AUTH_TOKEN = await configStorage.getItem('WORKERS_AUTH_TOKEN') || "";
      CONFIG.API.WORKER_PROXY_URL = await configStorage.getItem('WORKER_PROXY_URL') || "";
      CONFIG.API.TIDE_PROXY_URL = await configStorage.getItem('TIDE_PROXY_URL') || "";
      CONFIG.API.WATER_WORKER_URL = await configStorage.getItem('WATER_WORKER_URL') || "";
      CONFIG.API.CLOUDINARY_CLOUD_NAME = await configStorage.getItem('CLOUDINARY_CLOUD_NAME') || "drcaeidmm";
      CONFIG.API.CLOUDINARY_UPLOAD_PRESET = await configStorage.getItem('CLOUDINARY_UPLOAD_PRESET') || "unsigned";
      
      console.log('[CONFIG] loaded successfully');
      console.log('[CONFIG] FISHING_TRIP_API_WORKER:', CONFIG.API.FISHING_TRIP_API_WORKER);
      console.log('[CONFIG] WORKERS_AUTH_TOKEN:', CONFIG.API.WORKERS_AUTH_TOKEN ? '***' : 'empty');
      console.log('[CONFIG] WORKERS_AUTH_TOKEN actual length:', CONFIG.API.WORKERS_AUTH_TOKEN.length);
    };

    // IndexedDB の初期化と設定読み込み
    (async () => {
      await configStorage.init();
      await initializeDevConfig();
      await loadConfigFromStorage();
    })();

    // ===== Logger =====
    const DEBUG_WATER = true; // 必要に応じて true/false で出力を切替

    window.LOG = window.LOG || {};
    window.LOG.geo  = window.LOG.geo  || ((...a)=>console.debug("[Geo]", ...a));
    window.LOG.wx   = window.LOG.wx   || ((...a)=>console.warn("[Weather]", ...a));
    window.LOG.app  = window.LOG.app  || ((...a)=>console.debug("[FishLog]", ...a));
    window.LOG.tide = window.LOG.tide || ((...a)=>console.debug("[Tide]", ...a));
    // ★追加: 水温専用ロガー
    window.LOG.wt   = window.LOG.wt   || ((...a)=>console.debug("[WaterTemp]", ...a));

    // ===== ナビゲーション =====
    const navHome = document.getElementById('navHome');
    const navRecord = document.getElementById('navRecord');
    const navTrips = document.getElementById('navTrips');            // ★追加
    const navCatches = document.getElementById('navCatches');
    const homeView = document.getElementById('homeView');
    const recordView = document.getElementById('recordView');
    const tripsView = document.getElementById('tripsView');          // ★追加
    const catchesView = document.getElementById('catchesView');
    const settingsView = document.getElementById('settingsView');    // ★追加
    document.getElementById('homeGoRecord').onclick = () => { showView('record'); };
    document.getElementById('homeGoTrips').onclick = () => { showView('trips'); autoLoadTrips(); };   // ★追加
    document.getElementById('homeGoCatches').onclick = () => { showView('catches'); autoLoadCatches(); };
    navHome.onclick = () => showView('home');
    navRecord.onclick = () => showView('record');
    navTrips.onclick = () => { showView('trips'); autoLoadTrips(); };                                  // ★追加
    navCatches.onclick = () => { showView('catches'); autoLoadCatches(); };
    document.getElementById('navSettings').onclick = () => { showView('settings'); };

    // ★追加：ホームの「手動で釣果追加」ボタン（id="homeAddManualCatch"）に紐付け
    const btnAddManualFromHome = document.getElementById('homeAddManualCatch');
    btnAddManualFromHome && (btnAddManualFromHome.onclick = openManualCatch);
    function showView(name){
      homeView.classList.toggle('hidden', name !== 'home');
      recordView.classList.toggle('hidden', name !== 'record');
      tripsView.classList.toggle('hidden', name !== 'trips');    // ★追加
      catchesView.classList.toggle('hidden', name !== 'catches');
      settingsView.classList.toggle('hidden', name !== 'settings'); // ★追加
    }
    showView('home');


    // ===== JSTのオフセット付きISO =====
    function toOffsetIsoLocal(d){
      const pad = n => String(n).padStart(2,'0');
      const y = d.getFullYear();
      const m = pad(d.getMonth()+1);
      const da = pad(d.getDate());
      const hh = pad(d.getHours());
      const mi = pad(d.getMinutes());
      const ss = pad(d.getSeconds());
      const offMin = -d.getTimezoneOffset();
      const sign = offMin >= 0 ? '+' : '-';
      const abs = Math.abs(offMin);
      const oh = pad(Math.floor(abs/60));
      const om = pad(abs%60);
      return `${y}-${m}-${da}T${hh}:${mi}:${ss}${sign}${oh}:${om}`;
    }
    function nowIsoLocal(){ return toOffsetIsoLocal(new Date()); }
    function toLocalInputValue(d){
      const pad = n => String(n).padStart(2,'0');
      return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
    }

    // ===== 天気ユーティリティ =====
    function windDegToCardinal(deg){
      if (typeof deg !== 'number' || isNaN(deg)) return '';
      const d = ((deg % 360) + 360) % 360;
      const dirs = ['北','北北東','北東','東北東','東','東南東','南東','南南東','南','南南西','南西','西南西','西','西北西','北西','北北西'];
      const idx = Math.round(d / 22.5) % 16;
      return dirs[idx];
    }
    function formatWeatherBrief(wx){
      if (!wx) return '';
      const parts = [];
      const desc = wx.weather_description || wx.weather_main || '';
      if (desc) parts.push(desc);
      if (typeof wx.temp === 'number') parts.push(`${Math.round(wx.temp * 10) / 10}℃`);
      const sp = (typeof wx.wind_speed === 'number') ? `${Math.round(wx.wind_speed * 10) / 10}m/s` : '';
      const dir = windDegToCardinal(wx.wind_deg);
      if (sp || dir) parts.push(` ${[sp, dir].filter(Boolean).join(' ')}`);
      return parts.join(' / ');
    }

    // ===== OWM（開始/終了時の天気）- Cloudflare Worker プロキシ経由 =====
    const WORKER_PROXY_URL = CONFIG.API.WORKER_PROXY_URL;
    
    // ★テスト：Worker プロキシが起動したらすぐテストする
    (async () => {
      console.log("[INIT] Testing Worker proxy connectivity...");
      try {
        const testRes = await fetch(WORKER_PROXY_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ lat: 34.62, lng: 135.05, isHistorical: false })
        });
        console.log("[INIT] Worker proxy response status:", testRes.status);
        const testData = await testRes.json();
        console.log("[INIT] Worker proxy response data:", testData);
      } catch(e) {
        console.error("[INIT] Worker proxy test failed:", e);
      }
    })();
    
    // ★追加：JST タイムスタンプを Unix タイムスタンプ（秒）に変換
    function getJSTTimestampForOWM(date = null){
      if (!date) return Math.floor(Date.now() / 1000); // 現在時刻
      
      // ★修正：文字列か Date オブジェクトかを判定
      let targetDate;
      if (typeof date === 'string') {
        targetDate = new Date(date);
      } else if (date instanceof Date) {
        targetDate = date;
      } else {
        targetDate = new Date(date);
      }
      
      // date が 'YYYY-MM-DDTHH:MM:SS+09:00' 形式の場合、
      // new Date() は自動的に +09:00 を UTC オフセットとして処理し、
      // UTC ミリ秒を返す。つまり getTime() は既に正しい Unix ミリ秒
      // 例：'2025-11-17T06:49:10+09:00' → getTime() = 2025-11-16T21:49:10Z のミリ秒
      // これが正しい Unixタイムスタンプ
      return Math.floor(targetDate.getTime() / 1000);
    }
    
    async function fetchWeather(lat, lng, targetDate = null, timeoutMs = 10000){
      console.log("[fetchWeather] *** CALLED ***", { lat, lng, targetDate });
      if (typeof lat !== 'number' || typeof lng !== 'number') throw new Error("座標が未設定です");
      
      const jstTimestamp = getJSTTimestampForOWM(targetDate);
      const nowTimestamp = Math.floor(Date.now() / 1000);
      const isHistorical = targetDate !== null && jstTimestamp < nowTimestamp;
      
      // ★リクエストボディを構築
      const requestBody = {
        lat: lat,
        lng: lng,
        isHistorical: isHistorical,
        dt: isHistorical ? jstTimestamp : undefined
      };
      
      // ★デバッグログ：プロキシへのリクエスト
      console.log("[fetchWeather] Sending to Cloudflare Worker:", {
        workerUrl: WORKER_PROXY_URL,
        requestBody: requestBody,
        targetDate: targetDate ? (typeof targetDate.toISOString === 'function' ? targetDate.toISOString() : String(targetDate)) : "(current)",
        isHistorical: isHistorical,
        jstTimestamp: jstTimestamp,
        nowTimestamp: nowTimestamp
      });
      
      LOG.wx("[fetchWeather] Request to Worker:", {
        lat: lat,
        lng: lng,
        isHistorical: isHistorical,
        dt: isHistorical ? jstTimestamp : "(current)",
        jst_datetime: targetDate ? (typeof targetDate.toISOString === 'function' ? targetDate.toISOString() : String(targetDate)) : new Date().toISOString(),
        workerUrl: WORKER_PROXY_URL
      });
      
      const ctrl = new AbortController();
      const t = setTimeout(() => ctrl.abort("timeout"), timeoutMs);
      try {
        const res = await fetch(WORKER_PROXY_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(requestBody),
          signal: ctrl.signal
        });
        
        if (!res.ok) {
          let msg = `HTTP ${res.status}`;
          try { const err = await res.json(); if (err?.message) msg += `: ${err.message}`; } catch {}
          console.error("[fetchWeather] Worker returned error:", msg);
          throw new Error(msg);
        }
        
        const j = await res.json();
        console.log("[fetchWeather] Worker response received:", j);
        
        // ★ログ：レスポンス値
        const data = isHistorical ? (j.data?.[0] || {}) : (j.current || {});
        const rain1h = data.rain?.["1h"];
        const snow1h = data.snow?.["1h"];
        console.log("[fetchWeather] Extracted data:", { data, rain1h, snow1h });
        LOG.wx("[fetchWeather] Response:", {
          timestamp_utc: new Date(data.dt * 1000).toISOString(),
          timezone: j.timezone,
          timezone_offset_sec: j.timezone_offset,
          temp: data.temp,
          feels_like: data.feels_like,
          pressure: data.pressure,
          humidity: data.humidity,
          wind_speed: data.wind_speed,
          wind_deg: data.wind_deg,
          wind_gust: data.wind_gust,
          clouds: data.clouds,
          visibility: data.visibility,
          weather_main: data.weather?.[0]?.main,
          weather_description: data.weather?.[0]?.description,
          rain_1h: rain1h,
          snow_1h: snow1h
        });
        
        return mapWeather(j, lat, lng);
      } catch (err) {
        console.error("[fetchWeather] Error:", err);
        throw err;
      } finally { clearTimeout(t); }
    }
    function mapWeather(j, lat, lng){
      // One Call API 3.0 のレスポンス形式
      // timemachine の場合は data[0]、current & forecast の場合は current を使用
      const data = j.data?.[0] || j.current || {};
      const w = (data.weather && data.weather[0]) || {};
      const rain1h = data.rain?.["1h"];
      const snow1h = data.snow?.["1h"];
      
      // ★修正：One Call API のタイムゾーン情報を使用
      const utcTimestamp = data.dt; // Unix タイムスタンプ（秒、UTC）
      const timezoneOffset = j.timezone_offset || 0; // 秒単位のオフセット
      const jstTimestamp = utcTimestamp + timezoneOffset;
      
      return {
        timestamp: new Date(jstTimestamp * 1000).toISOString(), // ローカルタイムゾーン時刻（ISO形式）
        timestamp_jst_unix: jstTimestamp, // ローカルタイムゾーンの Unix タイムスタンプ
        timezone: j.timezone, // タイムゾーン文字列（例："Asia/Tokyo"）
        timezone_offset_sec: timezoneOffset, // UTC からのオフセット（秒）
        source: "owm:3.0/onecall",
        coord: { lat: lat ?? j.lat ?? null, lng: lng ?? j.lon ?? null },
        temp: data.temp ?? null,
        feels_like: data.feels_like ?? null,
        pressure: data.pressure ?? null,
        humidity: data.humidity ?? null,
        dew_point: data.dew_point ?? null,
        uvi: data.uvi ?? null,
        wind_speed: data.wind_speed ?? null,
        wind_deg: data.wind_deg ?? null,
        wind_gust: data.wind_gust ?? null,
        clouds: data.clouds ?? null,
        visibility: data.visibility ?? null,
        rain_1h: rain1h ?? null,
        snow_1h: snow1h ?? null,
        weather_id: w.id ?? null,
        weather_main: w.main ?? null,
        weather_description: w.description ?? null,
        raw: j
      };
    }

    // ★追加：緯度経度から海域コードを取得する（簡易版：緯度経度の範囲で判定）
    function getSeaAreaCodeFromCoords(lat, lng) {
      // 日本周辺の主要な漁場コードマッピング（経度・緯度の範囲で判定）
      // 実際のコード体系に合わせて調整してください
      const areas = [
        { code: 'hy3004', name: '瀬戸内海東部', minLat: 33.5, maxLat: 35.5, minLng: 132, maxLng: 135 },
        { code: 'hy3003', name: '瀬戸内海西部', minLat: 33, maxLat: 34.5, minLng: 130, maxLng: 132 },
        { code: 'hy3001', name: '日本海', minLat: 35, maxLat: 43, minLng: 128, maxLng: 141 },
        { code: 'hy3005', name: '関東沖', minLat: 33, maxLat: 37, minLng: 140, maxLng: 145 },
      ];
      
      for (const area of areas) {
        if (lat >= area.minLat && lat <= area.maxLat && lng >= area.minLng && lng <= area.maxLng) {
          return area.code;
        }
      }
      
      // デフォルト：瀬戸内海東部
      return 'hy3004';
    }

    // ★追加：過去30日分の海水温データから、指定日付の水温を取得
    async function getWaterTempForDate(lat, lng, targetDate) {
      try {
        // targetDate: "2025-11-05" 形式の文字列
        const code = getSeaAreaCodeFromCoords(lat, lng);
        
        // ★修正：プロキシ経由でAPIを呼び出し
        if (!WATER_WORKER_URL || /your[_-]?worker/i.test(WATER_WORKER_URL)){
          LOG.app("[WaterTemp] past API proxy not configured", { WATER_WORKER_URL });
          return null;
        }
        
        const baseUrl = `https://leisure-api-prod.n-kishou.co.jp/get-sea-water-temperature?code=${encodeURIComponent(code)}&type=past`;
        const proxyUrl = `${WATER_WORKER_URL.replace(/\/$/, '')}/proxy?url=${encodeURIComponent(baseUrl)}`;
        
        LOG.app("[WaterTemp] fetching past data via proxy", { code, targetDate, baseUrl, proxyUrl });
        
        const res = await fetch(proxyUrl, { 
          method: 'GET',
          timeout: 10000 
        });
        
        LOG.app("[WaterTemp] past API response status", { status: res.status, ok: res.ok });
        
        if (!res.ok) {
          console.warn(`[WaterTemp] API returned ${res.status}`);
          LOG.app("[WaterTemp] past API returned error status", { status: res.status });
          return null;
        }
        
        const data = await res.json();
        
        // ★修正：APIレスポンス構造を正しくパース
        // 構造: { result_list: { data: { graph_data_main: [...] } } }
        let dataArray = null;
        
        if (data?.result_list?.data?.graph_data_main && Array.isArray(data.result_list.data.graph_data_main)) {
          // 正常系：graph_data_main配列を取得
          dataArray = data.result_list.data.graph_data_main;
          LOG.app("[WaterTemp] ★extracted graph_data_main array", { 
            length: dataArray.length,
            sampleDate: dataArray[0]?.datetime?.substring(0, 10),
            sampleTemp: dataArray[0]?.temperature
          });
        } else {
          LOG.app("[WaterTemp] past API response structure not as expected", { 
            type: typeof data,
            hasResultList: !!data?.result_list,
            hasData: !!data?.result_list?.data,
            hasGraphDataMain: !!data?.result_list?.data?.graph_data_main,
            isArray: Array.isArray(data?.result_list?.data?.graph_data_main)
          });
          return null;
        }
        
        // ★修正：datetime フィールドから日付を抽出してマッチング
        // datetime 形式: "2025-11-05T00:00:00+09:00"
        const matching = dataArray.find(item => {
          if (!item.datetime) return false;
          const itemDate = item.datetime.substring(0, 10);  // "2025-11-05"
          return itemDate === targetDate;
        });
        
        if (matching) {
          const temp = parseFloat(matching.temperature);
          LOG.app("[WaterTemp] ★found matching past data for date", {
            date: matching.datetime.substring(0, 10),
            temperature_c: temp
          });
          
          return {
            temperature_c: temp,
            date: matching.datetime.substring(0, 10)
          };
        } else {
          LOG.app("[WaterTemp] no matching date found in past data", { 
            targetDate, 
            dataLength: dataArray.length,
            firstDate: dataArray[0]?.datetime?.substring(0, 10),
            lastDate: dataArray[dataArray.length-1]?.datetime?.substring(0, 10)
          });
          return null;
        }
        
      } catch (ex) {
        console.warn('[WaterTemp] fetch failed:', ex?.message || ex);
        LOG.app("[WaterTemp] past API fetch exception", { error: ex?.message || String(ex) });
        return null;
      }
    }

    // ★追加：手動追加の場合、開始日が今日以外なら過去データから水温を取得
    async function getWaterTempForManualEntry(lat, lng, startedAtIso, isManual = false) {
      if (!isManual) return null;
      
      const startDate = new Date(startedAtIso);
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      startDate.setHours(0, 0, 0, 0);
      
      LOG.app("[WaterTemp] getWaterTempForManualEntry check", {
        startedAtIso,
        startDateStr: startDate.toISOString().substring(0, 10),
        todayStr: today.toISOString().substring(0, 10),
        isToday: startDate.getTime() === today.getTime()
      });
      
      // 開始日が今日以外なら、過去データから取得
      if (startDate.getTime() !== today.getTime()) {
        const dateStr = startedAtIso.substring(0, 10); // "YYYY-MM-DD"
        LOG.app("[WaterTemp] requesting past data for date", { dateStr });
        const pastData = await getWaterTempForDate(lat, lng, dateStr);
        if (pastData) {
          LOG.app("[WaterTemp] got past data successfully", pastData);
          return pastData;
        } else {
          LOG.app("[WaterTemp] past data not found, will fallback to today");
        }
      } else {
        LOG.app("[WaterTemp] start date is today, will use current temp");
      }
      
      // 開始日が今日、または過去データが見つからない場合は null を返す
      // （現在の海水温取得ロジックに任せる）
      return null;
    }
    const SHEET_NAME = "Catches";
    const TRIPS_SHEET_NAME = "Trips";            // ← 追加: Trips を読む
    const HARBOR_SHEET_NAME = "港コード一覧";    // ← ここから港データ
    const POINTS_SHEET_NAME = "地点リスト";      // ★追加: 水温地点のマスタ（BuildPointsListが作る）

    // （※ 既存の Workers を使用：水温も TIDE_PROXY_URL を使う）
    const TIDE_PROXY_URL = CONFIG.API.TIDE_PROXY_URL;
        // ★水温API用 Worker URL（既存のものを使用）
    const WATER_WORKER_URL = CONFIG.API.WATER_WORKER_URL; 

    // ★修正：シートID を GAS から動的に取得する
    let SHEET_ID = ""; // GAS から起動時に取得
    
    const sheetIdEl = document.getElementById('sheetId');
    const btnSaveSheetConfig = document.getElementById('btnSaveSheetConfig');
    const sheetConfigStatus = document.getElementById('sheetConfigStatus');
    const btnLoadSheet = document.getElementById('btnLoadSheet');
    const btnClearSheet = document.getElementById('btnClearSheet');
    const sheetStatus = document.getElementById('catchesStatus');
    const mappingPanel = document.getElementById('mappingPanel');
    const mapPhoto = document.getElementById('mapPhoto');
    const mapDate = document.getElementById('mapDate');
    const mapTime = document.getElementById('mapTime');
    const mapSpecies = document.getElementById('mapSpecies');
    const mapSize = document.getElementById('mapSize');
    const mapPlace = document.getElementById('mapPlace');
    const mapLat = document.getElementById('mapLat');
    const mapLng = document.getElementById('mapLng');
    const mapTideName = document.getElementById('mapTideName');
    const mapTideLevel = document.getElementById('mapTideLevel');
    const mapTideTrend = document.getElementById('mapTideTrend');
    const mapHighTide = document.getElementById('mapHighTide');
    const mapLowTide = document.getElementById('mapLowTide');
    const mapNotes = document.getElementById('mapNotes');
    // ▼▼ マッピング保存UIの参照と永続化ヘルパ ▼▼
    const btnSaveMapping  = document.getElementById('btnSaveMapping');
    const btnResetMapping = document.getElementById('btnResetMapping');
    const mappingStatus   = document.getElementById('mappingStatus');

    const LS_MAP_KEY_PREFIX = 'fishlog_mapping_v1';
    const mappingKey = () => `${LS_MAP_KEY_PREFIX}:${SHEET_ID}:${SHEET_NAME}`;

    async function readSavedMapping(){
      try { 
        const data = await configStorage.getItem(mappingKey());
        return data ? JSON.parse(data) : null;
      } catch { 
        return null; 
      }
    }
    async function writeSavedMapping(){
      const obj = {
        photo: mapPhoto.value, date: mapDate.value, time: mapTime.value,
        species: mapSpecies.value, size: mapSize.value, place: mapPlace.value,
        lat: mapLat.value, lng: mapLng.value, tideName: mapTideName.value,
        tideLevel: mapTideLevel.value, tideTrend: mapTideTrend.value,
        highTide: mapHighTide.value, lowTide: mapLowTide.value, notes: mapNotes.value
      };
      try {
        await configStorage.setItem(mappingKey(), JSON.stringify(obj));
        if (mappingStatus){ mappingStatus.textContent = '保存しました'; setTimeout(()=> mappingStatus.textContent='', 1500); }
      } catch (err) {
        console.warn('[Mapping] Save failed:', err);
      }
    }
    async function applySavedMapping(){
      const s = await readSavedMapping();
      if (!s) return false;
      const set = (el, v) => { if (v != null) el.value = String(v); };
      set(mapPhoto, s.photo); set(mapDate, s.date); set(mapTime, s.time);
      set(mapSpecies, s.species); set(mapSize, s.size); set(mapPlace, s.place);
      set(mapLat, s.lat); set(mapLng, s.lng); set(mapTideName, s.tideName); set(mapTideLevel, s.tideLevel);
      set(mapTideTrend, s.tideTrend); set(mapHighTide, s.highTide); set(mapLowTide, s.lowTide); set(mapNotes, s.notes);
      return true;
    }
    btnSaveMapping  && (btnSaveMapping.onclick  = async () => { await writeSavedMapping(); });
    btnResetMapping && (btnResetMapping.onclick = async () => {
      try {
        await configStorage.removeItem(mappingKey());
        if (mappingStatus){ mappingStatus.textContent = '保存をクリアしました'; setTimeout(()=> mappingStatus.textContent='', 1500); }
      } catch (err) {
        console.warn('[Mapping] Clear failed:', err);
      }
    });
    
    // ★追加：キャッシュ変数の初期化
    let tripsCache = null;   // Trips シートのキャッシュ
    let catchesCache = null; // Catches シートのキャッシュ
    
    const remoteCatchList = document.getElementById('remoteCatchList');
    const detailWrap = document.getElementById('remoteCatchDetail');
    const btnCloseDetail = document.getElementById('btnCloseDetail');

    function gvizPayloadToRows(payload){
      const cols = (payload?.table?.cols || []).map(c => c.label || c.id || '');
      const rows = (payload?.table?.rows || []).map(r => {
        const arr = (r.c || []).map(c => c ? (c.v ?? c.f ?? '') : '');
        while (arr.length < cols.length) arr.push('');
        return arr;
      });
      return [cols, ...rows];
    }
    async function loadSheetViaGAS(sheetName, sheetId = null) {
      try {
        // sheetId が指定されていない場合は SHEET_ID を使用
        const id = (sheetId || SHEET_ID).trim();
        if (!id) throw new Error('Sheet ID が指定されていません');
        
        // ★修正：Worker 経由で GAS にアクセス（secrets 保護）
        const workerUrl = CONFIG.API.FISHING_TRIP_API_WORKER + '/api/getSheetData';
        console.log('[loadSheetViaGAS] Sending request to:', workerUrl);
        console.log('[loadSheetViaGAS] Auth Token:', CONFIG.API.WORKERS_AUTH_TOKEN ? `(${CONFIG.API.WORKERS_AUTH_TOKEN.length} chars)` : 'empty');
        
        const res = await fetch(workerUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Auth-Token': CONFIG.API.WORKERS_AUTH_TOKEN
          },
          body: JSON.stringify({
            sheetId: id,
            sheetName: sheetName
          })
        });
        
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const json = await res.json();
        if (!json.ok) throw new Error(json.error || 'Unknown error');
        return json.data; // [[header...], [row1...], [row2...], ...]
      } catch (err) {
        throw new Error(`Sheet load error (${sheetName}): ${err.message}`);
      }
    }

    function loadGVizViaJSONP(id, sheet, timeoutMs=12000){
      return new Promise((resolve, reject)=>{
        const url = `https://docs.google.com/spreadsheets/d/${id}/gviz/tq?tqx=out:json&sheet=${encodeURIComponent(sheet)}&_=${Date.now()}`;
        const g = (window.google = window.google || {});
        g.visualization = g.visualization || {};
        g.visualization.Query = g.visualization.Query || {};
        const prev = g.visualization.Query.setResponse;
        let settled=false;
        g.visualization.Query.setResponse = (payload)=>{
          if (settled) return; settled=true; cleanup();
          try { resolve(gvizPayloadToRows(payload)); } catch(e){ reject(e); }
        };
        const script=document.createElement('script');
        script.src=url; script.async=true;
        script.onerror=()=>{ if(settled) return; settled=true; cleanup(); reject(new Error('GVizの読み込みに失敗しました（ネットワーク/権限）')); };
        document.head.appendChild(script);
        const timer=setTimeout(()=>{ if(settled) return; settled=true; cleanup(); reject(new Error('GVizがタイムアウト（12秒）')); }, timeoutMs);
        function cleanup(){ clearTimeout(timer); try{script.remove();}catch{} g.visualization.Query.setResponse = prev; }
      });
    }

    // ===== 釣果（リモート閲覧UI） =====
    let lastRows = null;
    let lastHeaders = [];
    let hasLoadedOnce = false;

    // 追加: Trips の月情報マップ
    let tripsById = {}; // { [tripId]: { moon_visual, moon_age, moon_brightness } }

    // ★追加：GAS から SHEET_ID を取得
    async function initializeSheetId() {
      try {
        // ★修正：Worker 経由で GAS エンドポイントを呼び出す
        const workerUrl = CONFIG.API.FISHING_TRIP_API_WORKER + '/api/getSheetConfig';
        
        if (!workerUrl || !CONFIG.API.FISHING_TRIP_API_WORKER) {
          console.warn('[Init] FISHING_TRIP_API_WORKER not set');
          return;
        }
        
        console.log('[Init] Fetching SHEET_ID from Worker:', workerUrl);
        const res = await fetch(workerUrl + `?_=${Date.now()}`, {
          method: 'GET',
          headers: {
            'X-Auth-Token': CONFIG.API.WORKERS_AUTH_TOKEN
          }
        });
        const json = await res.json();
        console.log('[Init] Response:', json);
        
        if (json.ok && json.sheetId) {
          SHEET_ID = json.sheetId;
          console.log('[Init] SHEET_ID loaded from GAS via Worker:', SHEET_ID);
        } else {
          console.warn('[Init] GAS returned not ok or no sheetId:', json);
        }
      } catch (e) {
        console.warn('[Init] Failed to load SHEET_ID from GAS:', e?.message || e);
      }
    }

    function autoLoadCatches(){ if (!hasLoadedOnce && btnLoadSheet) btnLoadSheet.click(); }

    function parseGVizDate(str){
      if (typeof str !== 'string') return null;
      const m = str.match(/^Date\(([^)]+)\)/);
      if (!m) return null;
      const nums = m[1].split(',').map(n=>parseInt(n.trim(),10));
      if (!nums.length) return null;
      const [y, m0=0, d=1, hh=0, mi=0] = nums;
      const mm = Math.max(1, Math.min(12, m0 + 1));
      return { y, m:mm, d, hh, mi };
    }
    function z2(n){ return String(n).padStart(2,'0'); }
    function formatSheetDateTime(dateCell, timeCell){
      const d1 = parseGVizDate(String(dateCell||''));
      const t1 = parseGVizDate(String(timeCell||''));
      if (d1 || t1){
        const y = d1?.y ?? new Date().getFullYear();
        const m = d1?.m ?? (new Date().getMonth()+1);
        const d = d1?.d ?? new Date().getDate();
        const hh = t1?.hh ?? 0;
        const mi = t1?.mi ?? 0;
        return `${y}/${z2(m)}/${z2(d)} ${z2(hh)}:${z2(mi)}`;
      }
      const dateStr = (dateCell||'').toString().trim();
      const timeStr = (timeCell||'').toString().trim();
      if (dateStr || timeStr){
        const d = dateStr ? new Date(dateStr) : new Date();
        const ok = !isNaN(d.getTime());
        const y = ok ? d.getFullYear() : '';
        const m = ok ? z2(d.getMonth()+1) : '';
        const da = ok ? z2(d.getDate()) : '';
        let hh='00', mi='00';
        if (timeStr){
          const mm = timeStr.match(/(\d{1,2}):(\d{1,2})/);
          if (mm){ hh = z2(mm[1]); mi = z2(mm[2]); }
        }
        const ymd = (y && m && da) ? `${y}/${m}/${da}` : (dateStr||'');
        const hm = timeStr ? `${hh}:${mi}` : '';
        return [ymd, hm].filter(Boolean).join(' ');
      }
      return '';
    }

    document.getElementById('btnLoadSheet').onclick = async () => {
      try {
        console.log('[btnLoadSheet] Starting catch load with SHEET_ID:', SHEET_ID, 'SHEET_NAME:', SHEET_NAME);
        const id = SHEET_ID.trim(), sheet = SHEET_NAME.trim();
        sheetStatus.textContent = '読込中...';
        remoteCatchList.innerHTML=''; detailWrap.classList.add('hidden');
        if (!id || !sheet) throw new Error('シートID/シート名が空です');

        // 1) Trips を先に読み、tripId → 月情報マップを作る
        console.log('[btnLoadSheet] Loading Trips moon map...');
        tripsById = await loadTripsMoonMap();
        console.log('[btnLoadSheet] Trips moon map loaded, items:', Object.keys(tripsById).length);

        // 2) Catches を読み込む（SHEET_ID を明示的に渡す）
        console.log('[btnLoadSheet] Loading Catches sheet...');
        const rows = await loadSheetViaGAS(sheet, id);
        console.log('[btnLoadSheet] Catches loaded, rows:', rows?.length || 0);
        if (!rows || rows.length < 2){ sheetStatus.textContent='データが見つかりません（ヘッダ+1行以上が必要）'; hasLoadedOnce=true; return; }
        lastRows = rows; lastHeaders = rows[0];
        setupMapping(lastHeaders);
        renderRemoteList(applyCatchesFilter(mapRowsToItems(rows))); // tripId 経由で月情報を付与して描画
        sheetStatus.textContent = `読み込み完了：${rows.length-1}件`;
        hasLoadedOnce = true;
                // ★追記: Catches フィルタ UI（簡易）
        (function injectCatchesFilterUI(){
          if (!sheetStatus) return;
          const host = sheetStatus.parentElement; if (!host) return;
          if (document.getElementById('catchesFilterBar')) return;
          const bar = document.createElement('div');
          bar.id = 'catchesFilterBar';
          bar.className = 'mt-2 flex flex-wrap gap-2 text-sm';
          bar.innerHTML = `
            <input id="cfSpecies" placeholder="魚種を含む" class="px-2 py-1 rounded bg-slate-800 border border-slate-700" />
            <input id="cfMin" type="number" placeholder="サイズ最小" class="w-28 px-2 py-1 rounded bg-slate-800 border border-slate-700" />
            <input id="cfMax" type="number" placeholder="サイズ最大" class="w-28 px-2 py-1 rounded bg-slate-800 border border-slate-700" />
            <select id="cfSort" class="px-2 py-1 rounded bg-slate-800 border border-slate-700">
              <option value="time_desc">新しい順</option>
            </select>
            <button id="cfApply" class="px-2 py-1 rounded border border-slate-700 hover:bg-slate-800">適用</button>
          `;
          host.appendChild(bar);
          const apply = ()=>{
            uiFilter.catches.species = document.getElementById('cfSpecies').value.trim();
            uiFilter.catches.sizeMin = document.getElementById('cfMin').value ? Number(document.getElementById('cfMin').value) : null;
            uiFilter.catches.sizeMax = document.getElementById('cfMax').value ? Number(document.getElementById('cfMax').value) : null;
            uiFilter.catches.sort    = document.getElementById('cfSort').value;
            const items = mapRowsToItems(lastRows);
            renderRemoteList(applyCatchesFilter(items));
          };
          document.getElementById('cfApply').onclick = apply;
        })();

      }catch(e){
        console.error('[btnLoadSheet] Error:', e);
        console.error('[btnLoadSheet] Stack:', e.stack);
        sheetStatus.innerHTML = `読込に失敗しました。<span class="text-slate-400">(${e.message||e})</span><br><span class="text-slate-400">共有設定を「リンクを知っている全員（閲覧者）」にし、シート名を確認してください。</span>`;
        hasLoadedOnce = true;
      }
    };
    btnClearSheet && (btnClearSheet.onclick = ()=>{ remoteCatchList.innerHTML=''; detailWrap.classList.add('hidden'); sheetStatus.textContent=''; lastRows=null; lastHeaders=[]; hasLoadedOnce=false; tripsById={}; });
    btnCloseDetail.onclick = ()=> detailWrap.classList.add('hidden');

    function populateSelect(sel, headers){ sel.innerHTML=''; headers.forEach((h,i)=>{ const o=document.createElement('option'); o.value=String(i); o.textContent=h||`列${i+1}`; sel.appendChild(o); }); }

    function setupMapping(headers){
      const H = headers.map(h => String(h || '').trim());

      // 完全一致で列番号取得
      const idx = (name) => {
        const i = H.findIndex(h => h === name);
        return i >= 0 ? String(i) : null;
      };

      // ドロップダウンの中身は従来通り生成
      const selects=[mapPhoto,mapDate,mapTime,mapSpecies,mapSize,mapPlace,mapLat,mapLng,mapTideName,mapTideLevel,mapTideTrend,mapHighTide,mapLowTide,mapNotes];
      selects.forEach(s=>populateSelect(s, headers));

      // ① まずヒューリスティック（最下位の初期値）
      const g=guessMapping(headers);
      mapPhoto.value=g.photo; mapDate.value=g.date; mapTime.value=g.time;
      mapSpecies.value=g.species; mapSize.value=g.size; mapPlace.value=g.place;
      mapLat.value=g.lat; mapLng.value=g.lng; mapTideName.value=g.tideName; mapTideLevel.value=g.tideLevel;
      mapTideTrend.value=g.tideTrend; mapHighTide.value=g.highTide; mapLowTide.value=g.lowTide; mapNotes.value=g.notes;

      // ② 固定名（ヒューリスティックより優先）
      const iView = idx('photo_view_url');
      const iThumb= idx('photo_thumb_url');
      const iId   = idx('photo_file_id');
      if (iView)      mapPhoto.value = iView;
      else if (iThumb)mapPhoto.value = iThumb;
      else if (iId)   mapPhoto.value = iId;

      const iTs = idx('timestamp');
      if (iTs){ mapDate.value = iTs; mapTime.value = iTs; }

      const iSp = idx('species');         if (iSp) mapSpecies.value = iSp;
      const iSz = idx('size_cm');         if (iSz) mapSize.value    = iSz;
      const iTN = idx('tide_name');       if (iTN) mapTideName.value  = iTN;
      const iTL = idx('tide_level_cm');   if (iTL) mapTideLevel.value = iTL;
      const iTT = idx('tide_trend');      if (iTT) mapTideTrend.value = iTT;
      const iHH = idx('tide_high_times'); if (iHH) mapHighTide.value  = iHH;
      const iLL = idx('tide_low_times');  if (iLL) mapLowTide.value   = iLL;

      // ③ 保存済み（最優先）— 無条件で上書き適用（非同期）
      (async () => {
        await applySavedMapping();
      })();

      // 折りたたみを表示状態で出す（ユーザーが保存できるように）— mappingPanel が存在する場合のみ
      if (mappingPanel) {
        mappingPanel.classList.remove('hidden');
        mappingPanel.open = false; // 折りたたみ閉じ
      }

      // 変更時は即プレビュー更新（保存はボタン）
      selects.forEach(s=> s.onchange = ()=> lastRows && renderRemoteList(mapRowsToItems(lastRows)));

      // 初回プレビュー
      lastRows && renderRemoteList(mapRowsToItems(lastRows));
    }

    function guessMapping(headers){
      const L=headers.map(h=>String(h||'')); const lower=L.map(x=>x.toLowerCase());
      const findExact = name => { const i=L.findIndex(x=>x===name); return i>=0?String(i):null; };
      const findAny = keys => { for(let i=0;i<lower.length;i++){ if(keys.some(k=>lower[i].includes(k))) return String(i);} return null; };
      return {
        photo: findExact('写真URL')   ?? findAny(['photo','画像','img','url','link']) ?? '0',
        date:  findExact('日付')      ?? findAny(['date','日付']) ?? '0',
        time:  findExact('時刻')      ?? findAny(['time','時刻']) ?? '0',
        species: findExact('魚種')    ?? findAny(['species','魚種','fish']) ?? '0',
        size:  findExact('サイズ(cm)')?? findAny(['size','cm','サイズ']) ?? '0',
        place: findExact('地点名')    ?? findAny(['地点','場所','point','place','spot']) ?? '0',
        lat:   findExact('緯度')      ?? findAny(['lat','緯度']) ?? '0',
        lng:   findExact('経度')      ?? findAny(['lng','lon','経度']) ?? '0',
        tideName:  findExact('潮')    ?? findAny(['潮','tide']) ?? '0',
        tideLevel: findExact('潮位')  ?? findAny(['潮位','level']) ?? '0',
        tideTrend: findExact('潮位傾向') ?? findAny(['傾向','trend']) ?? '0',
        highTide:  findExact('満潮')  ?? findAny(['満潮','high']) ?? '0',
        lowTide:   findExact('干潮')  ?? findAny(['干潮','low']) ?? '0',
        notes: findExact('メモ')      ?? findAny(['memo','note','備考','コメント','メモ']) ?? '0',
      };
    }

    // 追加: Trips から月情報を読み込む
    async function loadTripsMoonMap(){
      try{
        // SHEET_ID が未設定の場合は待機
        if (!SHEET_ID) {
          console.log('[loadTripsMoonMap] Waiting for SHEET_ID...');
          await new Promise(resolve => {
            const check = () => {
              if (SHEET_ID) resolve();
              else setTimeout(check, 100);
            };
            setTimeout(check, 100);
          });
        }
        
        console.log('[loadTripsMoonMap] Loading with SHEET_ID:', SHEET_ID);
        const rows = await loadSheetViaGAS(TRIPS_SHEET_NAME, SHEET_ID);
        console.log('[loadTripsMoonMap] Loaded rows:', rows?.length || 0);
        if (!rows || rows.length < 2) return {};
        const headers = rows[0].map(h=>String(h||'').trim());
        const idxOf = name => headers.findIndex(h => h === name);

        const iTrip = idxOf('tripId');
        const iMb   = idxOf('moon_brightness');
        const iMa   = idxOf('moon_age');
        const iMv   = idxOf('moon_visual');

        // ★追加: 水温カラム（あれば使う）
        const iWtC  = idxOf('water_temp_c');
        const iWtP  = idxOf('water_temp_point');
        const iWtT  = idxOf('water_temp_time');

        // ★追加: raw_json からのフォールバック用
        const iRaw  = idxOf('raw_json');

        const map = {};
        for (let i=1;i<rows.length;i++){
          const r = rows[i];
          const id = r[iTrip] ?? '';
          if (!id) continue;

          // 既存（月情報）
          const rec = {
            moon_brightness: r[iMb] ?? '',
            moon_age:        r[iMa] ?? '',
            moon_visual:     r[iMv] ?? ''
          };

          // 追加（水温）— カラムがあれば優先
          if (iWtC>=0 || iWtP>=0 || iWtT>=0){
            rec.water_temp_c    = (iWtC>=0 ? r[iWtC] : '');
            const rawPoint = (iWtP>=0 ? r[iWtP] : '');
            rec.water_temp_point= (iWtP>=0 ? String(r[iWtP]) : '');
            rec.water_temp_time = (iWtT>=0 ? r[iWtT] : '');
            console.log('[loadTripsCache] water_temp parse:', { raw: rawPoint, processed: rec.water_temp_point, time: rec.water_temp_time });
          } else if (iRaw>=0 && r[iRaw]) {
            // フォールバック：raw_json.start_water_temp を見る
            try{
              const raw = JSON.parse(r[iRaw]);
              const wt = raw?.start_water_temp;
              if (wt){
                rec.water_temp_c     = (wt.temperature_c ?? '');
                rec.water_temp_point = (String(wt.point_name ?? ''));
                rec.water_temp_time  = (wt.date ?? '');
                console.log('[loadTripsCache] water_temp from raw_json:', { raw: wt.point_name, processed: rec.water_temp_point });
              }
            }catch{}
          }

          map[String(id)] = rec;
        }
        return map;
      }catch(e){
        console.warn('[Trips] 読み込みに失敗:', e?.message||e);
        return {};
      }
    }

    function mapRowsToItems(rows){
      // 固定列名 tripId を自動検出して紐付け（UIに追加しない）
      const headers = rows[0].map(h=>String(h||'').trim());
      const tripIdx = headers.findIndex(h => h === 'tripId');

      const get=(r,sel)=>{ const idx=Number(sel.value); return Number.isFinite(idx)&&r[idx]!==undefined ? r[idx] : ''; };
      const out=[];
      for(let i=1;i<rows.length;i++){
        const r=rows[i];
        const tripId = (tripIdx>=0) ? (r[tripIdx] ?? '') : '';
        const tripMoon = tripsById && tripId ? (tripsById[String(tripId)] || null) : null;

        out.push({
        tripId,
        // 既存マッピング
        photo:get(r,mapPhoto), date:get(r,mapDate), time:get(r,mapTime), species:get(r,mapSpecies), size:get(r,mapSize),
        place:get(r,mapPlace), lat:get(r,mapLat), lng:get(r,mapLng), tideName:get(r,mapTideName), tideLevel:get(r,mapTideLevel),
        tideTrend:get(r,mapTideTrend), tide_high_times:get(r,mapHighTide), tide_low_times:get(r,mapLowTide), notes:get(r,mapNotes),
        weight:'', method:'',
        // 追加: 月情報（Trips 由来）
        moon_visual: tripMoon?.moon_visual || '',
        moon_age: tripMoon?.moon_age || '',
        moon_brightness: tripMoon?.moon_brightness || '',
        // ★追加: 水温（Trips 由来）
        water_temp_c:     (tripMoon && 'water_temp_c'     in tripMoon) ? tripMoon.water_temp_c : '',
        water_temp_point: (tripMoon && 'water_temp_point' in tripMoon) ? String(tripMoon.water_temp_point || '') : '',
        water_temp_time:  (tripMoon && 'water_temp_time'  in tripMoon) ? tripMoon.water_temp_time  : ''
      });

      }
      return out;
    }

    const DRIVE_THUMB_SZ = 'w1200';
    function resolvePhotoUrl(raw){
      if (!raw) return '';
      let s = String(raw).trim();
      const urlInText = s.match(/https?:\/\/[^\s")]+/i);
      if (urlInText) s = urlInText[0];
      if (/^https?:\/\/(?:lh\d+\.googleusercontent\.com|drive\.google\.com\/thumbnail)/i.test(s)) return s;
      let id = null, resourceKey = null;
      const mFile = s.match(/https?:\/\/drive\.google\.com\/file\/d\/([^/]+)/i);
      if (mFile) id = mFile[1];
      const mId = s.match(/[?&]id=([^&]+)/i);
      if (!id && mId) id = mId[1];
      const mKey = s.match(/[?&]resourcekey=([^&]+)/i);
      if (mKey) resourceKey = mKey[1];
      if (!id && /^[A-Za-z0-9_-]{10,}$/.test(s) && s.indexOf('http') !== 0) id = s;
      if (id){
        let url = `https://drive.google.com/thumbnail?id=${id}&sz=${DRIVE_THUMB_SZ}`;
        if (resourceKey) url += `&resourcekey=${resourceKey}`;
        return url;
      }
      if (s.startsWith('http') || s.startsWith('data:')) return s;
      return '';
    }

    // バッジ（一覧と同じトーン）
    function pill(text, tone){
      const toneMap = {
        sky:     'border-sky-700/60 bg-sky-900/30',
        emerald: 'border-emerald-700/60 bg-emerald-900/30',
        violet:  'border-violet-700/60 bg-violet-900/30',
        slate:   'border-slate-700/60 bg-slate-800/40'
      };
      const cls = toneMap[tone] || toneMap.slate;
      return `<span class="px-2 py-0.5 rounded-full text-[11px] ${cls}">${text}</span>`;
    }

    // ラベル:値 の行
    function kv(label, value){
      if (!value && value !== 0) return '';
      return `<div class="flex justify-between gap-3 text-sm">
        <div class="text-slate-400">${label}</div>
        <div class="text-slate-200 text-right break-all">${value}</div>
      </div>`;
    }

    // 画像URL正規化（一覧で使っているものを流用）
    const resolvePhotoUrlDetail = resolvePhotoUrl;

    function renderRemoteList(items){
      // 一覧を折りたたみ(details)にし、展開中はhover無効・枠線は外枠のみ・閉じるボタン付き
      remoteCatchList.innerHTML = '';
      detailWrap.classList.add('hidden'); // 既存の独立詳細パネルは使わない

      items.forEach((it)=>{
        // ===== 外枠（折りたたみ） =====
        const wrap = document.createElement('details');
        wrap.className = 'rounded-2xl bg-slate-900 border border-slate-800 mb-2';

        // ===== サマリ（一覧部） =====
        const summary = document.createElement('summary');
        summary.className = 'list-none p-3 flex gap-3 items-start cursor-pointer rounded-2xl hover:bg-slate-800/60';

        // サムネ
        const img = document.createElement('img');
        img.className = 'w-24 h-24 object-cover rounded-xl bg-slate-950';
        img.alt = 'photo';
        img.src = resolvePhotoUrl(it.photo) || '';
        summary.appendChild(img);

        // テキスト群
        const info = document.createElement('div');
        info.className = 'flex-1 min-w-0';

        // 1行目：タイトル（魚種 / サイズ）
        const rowTitle = document.createElement('div');
        rowTitle.className = 'flex items-center justify-between gap-2';
        const title = document.createElement('div');
        title.className = 'font-semibold truncate text-lg';
        title.textContent = it.species || '(魚種不明)';
        rowTitle.appendChild(title);
        const sz = document.createElement('span');
        sz.className='text-sm text-slate-300';
        if (it.size !== '' && it.size != null) sz.textContent = String(it.size)+' cm';
        rowTitle.appendChild(sz);
        info.appendChild(rowTitle);

        // 2行目：日時 / 地点
        const rowMeta = document.createElement('div');
        rowMeta.className = 'mt-1 flex flex-wrap gap-x-4 gap-y-1 text-sm';
        const dtText = formatSheetDateTime(it.date, it.time);
        if (dtText) {
          const wrapMeta = document.createElement('span');
          const val = document.createElement('span');
          val.className = 'text-slate-200';
          val.textContent = dtText;
          wrapMeta.appendChild(val);
          rowMeta.appendChild(wrapMeta);
        }
        if (it.place) {
          const wrapMeta = document.createElement('span');
          const val = document.createElement('span');
          val.className = 'text-slate-200';
          val.textContent = it.place;
          wrapMeta.appendChild(val);
          rowMeta.appendChild(wrapMeta);
        }
        info.appendChild(rowMeta);

        // 3行目：潮バッジ
        const rowCond = document.createElement('div');
        rowCond.className = 'mt-1 flex flex-wrap items-center gap-2';
        if (it.tideName)  rowCond.insertAdjacentHTML('beforeend',  pill(it.tideName,  'sky'));
        if (it.tideTrend) rowCond.insertAdjacentHTML('beforeend',  pill(it.tideTrend, 'emerald'));
        if (it.tideLevel || it.tideLevel === 0) rowCond.insertAdjacentHTML('beforeend', pill(`${it.tideLevel} cm`, 'violet'));
        info.appendChild(rowCond);

        summary.appendChild(info);
        wrap.appendChild(summary);

        // ===== 展開部（閉じるボタン付き・内側は枠線ナシでシンプル） =====
        const detail = document.createElement('div');
        detail.className = 'px-3 pb-3';
        detail.innerHTML = `
          <div class="flex items-center justify-between mt-1 mb-2">
            <div class="text-xs text-slate-400">詳細</div>
            <button type="button" data-role="catch-detail-close"
              class="text-xs px-2 py-1 rounded-lg border border-slate-700 hover:bg-slate-800">
              閉じる
            </button>
          </div>

          <div class="grid sm:grid-cols-2 gap-4 mt-1">
            <div>
              <img
                src="${resolvePhotoUrlDetail(it.photo) || ''}"
                alt="photo"
                class="w-full h-auto max-h-[70vh] object-contain rounded-xl bg-slate-900"
              />
            </div>
            <div class="space-y-3">
              <div class="rounded-xl bg-slate-800/30 p-3 space-y-1">
                <div class="text-xs text-slate-400">基本情報</div>
                ${kv('魚種', it.species || '')}
                ${kv('サイズ', (it.size || it.size===0) ? `${it.size} cm` : '')}
                ${kv('重量', (it.weight || it.weight===0) ? `${it.weight} g` : '')}
                ${kv('方法', it.method || '')}
              </div>

              ${(it.place || it.lat || it.lng) ? `
                <div class="rounded-xl bg-slate-800/30 p-3 space-y-1">
                  <div class="text-xs text-slate-400">位置</div>
                  ${kv('地点', it.place || '')}
                  ${kv('緯度', it.lat || '')}
                  ${kv('経度', it.lng || '')}
                </div>` : ''}

              ${(it.tideName || it.tideTrend || (it.tideLevel || it.tideLevel===0) || it.tide_high_times || it.tide_low_times) ? `
                <div class="rounded-xl bg-slate-800/30 p-3 space-y-1">
                  <div class="text-xs text-slate-400">潮</div>
                  <div class="flex flex-wrap items-center gap-2 mb-1">
                    ${it.tideName  ? pill(it.tideName, 'sky') : ''}
                    ${it.tideTrend ? pill(it.tideTrend, 'emerald') : ''}
                    ${(it.tideLevel || it.tideLevel===0) ? pill(`${it.tideLevel} cm`, 'violet') : ''}
                  </div>
                  ${kv('満潮', it.tide_high_times || '')}
                  ${kv('干潮', it.tide_low_times  || '')}
                </div>` : ''}

              <!-- ★追加: 水温（Trips由来を it.* に展開済み） -->
              ${(it.water_temp_c!=='' || it.water_temp_point || it.water_temp_time) ? `
                <div class="rounded-xl bg-slate-800/30 p-3 space-y-1">
                  <div class="text-xs text-slate-400">水温</div>
                  ${kv('水温', (it.water_temp_c!=='' ? `${it.water_temp_c} ℃` : ''))}
                  ${kv('地点', it.water_temp_point || '')}
                </div>` : ''}

              ${it.notes ? `
                <div class="rounded-xl bg-slate-800/30 p-3">
                  <div class="text-xs text-slate-400 mb-1">メモ</div>
                  <div class="text-sm text-slate-200 whitespace-pre-line">${it.notes}</div>
                </div>` : ''}

            </div>
          </div>
        `;
        wrap.appendChild(detail);

        // 「閉じる」ボタンでこの details を閉じる
        detail.querySelector('[data-role="catch-detail-close"]').onclick = (e)=>{
          e.stopPropagation();
          wrap.open = false;
        };

        // 開閉で hover を制御（開いている間は hover 無効）
        wrap.addEventListener('toggle', () => {
          if (wrap.open) summary.classList.remove('hover:bg-slate-800/60');
          else summary.classList.add('hover:bg-slate-800/60');
        });

        remoteCatchList.appendChild(wrap);
      });
    }

    function showDetail(it){
      const wrap = document.getElementById('remoteCatchDetail');
      const body = document.getElementById('detailBody');

      const title = `
        <div class="flex items-start justify-between gap-3">
          <div class="font-semibold text-2xl tracking-tight">${it.species || '(魚種不明)'}</div>
          <div class="text-slate-200">${(it.size || it.size===0) ? `${it.size} cm` : ''}</div>
        </div>
      `;

      const timeText = formatSheetDateTime(it.date, it.time);
      const meta = `
        <div class="text-sm text-slate-300 flex flex-wrap gap-x-4 gap-y-1">
          ${timeText ? `<span>${timeText}</span>` : ''}
          ${it.place   ? `<span>${it.place}</span>` : ''}
        </div>
      `;

      const cond = `
        <div class="mt-1 flex flex-wrap items-center gap-2">
          ${it.tideName  ? pill(it.tideName, 'sky') : ''}
          ${it.tideTrend ? pill(it.tideTrend, 'emerald') : ''}
          ${(it.tideLevel || it.tideLevel===0) ? pill(`${it.tideLevel} cm`, 'violet') : ''}
        </div>
      `;

      const img = `
        <img
          src="${resolvePhotoUrlDetail(it.photo) || ''}"
          alt="photo"
          class="w-full h-auto max-h-[70vh] object-contain rounded-xl border border-slate-800 bg-slate-900"
        />
      `;

      const basicCard = `
        <div class="rounded-2xl bg-slate-900 border border-slate-800 p-3 space-y-2">
          <div class="text-xs text-slate-400">基本情報</div>
          ${kv('魚種', it.species || '')}
          ${kv('サイズ', (it.size || it.size===0) ? `${it.size} cm` : '')}
          ${kv('重量', (it.weight || it.weight===0) ? `${it.weight} g` : '')}
          ${kv('方法', it.method || '')}
        </div>
      `;

      const posCard = (it.place || it.lat || it.lng) ? `
        <div class="rounded-2xl bg-slate-900 border border-slate-800 p-3 space-y-2">
          <div class="text-xs text-slate-400">位置</div>
          ${kv('地点', it.place || '')}
          ${kv('緯度', it.lat || '')}
          ${kv('経度', it.lng || '')}
        </div>
      ` : '';

      const tideCard = (it.tideName || it.tideTrend || (it.tideLevel || it.tideLevel===0) || it.tide_high_times || it.tide_low_times) ? `
        <div class="rounded-2xl bg-slate-900 border border-slate-800 p-3 space-y-2">
          <div class="text-xs text-slate-400">潮</div>
          <div class="flex flex-wrap items-center gap-2">
            ${it.tideName  ? pill(it.tideName, 'sky') : ''}
            ${it.tideTrend ? pill(it.tideTrend, 'emerald') : ''}
            ${(it.tideLevel || it.tideLevel===0) ? pill(`${it.tideLevel} cm`, 'violet') : ''}
          </div>
          ${kv('満潮', slashAligned(it.tide_high_times))}
          ${kv('干潮', slashAligned(it.tide_low_times))}
        </div>
      ` : '';

      // 追加: 月情報カード（Trips から）
      const moonCard = (it.moon_visual || it.moon_age || it.moon_brightness) ? `
        <div class="rounded-2xl bg-slate-900 border border-slate-800 p-3 space-y-2">
          <div class="text-xs text-slate-400">月</div>
          ${kv('見え方', it.moon_visual || '')}
          ${kv('月齢', it.moon_age || '')}
        </div>
      ` : '';

      const notesCard = it.notes ? `
        <div class="rounded-2xl bg-slate-900 border border-slate-800 p-3">
          <div class="text-xs text-slate-400 mb-1">メモ</div>
          <div class="text-sm text-slate-200 whitespace-pre-line">${it.notes}</div>
        </div>` : '';

      body.innerHTML = `
        ${title}
        ${meta}
        ${cond}
        <div class="grid sm:grid-cols-2 gap-4 mt-2">
          <div>${img}</div>
          <div class="space-y-3">          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt
            ${basicCard}
            ${posCard}
            ${tideCard}
            ${moonCard}
          </div>
        </div>
        ${notesCard}
      `;

      wrap.classList.remove('hidden');
      wrap.scrollIntoView({behavior:'smooth', block:'start'});
    }

    // 「HH:MM／HH:MM」をスラッシュで揃えて表示
    function slashAligned(val){
      if (!val) return '';
      const [aRaw='', bRaw=''] = String(val).split('／');
      const a = (aRaw || '').trim() || '－';
      const b = (bRaw || '').trim() || '－';
      // 左右を別カラム、中央にスラッシュ。等幅数字で桁揃え
      return `
        <span class="inline-grid grid-cols-[1fr_auto_1fr] items-baseline gap-1 tabular-nums">
          <span class="text-right">${a}</span>
          <span>／</span>
          <span class="text-left">${b}</span>
        </span>
      `;
    }


    // ===== PWA: Service Worker 登録 =====
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js')
          .then(registration => {
            console.log('[PWA] Service Worker registered:', registration);
          })
          .catch(err => {
            console.warn('[PWA] Service Worker registration failed:', err);
          });
      });
    }

    // ===== PWA: IndexedDB 初期化 =====
    const DB_NAME = 'FishLogDB';
    const STORE_NAME = 'draftTrips';
    let db = null;

    function initIndexedDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, 1);

        request.onerror = () => {
          console.warn('[IndexedDB] Open failed');
          reject(request.error);
        };

        request.onsuccess = () => {
          db = request.result;
          console.log('[IndexedDB] Initialized');
          resolve(db);
        };

        request.onupgradeneeded = (event) => {
          db = event.target.result;
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME, { keyPath: 'tripId' });
            console.log('[IndexedDB] Object store created');
          }
        };
      });
    }

    async function saveDraftToIndexedDB(draft) {
      if (!db) return;
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        const request = store.put(draft);

        request.onsuccess = () => {
          console.log('[IndexedDB] Draft saved:', draft.tripId);
          resolve();
        };

        request.onerror = () => {
          console.warn('[IndexedDB] Save failed:', request.error);
          reject(request.error);
        };
      });
    }

    async function loadDraftFromIndexedDB(tripId) {
      if (!db) return null;
      return new Promise((resolve) => {
        const tx = db.transaction(STORE_NAME, 'readonly');
        const store = tx.objectStore(STORE_NAME);
        const request = store.get(tripId);

        request.onsuccess = () => {
          if (request.result) {
            console.log('[IndexedDB] Draft loaded:', tripId, request.result);
            console.log('[IndexedDB] start_water_temp:', request.result?.start_water_temp);
            resolve(request.result);
          } else {
            console.log('[IndexedDB] Draft not found:', tripId);
            resolve(null);
          }
        };

        request.onerror = () => {
          console.warn('[IndexedDB] Load failed:', request.error);
          resolve(null);
        };
      });
    }

    // ===== 釣行ドラフト =====
    const LS_KEY='fishtrip_draft_v1';
    const uuid = ()=> (crypto?.randomUUID ? crypto.randomUUID() : (Date.now().toString(36)+Math.random().toString(36).slice(2,10)));
    const loadDraft = () => {
  try {
    const raw = localStorage.getItem(LS_KEY);
    if (!raw) {
      return { tripId: uuid(), status: 'idle', catches: [], tide_daily_cache: {}, manualStarted: false, updatedAt: new Date().toISOString() };
    }
    const p = JSON.parse(raw);
    return {
      tripId: p.tripId || uuid(),
      status: p.status || 'idle',
      catches: p.catches || [],
      startedAt: p.startedAt,
      endedAt: p.endedAt,
      lat: p.lat,
      lng: p.lng,
      start_weather: p.start_weather,
      end_weather: p.end_weather,
      start_tide: p.start_tide,
      tide_daily_cache: p.tide_daily_cache || {},
      start_water_temp: p.start_water_temp || null,
      manualStarted: !!p.manualStarted,
      updatedAt: p.updatedAt || new Date().toISOString()
    };
  } catch {
    return { tripId: uuid(), status: 'idle', catches: [], tide_daily_cache: {}, manualStarted: false, updatedAt: new Date().toISOString() };
  }
};
    const saveDraft = async (d) => {
      d.updatedAt = new Date().toISOString();
      try {
        localStorage.setItem(LS_KEY, JSON.stringify(d));
      } catch (e) {
        console.warn('[Draft] localStorage save failed (PWA mode?):', e.message);
      }
      try {
        await saveDraftToIndexedDB(d);
      } catch (err) {
        console.warn('[Draft] IndexedDB save failed:', err);
      }
    };
    const fmtLocal = iso => { try{return new Date(iso).toLocaleString();}catch{return '—'}; };

    let draft = loadDraft();
    
    // ★追加：アップロード状態管理
    let isUploading = false;
    let uploadingMessage = '処理中...';  // ★追加：処理内容を表示するメッセージ
    
    // IndexedDB 初期化と非同期ロード
    (async () => {
      try {
        await initIndexedDB();
        const idbDraft = await loadDraftFromIndexedDB(draft.tripId);
        if (idbDraft && new Date(idbDraft.updatedAt) > new Date(draft.updatedAt || 0)) {
          console.log('[Init] Using newer IndexedDB version');
          draft = idbDraft;
        }
        if (typeof render === 'function') render();
      } catch (err) {
        console.warn('[Init] Failed to load from IndexedDB:', err);
        if (typeof render === 'function') render();
      }
    })();

    let catchForm = { id: uuid(), timestamp: nowIsoLocal(), species:'', size_cm:null, weight_g:null, method:'', photoPreviewUrl:undefined };
    let editMode=false, editingId=null;
    let manualCatchMode = false;

    // 終了確認モーダル用
    let pendingEnd = null; // { endedAt: string(JST ISO), end_weather: object|null }

    // DOM参照（記録ビュー）
    const txtStatus=document.getElementById('txtStatus');
    const txtTripId=document.getElementById('txtTripId');
    const txtPosWrap=document.getElementById('txtPos');
    const txtLat=document.getElementById('txtLat');
    const txtLng=document.getElementById('txtLng');
    const txtStartedAt=document.getElementById('txtStartedAt');
    const txtCatchCount=document.getElementById('txtCatchCount');
    const tripWeatherRow=document.getElementById('tripWeatherRow');
    const buttonRow=document.getElementById('buttonRow');
    const bottomBar=document.getElementById('bottomBar');
    const btnAddCatchBottom=document.getElementById('btnAddCatchBottom');
    const btnEndBottom=document.getElementById('btnEndBottom');

    const catchListEmpty=document.getElementById('catchListEmpty');
    const hintAddWhenActive=document.getElementById('hintAddWhenActive');
    const catchList=document.getElementById('catchList');

    const catchModal=document.getElementById('catchModal');
    const btnCloseModal=document.getElementById('btnCloseModal');
    const btnCancelCatch=document.getElementById('btnCancelCatch');
    const btnSaveCatch=document.getElementById('btnSaveCatch');
    const inpCatchTime=document.getElementById('inpCatchTime');
    const inpSpecies=document.getElementById('inpSpecies');
    const inpSize=document.getElementById('inpSize');
    const inpWeight=document.getElementById('inpWeight');
    const inpMethod=document.getElementById('inpMethod');
    const inpPhoto=document.getElementById('inpPhoto');
    const imgPreview=document.getElementById('imgPreview');
    const modalTitle=document.getElementById('modalTitle');

    // 画像アップロード（CONFIG から毎回読み込み）

    // ★修正：SHEET_ID を優先で取得してから他の処理を実行
    (async () => {
      try {
        console.log('[Init] Starting SHEET_ID initialization...');
        await initializeSheetId();
        console.log('[Init] SHEET_ID initialization complete. SHEET_ID:', SHEET_ID);
      } catch (err) {
        console.error('[Init] SHEET_ID initialization failed:', err);
      }
    })();

    // ===== Settings UI 機能 =====
    // 初期化：GAS から読み込むため、初期値は空にしておく

    // Sheet ID 保存関数（統合）
    async function saveSheetConfigToGAS() {
      try {
        const newId = (sheetIdEl?.value || '').trim();
        if (!newId) {
          if (sheetConfigStatus) sheetConfigStatus.textContent = 'ID を入力してください';
          return;
        }
        
        // ★修正：Worker 経由で GAS に送信（secrets 保護）
        const workerUrl = CONFIG.API.FISHING_TRIP_API_WORKER + '/api/setSpreadsheetId';
        const res = await fetch(workerUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Auth-Token': CONFIG.API.WORKERS_AUTH_TOKEN
          },
          body: JSON.stringify({ spreadsheetId: newId })
        });
        const json = await res.json();
        
        if (json.ok) {
          if (sheetConfigStatus) {
            sheetConfigStatus.textContent = '✓ 保存しました';
            setTimeout(() => { if (sheetConfigStatus) sheetConfigStatus.textContent = ''; }, 2000);
          }
          // 送信後、入力値をクリア（フロント側には保持しない）
          if (sheetIdEl) sheetIdEl.value = '';
          console.log('[Settings] Sheet ID saved to GAS');
        } else {
          if (sheetConfigStatus) sheetConfigStatus.textContent = 'エラー: ' + (json.message || '不明');
        }
      } catch (err) {
        console.error('[Settings] saveSheetConfigToGAS error:', err);
        if (sheetConfigStatus) sheetConfigStatus.textContent = 'エラーが発生しました';
      }
    }

    // ボタンのオンクリック設定
    if (btnSaveSheetConfig) btnSaveSheetConfig.onclick = saveSheetConfigToGAS;

    // ★修正：秘密情報（トークン・キー）の保存関数（ハイブリッドストレージ経由）
    async function saveAuthToken() {
      const token = (document.getElementById('workersAuthTokenEl')?.value || '').trim();
      const status = document.getElementById('secretsStatus');
      
      if (!token) {
        if (status) status.textContent = 'トークンを入力してください';
        return;
      }
      
      try {
        await configStorage.setItem('WORKERS_AUTH_TOKEN', token);
        CONFIG.API.WORKERS_AUTH_TOKEN = token;
        
        if (status) {
          status.textContent = '✓ 保存しました';
          setTimeout(() => { if (status) status.textContent = ''; }, 2000);
        }
        
        document.getElementById('workersAuthTokenEl').value = '';
        console.log('[Settings] Worker Auth Token saved via hybrid storage');
      } catch (err) {
        console.error('[Settings] Failed to save auth token:', err);
        if (status) status.textContent = 'エラーが発生しました';
      }
    }

    // ★修正：秘密情報の一括保存ボタンハンドラ
    async function saveSecretsHandler() {
      const authToken = (document.getElementById('workersAuthTokenEl')?.value || '').trim();
      const status = document.getElementById('secretsStatus');
      
      if (!authToken) {
        if (status) status.textContent = 'トークンを入力してください';
        return;
      }
      
      await saveAuthToken();
    }

    if (document.getElementById('btnSaveSecrets')) {
      document.getElementById('btnSaveSecrets').onclick = saveSecretsHandler;
    }

    function fileToDataURL(file){
      return new Promise((res, rej)=>{
        const r = new FileReader();
        r.onload = () => res(r.result);
        r.onerror = rej;
        r.readAsDataURL(file);
      });
    }

// ★追加：ホームのボタンから“釣行中でなくても”釣果追加モーダルを開く
    function openManualCatch(){
      manualCatchMode = true;

      // 釣行中でない場合は「釣行中」にするが、開始時刻は空のまま（Startは未入力表示にする）
      if (draft.status === 'idle') {
        draft.status = 'active';          // 画面は「釣行中」表示に
        draft.startedAt = null;           // ← Start時間は空で保持
        draft.endedAt   = null;
        draft.catches   = draft.catches || [];
        draft.manualStarted = true;       // 手動開始フラグはここで明示
        saveDraft(draft);
      }

      // 既存の“追加モーダル”をそのまま利用
      editMode=false; editingId=null; 
      catchForm={ id:uuid(), timestamp:nowIsoLocal(), species:'', size_cm:null, weight_g:null, method:'', photoPreviewUrl:undefined };
      try{ inpCatchTime.value = toLocalInputValue(new Date(catchForm.timestamp)); }catch{ inpCatchTime.value=''; }
      inpSpecies.value=''; inpSize.value=''; inpWeight.value=''; inpMethod.value=''; inpPhoto.value='';
      imgPreview.src=''; imgPreview.classList.add('hidden');
      catchModal.classList.remove('hidden');
    }

    // ★追加: Cloudinary経由でEXIF(GPS)をフロント側で取得する関数
    async function fetchExifFromCloudinary(file) {
      const CLOUDINARY_UPLOAD_URL = `https://api.cloudinary.com/v1_1/${CONFIG.API.CLOUDINARY_CLOUD_NAME}/image/upload`;
      const CLOUDINARY_UPLOAD_PRESET = CONFIG.API.CLOUDINARY_UPLOAD_PRESET;

      // 1. Cloudinaryへアップロード
      const formData = new FormData();
      formData.append("file", file);
      formData.append("upload_preset", CLOUDINARY_UPLOAD_PRESET);
      formData.append("public_id", "exif_" + Date.now());

      const uploadRes = await fetch(CLOUDINARY_UPLOAD_URL, { method: "POST", body: formData });
      const uploadJson = await uploadRes.json();
      if (!uploadJson.secure_url) throw new Error("Cloudinary upload failed");

      const imageUrl = uploadJson.secure_url;

      // ★修正：Worker 経由で EXIF を取得（RapidAPI キーは Worker が管理）
      const exifRes = await fetch(CONFIG.API.FISHING_TRIP_API_WORKER + '/api/exif', {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-Auth-Token": CONFIG.API.WORKERS_AUTH_TOKEN
        },
        body: JSON.stringify({ imageUrl: imageUrl })
      });
      const exifJson = await exifRes.json();

      // Worker からの応答を処理
      if (!exifJson.Composite) return null;
      
      const latStr = exifJson?.Composite?.GPSLatitude;
      const lonStr = exifJson?.Composite?.GPSLongitude;
      const dateTime = exifJson?.EXIF?.DateTimeOriginal || "不明";

      console.log("📸 撮影日時:", dateTime);
      console.log("📍 緯度:", latStr, "経度:", lonStr);

      if (!latStr || !lonStr) return null;

      // 3. 度単位へ変換（DMS → decimal）
      function dmsToDecimal(dms) {
        const parts = dms.split(/[^\d\w.]+/).filter(Boolean).map(Number);
        if (parts.length < 3) return NaN;
        return parts[0] + parts[1]/60 + parts[2]/3600;
      }

      const lat = dmsToDecimal(latStr);
      const lng = dmsToDecimal(lonStr);

      return { lat, lng, dateTime, imageUrl };
    }
       
    async function uploadPhotoToDrive(file){
      // ★進捗（存在すれば使用）
      const setProgress = (msg)=>{ try{ const el=document.getElementById('uploadProgress'); if(el){ el.textContent = msg; } }catch{} };

      setProgress('画像を最適化中...');
      const { dataUrl, mime } = await compressImageFile(file, { maxSize:1600, quality:0.85 });

      const payload = {
        action: "uploadPhoto",
        fileName: file.name || (`photo_${Date.now()}.jpg`),
        mimeType: mime || file.type || "image/jpeg",
        dataUrl
      };

      setProgress('アップロード中...');
      // ★修正：Worker 経由で GAS にアップロード（secrets 保護）
      const workerUrl = CONFIG.API.FISHING_TRIP_API_WORKER + '/api/upload';
      const res = await fetch(workerUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-Auth-Token": CONFIG.API.WORKERS_AUTH_TOKEN
        },
        body: JSON.stringify(payload)
      });
      let j={}; try{ j = await res.json(); }catch{}
      setProgress('');
      if (!res.ok || !j?.ok) throw new Error(j?.error || `HTTP ${res.status}`);
      return j; // { ok:true, fileId, viewUrl, thumbUrl }
    }

    // ★追加：Google Drive からファイルを削除する関数（GAS経由）
    // ★修正：画像削除は GAS 呼び出しをスキップ（ローカルのみで削除をマーク）
    // ★修正：画像削除は GAS の定期実行に委ねる
    // 方針：catch シートに存在しない photoFileId を持つ画像は、GAS の定期実行で自動削除される
    // メリット：
    //   - UI のハング問題が完全に解決
    //   - 編集キャンセル時に画像が削除されない（必要な画像が守られる）
    //   - orphan 画像は定期的に自動クリーンアップ
    function deletePhotoFromDrive(fileId) {
      if (!fileId) {
        console.warn('[DeletePhoto] No fileId provided');
        return;
      }

      console.log('[DeletePhoto] Photo marked for orphan cleanup (will be deleted by GAS scheduled trigger):', fileId);
      // ★重要：フロント側では何もしない
      // GAS の cleanupOrphanPhotos() がシート上に存在しない fileId を定期的に削除
    }

    // ★追加：潮汐チャート画像取得・アップロード関数（GASプロキシ経由）
    async function fetchAndUploadTideImages(startedAt, endedAt) {
        console.log('[TideImageUpload] Starting tide image fetch', { startedAt, endedAt });
        
        if (!startedAt || !endedAt) {
          console.warn('[TideImageUpload] Missing startedAt or endedAt');
          return { ok: false, images: [] };
        }

        // ★ローカルファイル（file://）では画像取得をスキップ
        if (window.location.protocol === 'file:') {
          console.warn('[TideImageUpload] Running on file:// protocol - image fetch skipped (use local HTTP server)');
          return { ok: true, images: [], skipped: true, reason: 'file protocol' };
        }      try {
        const startDate = new Date(startedAt);
        const endDate = new Date(endedAt);
        
        // 釣行開始の30分前から終了の20分後までの時間範囲を計算
        const rangeStart = new Date(startDate.getTime() - 30 * 60000); // 30分前
        const rangeEnd = new Date(endDate.getTime() + 20 * 60000);     // 20分後
        
        console.log('[TideImageUpload] Time range:', {
          rangeStart: rangeStart.toISOString(),
          rangeEnd: rangeEnd.toISOString()
        });

        // ファイル名は10分単位なので、10分ごとのファイルを取得
        const filenames = [];
        
        let current = new Date(rangeStart);
        current.setMinutes(Math.floor(current.getMinutes() / 10) * 10, 0, 0); // 10分単位に切り下げ

        while (current <= rangeEnd) {
          const yyyy = current.getFullYear();
          const mm = String(current.getMonth() + 1).padStart(2, '0');
          const dd = String(current.getDate()).padStart(2, '0');
          const hh = String(current.getHours()).padStart(2, '0');
          const mi = String(current.getMinutes()).padStart(2, '0');
          const filename = `${yyyy}${mm}${dd}${hh}${mi}.png`;
          
          filenames.push(filename);
          console.log('[TideImageUpload] Added filename:', filename);
          
          // 次の10分へ
          current = new Date(current.getTime() + 10 * 60000);
        }

        console.log('[TideImageUpload] Total images to fetch:', filenames.length);

        // GASプロキシ経由で画像をフェッチしてアップロード
        const uploadedImages = [];
        for (const filename of filenames) {
          try {
            console.log('[TideImageUpload] Fetching via proxy:', filename);
            
            // ★修正：Worker 経由で GAS にリクエスト（secrets 保護）
            const proxyPayload = {
              action: 'fetchTideImageViaProxy',
              filename: filename
            };

            const workerUrl = CONFIG.API.FISHING_TRIP_API_WORKER + '/api/upload';
            const proxyRes = await fetch(workerUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-Auth-Token': CONFIG.API.WORKERS_AUTH_TOKEN
              },
              body: JSON.stringify(proxyPayload)
            });

            const proxyJson = await proxyRes.json();
            
            if (proxyJson?.ok && proxyJson?.fileId) {
              console.log('[TideImageUpload] Upload successful:', filename, {
                fileId: proxyJson.fileId,
                viewUrl: proxyJson.viewUrl
              });
              uploadedImages.push({
                filename: filename,
                fileId: proxyJson.fileId,
                viewUrl: proxyJson.viewUrl,
                timestamp: filename.replace(/[^\d]/g, '').slice(0, 12) // yyyymmddhhmm
              });
            } else {
              console.warn('[TideImageUpload] Proxy fetch failed:', filename, proxyJson?.error);
            }
          } catch (err) {
            console.warn('[TideImageUpload] Error processing image:', filename, err);
          }
        }

        console.log('[TideImageUpload] Completed. Uploaded', uploadedImages.length, 'images');
        return { ok: true, images: uploadedImages };
      } catch (err) {
        console.error('[TideImageUpload] Fatal error:', err);
        return { ok: false, error: err.message, images: [] };
      }
    }

    // ★追記: 画像圧縮ヘルパー（最大長辺 1600px / JPEG 品質 0.85）
    async function compressImageFile(file, {maxSize=1600, quality=0.85} = {}){
      const imgDataUrl = await fileToDataURL(file);
      const img = new Image();
      img.src = imgDataUrl;
      await img.decode();

      const w = img.naturalWidth, h = img.naturalHeight;
      const scale = Math.min(1, maxSize / Math.max(w, h));
      if (scale === 1 && (file.type && file.type !== 'image/heic')) {
        // そのまま返す（非HEICでサイズ問題なし）
        return { dataUrl: imgDataUrl, mime: (file.type || 'image/jpeg') };
      }

      const canvas = document.createElement('canvas');
      canvas.width = Math.round(w * scale);
      canvas.height = Math.round(h * scale);
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

      const mime = 'image/jpeg'; // Google Drive サムネ互換優先
      const dataUrl = canvas.toDataURL(mime, quality);
      return { dataUrl, mime };
    }

        // ★追記: フィルタ&ソート状態
    const uiFilter = {
      catches: { species:'', sizeMin:null, sizeMax:null, tideName:'', sort:'time_desc' },
      trips:   { tideName:'', dateFrom:'', dateTo:'', sort:'start_desc' }
    };
    function applyCatchesFilter(items){
      let out = items.slice();
      const f = uiFilter.catches;
      if (f.species) out = out.filter(x => String(x.species||'').includes(f.species));
      if (f.tideName) out = out.filter(x => String(x.tideName||'') === f.tideName);
      if (f.sizeMin!=null) out = out.filter(x => (x.size!=null && +x.size >= +f.sizeMin));
      if (f.sizeMax!=null) out = out.filter(x => (x.size!=null && +x.size <= +f.sizeMax));
      if (f.sort === 'time_desc') out.sort((a,b)=> (new Date(b.time||b.date||0)) - (new Date(a.time||a.date||0)));
      return out;
    }
    function applyTripsFilter(rows){
      const headers = rows[0].map(h=>String(h||'').trim());
      const col = {
        tideName: headers.indexOf('tideName'),
        startedAt: headers.indexOf('startedAt')
      };
      const f = uiFilter.trips;
      const body = rows.slice(1).filter(r=>{
        if (f.tideName && String(r[col.tideName]||'') !== f.tideName) return false;
        if (f.dateFrom && new Date(r[col.startedAt]||0) < new Date(f.dateFrom)) return false;
        if (f.dateTo   && new Date(r[col.startedAt]||0) > new Date(f.dateTo))   return false;
        return true;
      });
      if (f.sort === 'start_desc') body.sort((a,b)=> new Date(b[col.startedAt]||0) - new Date(a[col.startedAt]||0));
      return [headers, ...body];
    }

    // ===== 潮汐：Worker プロキシ =====
    const TIDE_PROXY_URL_FOR_TIDE = TIDE_PROXY_URL; // 可読用エイリアス（動作は同一）

    // 港コード一覧（GViz）読み込みキャッシュ
    let harborCache = null;

    async function loadHarborsFromSheet(){
      if (harborCache) return harborCache;
      
      // ★追加：SHEET_ID が取得されるまで待機
      if (!SHEET_ID) {
        console.log('[loadHarborsFromSheet] Waiting for SHEET_ID...');
        await new Promise(resolve => {
          const check = () => {
            if (SHEET_ID) resolve();
            else setTimeout(check, 100);
          };
          setTimeout(check, 100);
        });
      }
      
      const rows = await loadSheetViaGAS(HARBOR_SHEET_NAME, SHEET_ID);
      if (!rows || rows.length < 2) throw new Error("港コード一覧のデータが見つかりません");
      const headers = rows[0].map(h=>String(h||'').trim());
      const findCol = (cands) => {
        const idx = headers.findIndex(h => cands.some(c => h.toLowerCase().includes(c)));
        return idx >= 0 ? idx : null;
      };
      const idxPC = findCol(['pc','pref','都道府県コード','県コード']) ?? 0;
      const idxHC = findCol(['hc','harbor','港コード','港id']) ?? 1;
      const idxPN = findCol(['pn','pref','都道府県名']) ?? 2;
      const idxHN = findCol(['hn','港名','harbor']) ?? 3;
      const idxLAT= findCol(['lat','緯度']) ?? 4;
      const idxLON= findCol(['lon','lng','経度']) ?? 5;

      const mapped = [];
      for (let i=1; i<rows.length; i++){
        const r = rows[i];
        const pc = r[idxPC]; const hc = r[idxHC];
        const pn = r[idxPN]; const hn = r[idxHN];
        const lat= parseFloat(r[idxLAT]); const lon=parseFloat(r[idxLON]);
        if (!isFinite(lat) || !isFinite(lon)) continue;
        mapped.push({ pc, hc, pn, hn, lat, lon });
      }
      harborCache = { headers, rows, mapped };
      LOG.tide("harbors loaded:", mapped.length);
      return harborCache;
    }

    function haversineDistance(lat1, lon1, lat2, lon2) {
      const R = 6371;
      const toRad = deg => (deg * Math.PI) / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a =
        Math.sin(dLat / 2) ** 2 +
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
      return R * 2 * Math.asin(Math.sqrt(a));
    }

    async function findNearestHarbor(lat, lon, radiusKm = 10){
      const hc = await loadHarborsFromSheet();

      // まずは要求の半径（既定10km）で探索
      const scan = (rkm) => hc.mapped
        .map(h => ({ ...h, dist: haversineDistance(lat, lon, h.lat, h.lon) }))
        .filter(h => h.dist <= rkm)
        .sort((a,b)=> a.dist - b.dist);

      let candidates = scan(radiusKm);
      if (candidates.length > 0) return candidates[0];

      // ★追加: 見つからなければ 30km に拡張して再試行
      if (radiusKm < 30){
        candidates = scan(30);
        if (candidates.length > 0) return candidates[0];
      }
      return null;
    }

    function toSeconds_HHMM(timeStr) {
      if (timeStr === "24:00") timeStr = "23:59";
      const [h, m] = timeStr.split(":").map(Number);
      return h * 3600 + m * 60;
    }

    function analyzeTideTrendForTime(chart, localDate){
      try{
        const tideList = chart?.tide;
        if (!tideList || tideList.length < 2) return "不明";
        const heights = tideList.map(t => t.cm);
        const min = Math.min(...heights);
        const max = Math.max(...heights);
        const range = max - min;
        if (!isFinite(range) || range <= 0) return "不明";

        const hh = localDate.getHours();
        const mm = localDate.getMinutes();
        const shotSec = hh*3600 + mm*60;

        let closest = tideList[0];
        let closestDiff = Math.abs(toSeconds_HHMM(closest.time) - shotSec);
        for (let i=1; i<tideList.length; i++){
          const sec = toSeconds_HHMM(tideList[i].time);
          const diff = Math.abs(sec - shotSec);
          if (diff < closestDiff){ closest = tideList[i]; closestDiff = diff; }
        }
        const idx = tideList.indexOf(closest);
        const prev = tideList[idx-1];
        const next = tideList[idx+1];
        if (!prev || !next) return "不明";

        const trend = next.cm > prev.cm ? "上げ潮" : "下げ潮";
        const level = Math.round(((closest.cm - min) / range) * 10);
        return `${trend}（${level}分）`;
      }catch{ return "不明"; }
    }

    // === その日の満潮/干潮の時刻を抽出（最大2つずつ） ===
    function summarizeHighLowTimesFromChart(chart){
      const list = Array.isArray(chart?.tide) ? chart.tide : [];
      if (list.length < 3) return { high:null, low:null };

      const pts = list
        .map(p => ({ t: timeStrToMinutes(p.time), cm: Number(p.cm) }))
        .filter(p => isFinite(p.cm))
        .sort((a,b)=> a.t - b.t);

      const highs = [];
      const lows  = [];
      for (let i=1;i<pts.length-1;i++){
        const a = pts[i-1], b = pts[i], c = pts[i+1];
        if (a.cm < b.cm && b.cm > c.cm) highs.push(pts[i].t);
        if (a.cm > b.cm && b.cm < c.cm) lows.push(pts[i].t);
      }

      const toHHMM = (m)=> `${String(Math.floor(m/60)).padStart(2,'0')}:${String(m%60).padStart(2,'0')}`;
      const fmt = (arr) => {
        const xs = arr.slice(0, 2).map(toHHMM);
        if (xs.length === 0) return null;    // その日なし
        if (xs.length === 1) xs.push('－');  // 片方しか無い → 「HH:MM／－」
        return xs.join('／');
      };
      return { high: fmt(highs), low: fmt(lows) };
    }

    // === 指定日のチャート取得（キャッシュ付） ===
    const tideChartCache = {};
    async function getTideChartForDate(lat, lon, isoWithOffset){
      if (!TIDE_PROXY_URL_FOR_TIDE || TIDE_PROXY_URL_FOR_TIDE.includes("your-worker")) return null;
      const harbor = await findNearestHarbor(lat, lon, 10);
      if (!harbor) return null;

      const d = new Date(isoWithOffset);
      const y = d.getFullYear();
      const m = d.getMonth() + 1;
      const da = d.getDate();
      const keyDate = `${y}-${String(m).padStart(2,'0')}-${String(da).padStart(2,'0')}`;
      const cacheKey = `${harbor.pc}-${harbor.hc}-${keyDate}`;
      if (tideChartCache[cacheKey]) {
        return { harbor, chart: tideChartCache[cacheKey], chartDateKey: keyDate };
      }

      const url = `${TIDE_PROXY_URL_FOR_TIDE}?pc=${encodeURIComponent(harbor.pc)}&hc=${encodeURIComponent(harbor.hc)}&yr=${y}&mn=${m}&dy=${da}&rg=day`;
      let tideJson=null;
      try{
        const res = await fetch(url);
        if (!res.ok) return null;
        tideJson = await res.json();
      }catch{ return null; }

      const chartAll = tideJson?.tide?.chart;
      if (!chartAll) return null;
      const chart = chartAll[keyDate] || chartAll[`${y}-${m}-${da}`] || chartAll[Object.keys(chartAll).sort().reverse()[0]];
      if (!chart) return null;

      tideChartCache[cacheKey] = chart;
      return { harbor, chart, chartDateKey: keyDate };
    }

    // === 釣果時刻の潮位(cm)と傾向 ===
    function nearestTideLevelCm(chart, localDate){
      const list = Array.isArray(chart?.tide) ? chart.tide : [];
      if (!list.length) return null;
      const target = localDate.getHours()*60 + localDate.getMinutes();
      let best = list[0], diff = Math.abs(timeStrToMinutes(best.time)-target);
      for (let i=1;i<list.length;i++){
        const d = Math.abs(timeStrToMinutes(list[i].time)-target);
        if (d < diff){ best = list[i]; diff = d; }
      }
      const cm = Number(best.cm);
      return isFinite(cm) ? Math.round(cm) : null;
    }

    function dateKeyFromIso(iso){
      const d = new Date(iso);
      const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), da=String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${da}`;
    }

    function tideInfoFromChart(chart, isoWithOffset){
      const localDate = new Date(isoWithOffset);
      const level_cm = nearestTideLevelCm(chart, localDate);
      const trend_text = analyzeTideTrendForTime(chart, localDate);
      return { level_cm, trend_text };
    }

    // ===== 開始時の潮 =====
    async function fetchTideForStart(lat, lon, startedAtIso){
      if (!TIDE_PROXY_URL_FOR_TIDE || TIDE_PROXY_URL_FOR_TIDE.includes("your-worker")) {
        LOG.tide("TIDE_PROXY_URL が未設定のためスキップ");
        return null;
      }
      const harbor = await findNearestHarbor(lat, lon, 10);
      if (!harbor) { LOG.tide("近傍港が見つかりません"); return null; }

      const d = new Date(startedAtIso);
      const yr = d.getFullYear();
      const mn = d.getMonth() + 1;
      const dy = d.getDate();

      const url = `${TIDE_PROXY_URL_FOR_TIDE}?pc=${encodeURIComponent(harbor.pc)}&hc=${encodeURIComponent(harbor.hc)}&yr=${yr}&mn=${mn}&dy=${dy}&rg=day`;
      LOG.tide("fetch:", url);

      let tideJson = null;
      try{
        const res = await fetch(url);
        if (!res.ok){ LOG.tide("tide http error", res.status); return null; }
        tideJson = await res.json();
      }catch(e){
        LOG.tide("tide fetch failed", e?.message);
        return null;
      }

      const chartAll = tideJson?.tide?.chart && typeof tideJson.tide.chart === 'object' ? tideJson.tide.chart : null;
      if (!chartAll) { LOG.tide("no chart in response"); return null; }

      const key1 = `${yr}-${mn}-${dy}`;
      const key2 = `${yr}-${String(mn).padStart(2,'0')}-${String(dy).padStart(2,'0')}`;
      let chartDateKey = null;
      let chart = null;
      if (chartAll[key1]) { chartDateKey = key1; chart = chartAll[key1]; }
      else if (chartAll[key2]) { chartDateKey = key2; chart = chartAll[key2]; }
      else {
        const keys = Object.keys(chartAll).sort().reverse();
        chartDateKey = keys[0] || null;
        chart = chartDateKey ? chartAll[chartDateKey] : null;
      }
      if (!chart) { LOG.tide("chart not found even after fallback"); return null; }

      const tideName = chart?.moon?.title || "不明";
      const sunrise  = chart?.sun?.rise || "不明";
      const sunset   = chart?.sun?.set  || "不明";
      const trendText= analyzeTideTrendForTime(chart, d);
      const rawAge = chart?.moon?.age;
      const rawBrightness =
        (chart?.moon?.brightness ?? chart?.moon?.illumination ?? chart?.moon?.percent ?? null);

      const age = Number.isFinite(Number(rawAge)) ? Number(rawAge) : null;
      const brightness = Number.isFinite(Number(rawBrightness)) ? Number(rawBrightness) : null;

      return {
        harbor: { pc: harbor.pc, hc: harbor.hc, pn: harbor.pn, hn: harbor.hn, lat: harbor.lat, lon: harbor.lon, dist_km: harbor.dist },
        tideName, sunrise, sunset, trendText,
        chartDateKey,
        chart,
        moon: (age != null || brightness != null) ? { age, brightness } : null
      };
    }

    function timeStrToMinutes(t){
      if (!t) return 0;
      if (t === "24:00") return 24*60;
      const [h,m] = t.split(":").map(n=>parseInt(n,10));
      return (isFinite(h)?h:0)*60 + (isFinite(m)?m:0);
    }

    function drawTideChartOnCanvas(canvas, chart){
      const ctx = canvas.getContext('2d');
      const W = 720, H = 260;
      canvas.width = W; canvas.height = H;

      const padding = { left: 48, right: 16, top: 16, bottom: 28 };
      const innerW = W - padding.left - padding.right;
      const innerH = H - padding.top - padding.bottom;

      const tideList = Array.isArray(chart?.tide) ? chart.tide : [];
      if (!tideList.length){
        ctx.clearRect(0,0,W,H);
        ctx.fillStyle = "#94a3b8";
        ctx.font = "12px sans-serif";
        ctx.fillText("この日の潮汐データがありません", 16, 24);
        return;
      }

      const points = tideList.map(p => ({
        xMin: Math.max(0, Math.min(1440, timeStrToMinutes(p.time))),
        cm: Number(p.cm)
      })).filter(p => isFinite(p.cm));

      const ys = points.map(p=>p.cm);
      let minY = Math.min(0, Math.min(...ys));
      let maxY = Math.max(0, Math.max(...ys));
      if (minY === maxY){ minY -= 10; maxY += 10; }

      const mapX = (min) => padding.left + (min/1440) * innerW;
      const mapY = (cm)  => padding.top + (maxY - cm) / (maxY - minY) * innerH;

      ctx.clearRect(0,0,W,H);
      ctx.fillStyle = "#0f172a";
      ctx.fillRect(0,0,W,H);

      ctx.strokeStyle = "#1e293b";
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let h=0; h<=24; h+=3){
        const x = mapX(h*60);
        ctx.moveTo(x, padding.top);
        ctx.lineTo(x, H - padding.bottom);
      }
      ctx.stroke();

      const yZero = mapY(0);
      ctx.strokeStyle = "#64748b";
      ctx.lineWidth = 1.5;
      ctx.setLineDash([4,4]);
      ctx.beginPath();
      ctx.moveTo(padding.left, yZero);
      ctx.lineTo(W - padding.right, yZero);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.strokeStyle = "#334155";
      ctx.lineWidth = 1;
      ctx.strokeRect(padding.left, padding.top, innerW, innerH);

      ctx.strokeStyle = "#38bdf8";
      ctx.lineWidth = 2;
      ctx.beginPath();
      points.forEach((p,i)=>{
        const x = mapX(p.xMin);
        const y = mapY(p.cm);
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.stroke();

      ctx.fillStyle = "#7dd3fc";
      points.forEach(p=>{
        const x = mapX(p.xMin);
        const y = mapY(p.cm);
        ctx.beginPath(); ctx.arc(x,y,2.2,0,Math.PI*2); ctx.fill();
      });

      ctx.fillStyle = "#cbd5e1";
      ctx.font = "11px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      [0,6,12,18,24].forEach(h=>{
        const x = mapX(h*60);
        ctx.fillText(`${String(h).padStart(2,"0")}:00`, x, H - padding.bottom + 6);
      });

      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      ctx.fillText(`${Math.round(maxY)} cm`, padding.left - 6, mapY(maxY));
      ctx.fillText(`0 cm`,              padding.left - 6, yZero);
      ctx.fillText(`${Math.round(minY)} cm`, padding.left - 6, mapY(minY));
    }

    // ======== ★追加：水温地点マッチング & 当日水温取得（既存 Workers を使用） ========
    // 地点リスト（GViz）
    let pointsCache = null;

    async function loadWaterTempPointsFromSheet(){
      if (pointsCache){
        if (DEBUG_WATER) LOG.wt("use cached points:", { count: pointsCache.mapped?.length ?? 0 });
        return pointsCache;
      }
      
      // ★追加：SHEET_ID が取得されるまで待機
      if (!SHEET_ID) {
        if (DEBUG_WATER) LOG.wt("loadWaterTempPointsFromSheet: Waiting for SHEET_ID...");
        await new Promise(resolve => {
          const check = () => {
            if (SHEET_ID) resolve();
            else setTimeout(check, 100);
          };
          setTimeout(check, 100);
        });
      }
      
      if (DEBUG_WATER) LOG.wt("loadWaterTempPointsFromSheet: start", { SHEET_ID, POINTS_SHEET_NAME });

      const rows = await loadSheetViaGAS(POINTS_SHEET_NAME, SHEET_ID);
      if (!rows || rows.length < 2) throw new Error("地点リストのデータが見つかりません");

      const headers = rows[0].map(h=>String(h||'').trim());
      const idxOf = (name) => headers.findIndex(h => h === name);
      const iName = idxOf("ポイント名");
      const iLat  = idxOf("緯度");
      const iLon  = idxOf("経度");
      const iCode = idxOf("ポイントコード");

      if (DEBUG_WATER) LOG.wt("sheet headers", headers);

      const mapped = [];
      for (let i=1; i<rows.length; i++){
        const r = rows[i];
        const name = r[iName] ?? '';
        const lat  = parseFloat(r[iLat]);
        const lon  = parseFloat(r[iLon]);
        const code = r[iCode] ?? '';
        if (!isFinite(lat) || !isFinite(lon) || !code) continue;
        mapped.push({ name, lat, lon, code });
      }

      pointsCache = { headers, rows, mapped };
      if (DEBUG_WATER){
        LOG.wt("points mapped:", { count: mapped.length });
        LOG.wt("points sample(3):", mapped.slice(0,3));
      }
      return pointsCache;
    }

    async function findNearestWaterTempPoint(lat, lon, radiusKm = 30){
      const pc = await loadWaterTempPointsFromSheet();
      if (DEBUG_WATER) LOG.wt("findNearestWaterTempPoint: args", { lat, lon, radiusKm });

      const candidates = pc.mapped
        .map(p => ({ ...p, dist: haversineDistance(lat, lon, p.lat, p.lon) }))
        .filter(p => p.dist <= radiusKm)
        .sort((a,b)=> a.dist - b.dist);

      if (DEBUG_WATER){
        LOG.wt("candidates within radius", { count: candidates.length });
        LOG.wt("top5 candidates", candidates.slice(0,5).map(c=>({ name:c.name, code:c.code, dist_km:+c.dist.toFixed(3) })));
      }
      const chosen = candidates[0] || null;
      if (DEBUG_WATER) LOG.wt("chosen point", chosen ? { name: chosen.name, code: chosen.code, dist_km:+chosen.dist.toFixed(3) } : null);
      return chosen;
    }

    function getTodayDateKeyJST(){
      const now = new Date();
      const y = now.getFullYear();
      const m = String(now.getMonth()+1).padStart(2,'0');
      const d = String(now.getDate()).padStart(2,'0');
      const key = `${y}-${m}-${d}`;
      if (DEBUG_WATER) LOG.wt("today key (JST)", key);
      return key;
    }

    async function fetchTodayWaterTempByNearest(lat, lon, targetDate = null){
      const tag = `[lat=${lat?.toFixed?.(5)}, lon=${lon?.toFixed?.(5)}]`;
      try{
       if (!WATER_WORKER_URL || /your[_-]?worker/i.test(WATER_WORKER_URL)){
          if (DEBUG_WATER) LOG.wt("skip: WATER_WORKER_URL is not set/placeholder");
          return null;
        }

        const point = await findNearestWaterTempPoint(lat, lon, 30);
        if (!point){
          if (DEBUG_WATER) LOG.wt("no nearest point found", { radiusKm: 30 });
          return null;
        }

        const base = `https://leisure-api-prod.n-kishou.co.jp/get-sea-water-temperature?code=${encodeURIComponent(point.code)}&type=forecast`;
        const url  = `${WATER_WORKER_URL.replace(/\/$/, '')}/proxy?url=${encodeURIComponent(base)}`;


        if (DEBUG_WATER) LOG.wt("request", { tag, worker: WATER_WORKER_URL, base, proxy: url, point });

        const res = await fetch(url, { method:'GET' });

        if (DEBUG_WATER){
          LOG.wt("response status", { status: res.status, ok: res.ok });
          // ヘッダは量が多いので主要なものだけ
          const ct = res.headers.get('content-type');
          LOG.wt("response content-type", ct);
        }

        if (!res.ok){
          const text = await res.text().catch(()=>"(body read error)");
          if (DEBUG_WATER) LOG.wt("response NG body snippet", text.slice(0,400));
          return null;
        }

        let j=null;
        try{
          j = await res.json();
        }catch(parseErr){
          if (DEBUG_WATER) LOG.wt("JSON parse error", String(parseErr));
          return null;
        }

        if (DEBUG_WATER){
          const keys = Object.keys(j || {});
          LOG.wt("json keys", keys);
          LOG.wt("result_list keys", Object.keys(j?.result_list || {}));
        }

        const data = j?.result_list?.data;
        const list = Array.isArray(data?.graph_data_main) ? data.graph_data_main : [];
        if (DEBUG_WATER){
          LOG.wt("graph_data_main length", list.length);
          LOG.wt("graph range", {
            min: data?.temperature_min_of_graph ?? null,
            max: data?.temperature_max_of_graph ?? null
          });
          if (list.length) LOG.wt("first 2 entries", list.slice(0,2));
        }

        // ★修正：targetDate が指定されている場合はそれを使用、無ければ今日の日付を使用
        let targetDateKey;
        if (targetDate && typeof targetDate === 'object' && typeof targetDate.toISOString === 'function') {
          // ISO形式の日付文字列から YYYY-MM-DD を抽出
          targetDateKey = targetDate.toISOString().split('T')[0];
          if (DEBUG_WATER) LOG.wt("target date (from param)", targetDateKey);
        } else {
          targetDateKey = getTodayDateKeyJST();
          if (DEBUG_WATER) LOG.wt("target date (today)", targetDateKey);
        }
        
        const today = list.find(x => typeof x?.datetime === 'string' && x.datetime.startsWith(targetDateKey));
        const temp = today ? parseFloat(today.temperature) : null;

        if (DEBUG_WATER) LOG.wt("match date", { targetDateKey, matched: today ?? null, temp });

        return {
          point_code: point.code,
          point_name: point.name,
          dist_km: point.dist,
          date: today?.datetime ?? null,
          temperature_c: isFinite(temp) ? Math.round(temp*10)/10 : null,
          graph_min: data?.temperature_min_of_graph ?? null,
          graph_max: data?.temperature_max_of_graph ?? null,
          _debug: DEBUG_WATER ? { proxy_url: url, base_url: base } : undefined
        };
      }catch(e){
        if (DEBUG_WATER) LOG.wt("failed", { tag, error: e?.message || String(e) });
        return null;
      }
    }


    // ===== UIレンダリング =====
    function render(){
      console.log('[render] full draft:', JSON.stringify(draft, null, 2));
      console.log('[render] draft.start_water_temp:', draft.start_water_temp);
      if (draft.start_water_temp) {
        console.log('[render] draft.start_water_temp.point_name:', draft.start_water_temp.point_name);
        console.log('[render] draft.start_water_temp.date:', draft.start_water_temp.date);
      }
      txtTripId.textContent = draft.tripId.slice(0,8);
      txtStatus.textContent = draft.status==='idle' ? '未開始' : (draft.status==='active' ? '釣行中' : '終了');
      txtStartedAt.textContent = draft.startedAt ? fmtLocal(draft.startedAt) : '—';
      txtCatchCount.textContent = (draft.catches?.length||0)+' 件';

      if(typeof draft.lat==='number' && typeof draft.lng==='number'){
        txtPosWrap.classList.remove('hidden'); txtLat.textContent=draft.lat.toFixed(5); txtLng.textContent=draft.lng.toFixed(5);
      }else{
        txtPosWrap.classList.add('hidden');
      }

      // ★修正：開始時の天気を上部に表示
      const wxBrief = draft.start_weather ? formatWeatherBrief(draft.start_weather) : null;
      document.getElementById('tripWeatherTop').textContent = wxBrief || '—';

      tripWeatherRow.innerHTML = '';
      const box = (label, val) => {
        const d=document.createElement('div');
        d.className='rounded-xl bg-slate-800/40 p-3';
        d.innerHTML = `<div class="text-xs text-slate-400">${label}</div>
                       <div class="text-sm text-slate-200 mt-0.5">${val || '—'}</div>`;
        return d;
      };

      // ★修正：潮汐情報と水温を1つのブロックにまとめる
      const tideName = draft.start_tide?.tideName || '—';
      const tideTrend = draft.start_tide?.trendText || '—';
      const wt = draft.start_water_temp;
      console.log('[render] water_temp raw:', { temperature_c: wt?.temperature_c, point_name: wt?.point_name, date: wt?.date });
      // 水温地点名から @HH:mm 以降を削除
      const cleanPointName = wt?.point_name ? (() => {
        const val = wt.point_name;
        const idx = val.indexOf(' @');
        const result = idx > -1 ? val.substring(0, idx) : val;
        console.log('[render] cleanPointName:', { raw: val, idx, result });
        return result;
      })() : '';
      const wtBrief = wt && wt.temperature_c!=null
        ? `${wt.temperature_c}℃${cleanPointName ? `（${cleanPointName}）` : ''}`
        : null;
      console.log('[render] wtBrief:', wtBrief);

      // 潮汐と水温が両方あれば1つのブロックに、なければ個別に
      if ((tideName !== '—' || tideTrend !== '—') || wtBrief) {
        const combineBox = document.createElement('div');
        combineBox.className = 'rounded-xl bg-slate-800/40 p-3 space-y-2';
        combineBox.innerHTML = `
          <div>
            <div class="text-xs text-slate-400">潮</div>
            <div class="text-sm text-slate-200">${tideName} / ${tideTrend}</div>
          </div>
          ${wtBrief ? `
          <div>
            <div class="text-xs text-slate-400">水温</div>
            <div class="text-sm text-slate-200">${wtBrief}</div>
          </div>` : ''}
        `;
        tripWeatherRow.appendChild(combineBox);
      }

      // ★修正：状態に応じてボタンを表示
      buttonRow.innerHTML='';
      if (draft.status==='idle'){
        // 未開始時：釣行開始ボタン
        const b=document.createElement('button'); 
        b.textContent='釣行開始';
        b.className='w-full py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500 font-semibold';
        b.onclick=startTrip; 
        buttonRow.appendChild(b);
      } else if (draft.status==='ended'){
        // ★追加：終了時：新規釣行ボタン
        const btnReset=document.createElement('button');
        btnReset.textContent='新規釣行';
        btnReset.className='w-full py-2 rounded-xl bg-slate-700 hover:bg-slate-600 font-semibold';
        btnReset.onclick=()=>{
          if(confirm('新しい釣行を開始しますか？')){
            draft = { tripId: uuid(), status: 'idle', catches: [], tide_daily_cache: {}, start_water_temp: null, memo: null };
            saveDraft(draft);
            render();
          }
        };
        buttonRow.appendChild(btnReset);
      }
      
      // 釣行中/終了時は固定底部バーを表示
      if (draft.status==='active'){ 
        bottomBar.classList.remove('hidden'); 
        hintAddWhenActive.classList.remove('hidden'); 
      }
      else { 
        bottomBar.classList.add('hidden'); 
        hintAddWhenActive.classList.add('hidden'); 
      }

      // 釣果リスト
      catchList.innerHTML='';
      const has = draft.catches && draft.catches.length>0;
      catchListEmpty.classList.toggle('hidden', has);
      if (has){
        draft.catches.forEach(c=>{
          const li=document.createElement('li'); li.className='rounded-xl bg-slate-900 border border-slate-800 p-3 flex gap-3';
          const thumbSrc = c.photoDriveThumbUrl || c.photoDriveUrl || c.photoPreviewUrl || "";
          let thumb;
          if (thumbSrc){
            thumb=document.createElement('img'); thumb.src=thumbSrc; thumb.alt='catch'; thumb.className='w-20 h-20 object-cover rounded-lg border border-slate-800';
          } else {
            thumb=document.createElement('div'); thumb.className='w-20 h-20 rounded-lg border border-dashed border-slate-700 grid place-items-center text-xs text-slate-500'; thumb.textContent='No Photo';
          }
          li.appendChild(thumb);

          const info=document.createElement('div'); info.className='flex-1 min-w-0';
          const row1=document.createElement('div'); row1.className='flex items-center justify-between';
          const title=document.createElement('div'); title.className='font-semibold truncate'; title.textContent=c.species||'(魚種未設定)';
          const tm=document.createElement('div'); tm.className='text-xs text-slate-400 ml-2'; try{ tm.textContent=new Date(c.timestamp).toLocaleTimeString(); }catch{ tm.textContent=''; }
          row1.appendChild(title); row1.appendChild(tm);

          const row2=document.createElement('div'); row2.className='text-sm text-slate-300 mt-1 flex flex-wrap gap-x-3 gap-y-1';
          if (c.size_cm!=null){ const sp=document.createElement('span'); sp.textContent='サイズ: '+c.size_cm+' cm'; row2.appendChild(sp); }
          if (c.weight_g!=null){ const sp=document.createElement('span'); sp.textContent='重量: '+c.weight_g+' g'; row2.appendChild(sp); }
          if (c.method){ const sp=document.createElement('span'); sp.textContent='方法: '+c.method; row2.appendChild(sp); }

          if (c.weather) {
            const rowWx = document.createElement('div');
            rowWx.className = 'text-xs text-slate-400 mt-1';
            rowWx.textContent = formatWeatherBrief(c.weather);
            info.appendChild(rowWx);
          }

          info.appendChild(row1); info.appendChild(row2);

          const ops=document.createElement('div'); ops.className='flex flex-col gap-1 shrink-0';
          const btnEdit=document.createElement('button'); btnEdit.className='px-2 py-1 text-xs rounded-lg border border-slate-700 hover:bg-slate-800'; btnEdit.textContent='編集';
          btnEdit.onclick=()=>openEditCatch(c.id);
          const btnDel=document.createElement('button'); btnDel.className='px-2 py-1 text-xs rounded-lg border border-slate-700 hover:bg-slate-800'; btnDel.textContent='削除';
          btnDel.onclick = async () =>{ 
            console.log('[DEBUG-Delete] 1. Delete button clicked');
            if (confirm('この釣果を削除しますか？')) {
              console.log('[DEBUG-Delete] 2. Confirmed delete');
              // ★修正：削除対象の釣果から photoFileId を取得
              const photoFileIdStatus = c?.photoFileId;
              console.log('[DEBUG-Delete] 3. photoFileId:', photoFileIdStatus);
              
              console.log('[DEBUG-Delete] 4. Before splice, catches count:', draft.catches.length);
              draft.catches = draft.catches.filter(x=>x.id!==c.id); 
              console.log('[DEBUG-Delete] 5. After splice, catches count:', draft.catches.length);
              
              console.log('[DEBUG-Delete] 6. Starting saveDraft...');
              await saveDraft(draft);
              console.log('[DEBUG-Delete] 7. saveDraft completed');
              
              // ★修正②: 削除後に補完ロジックを実行（手動釣行時のみ）
              if (draft.manualStarted) {
                console.log('[DEBUG-Delete] 8. Manual started, recalculating times...');
                // 手動釣行時は削除後に時刻を再計算してから画面更新
                const validTimes = draft.catches
                  .map(c => c.timestamp)
                  .filter(ts => !!ts);
                
                console.log('[DEBUG-Delete] 9. Valid times count:', validTimes.length);
                if (validTimes.length > 0) {
                  const earliestTime = validTimes.reduce((a, b) => a < b ? a : b);
                  const latestTime = validTimes.reduce((a, b) => a > b ? a : b);
                  draft.startedAt = earliestTime;
                  draft.endedAt = latestTime;
                  console.log('[DEBUG-Delete] 10. Updated times, saving...');
                  await saveDraft(draft);
                  console.log('[DEBUG-Delete] 11. Time save completed');
                } else {
                  // 釣果が全て削除された場合
                  draft.startedAt = null;
                  draft.endedAt = null;
                  console.log('[DEBUG-Delete] 12. All catches deleted, saving empty times...');
                  await saveDraft(draft);
                  console.log('[DEBUG-Delete] 13. Empty save completed');
                }
              }
              
              // ★修正③：即座に画面更新（長時間処理の _complementTripDataOnly は呼ばない）
              console.log('[DEBUG-Delete] 14. Starting render...');
              render();
              console.log('[DEBUG-Delete] 15. Render completed');
              
              // ★注記：画像削除は GAS の定期実行で自動削除（フロント側では何もしない）
              console.log('[DEBUG-Delete] 16. Photo will be cleaned up by GAS scheduled trigger');
              console.log('[DEBUG-Delete] 17. Delete process fully completed');
            }
          };
          ops.appendChild(btnEdit); ops.appendChild(btnDel);

          li.appendChild(info); li.appendChild(ops);
          catchList.appendChild(li);
        });
      }
    }
        // ===== 釣行の確認（Trips） =====
    const tripListEl = document.getElementById('tripList');
    const tripStatus = document.getElementById('tripStatus');
    const tripDetailWrap = document.getElementById('tripDetail');
    const tripDetailBody = document.getElementById('tripDetailBody');
    const btnCloseTripDetail = document.getElementById('btnCloseTripDetail');

    btnCloseTripDetail.onclick = () => tripDetailWrap.classList.add('hidden');

    function autoLoadTrips(){ 
      if (!tripsCache) {
        // SHEET_ID が未設定の場合、初期化完了を待つ
        if (!SHEET_ID) {
          console.log('[autoLoadTrips] SHEET_ID not yet loaded, waiting...');
          setTimeout(() => autoLoadTrips(), 100);
          return;
        }
        loadTrips();
      }
    }

    // 読込ボタンのハンドラ
    document.getElementById('btnLoadTrips').onclick = () => { autoLoadTrips(); };
    
    // クリアボタンのハンドラ
    document.getElementById('btnClearTrips').onclick = () => { 
      tripsCache = null; 
      tripListEl.innerHTML = ''; 
      tripDetailWrap.classList.add('hidden'); 
      tripStatus.textContent = '';
    };

    async function loadTrips(){
      try{
        tripStatus.textContent = '読込中...';
        tripListEl.innerHTML = '';
        tripDetailWrap.classList.add('hidden');
        
        console.log('[loadTrips] Starting with SHEET_ID:', SHEET_ID, 'TRIPS_SHEET_NAME:', TRIPS_SHEET_NAME);
        
        tripsCache = await loadSheetViaGAS(TRIPS_SHEET_NAME, SHEET_ID);
        console.log('[loadTrips] Trips loaded, rows:', tripsCache?.length || 0);
        
        // ★追加：釣果シートも読み込む
        catchesCache = await loadSheetViaGAS(SHEET_NAME, SHEET_ID);
        console.log('[loadTrips] Loaded caches:', { tripsCache: tripsCache?.length || 0, catchesCache: catchesCache?.length || 0 });
        
        if (!tripsCache || tripsCache.length < 2){
          tripStatus.textContent = 'Trips にデータが見つかりません';
          console.log('[loadTrips] No data found in Trips:', tripsCache);
          return;
        }
        renderTripsList(tripsCache);
        // ★追記: Trips フィルタ UI
        (function injectTripsFilterUI(){
          if (!tripStatus) return;
          const host = tripStatus.parentElement; if (!host) return;
          if (document.getElementById('tripsFilterBar')) return;
          const bar = document.createElement('div');
          bar.id = 'tripsFilterBar';
          bar.className = 'mt-2 flex flex-wrap gap-2 text-sm';
          bar.innerHTML = `
            <input id="tfFrom" type="date" class="px-2 py-1 rounded bg-slate-800 border border-slate-700" />
            <input id="tfTo"   type="date" class="px-2 py-1 rounded bg-slate-800 border border-slate-700" />
            <select id="tfSort" class="px-2 py-1 rounded bg-slate-800 border border-slate-700">
              <option value="start_desc">開始が新しい順</option>
            </select>
            <button id="tfApply" class="px-2 py-1 rounded border border-slate-700 hover:bg-slate-800">適用</button>
          `;
          host.appendChild(bar);
          document.getElementById('tfApply').onclick = ()=>{
            uiFilter.trips.dateFrom = document.getElementById('tfFrom').value || '';
            uiFilter.trips.dateTo   = document.getElementById('tfTo').value   || '';
            uiFilter.trips.sort     = document.getElementById('tfSort').value;
            const filtered = applyTripsFilter(tripsCache);
            renderTripsList(filtered);
          };
        })();
        tripStatus.textContent = `読み込み完了：${tripsCache.length-1}件`;
      }catch(e){
        console.error('[loadTrips] Error:', e);
        console.error('[loadTrips] Stack:', e.stack);
        tripStatus.textContent = `読込失敗: ${e.message||e}`;
      }
    }

    function hIdx(headers, name){
      const i = headers.findIndex(h => String(h||'').trim() === name);
      return i >= 0 ? i : -1;
    }

   function renderTripsList(rows){
      // --- helpers（この関数内だけ） ---
      const pad2 = n => String(n).padStart(2,'0');
      const fmtYMD = iso => {
        const d = new Date(iso); if (isNaN(d)) return '—';
        return `${d.getFullYear()}年${pad2(d.getMonth()+1)}月${pad2(d.getDate())}日`;
      };
            // "6:24:00" / "06:24" / GVizのDate(...) / 数値シリアルに対応して HH:MM を返す
      const hm = (v) => {
        if (v == null) return '';

        // 1) GVizの Date(YYYY,MM,DD,HH,MM,SS) 形式
        const ds = String(v);
        const mDate = ds.match(/^Date\(([^)]+)\)/);
        if (mDate) {
          const parts = mDate[1].split(',').map(n => parseInt(n.trim(), 10));
          const hh = parts[3] ?? 0;
          const mi = parts[4] ?? 0;
          return `${pad2(hh)}:${pad2(mi)}`;
        }

        // 2) 数値シリアル（1日=1.0 としての小数。GViz経由で数値になるケース）
        if (typeof v === 'number' && isFinite(v)) {
          // 小数部だけから時刻を復元（丸め誤差対策で四捨五入）
          const seconds = Math.round((v - Math.floor(v)) * 24 * 3600);
          const hh = Math.floor(seconds / 3600);
          const mi = Math.floor((seconds % 3600) / 60);
          return `${pad2(hh)}:${pad2(mi)}`;
        }

        // 3) 文字列 "6:24:00" / "06:24" など（先頭の HH:MM を抽出）
        const m = ds.match(/(\d{1,2}):(\d{2})/);
        return m ? `${pad2(m[1])}:${m[2]}` : '';
      };
      const hIdx = (hs, key) => hs.findIndex(h => String(h||'').trim() === key);

      const headers = rows[0];
      const col = {
        tripId:     hIdx(headers,'tripId'),
        startedAt:  hIdx(headers,'startedAt'),
        endedAt:    hIdx(headers,'endedAt'),
        catches:    hIdx(headers,'catches_count'),
        moon_v:     hIdx(headers,'moon_visual'),
        moon_a:     hIdx(headers,'moon_age'),
        sunrise:    hIdx(headers,'sunrise'),
        sunset:     hIdx(headers,'sunset'),
        raw_json:   hIdx(headers,'raw_json'),
        memo:       hIdx(headers,'memo')  // ★追加：メモカラムのインデックス
      };

      tripListEl.innerHTML = '';

      for (let i=1;i<rows.length;i++){
        const r = rows[i];

        const thisTripId = col.tripId>=0 ? (r[col.tripId] || '') : '';
        const started = col.startedAt>=0 ? (r[col.startedAt] || '') : '';
        const ended   = col.endedAt>=0   ? (r[col.endedAt]   || '') : '';
        const count   = Number(col.catches>=0 ? (r[col.catches] || 0) : 0);

        const moonV = col.moon_v>=0 ? (r[col.moon_v] || '') : '';
        const moonA = col.moon_a>=0 ? (r[col.moon_a] || '') : '';

        // 追加情報（潮名 / 日の出・日の入り / 開始時の天気）
        let tideName = '';
        let sunrise  = (col.sunrise>=0 ? (r[col.sunrise] || '') : '');
        let sunset   = (col.sunset>=0  ? (r[col.sunset]  || '') : '');
        let startWeatherBrief = '';

        // ★追加: 水温の概要
        let waterTempBrief = '';
        
        // ★追加：メモを取得（1行表示用）
        const memo = col.memo >= 0 ? (r[col.memo] || '') : '';
        const memoDisplay = memo ? memo.split('\n')[0].substring(0, 100) : '';  // 最初の1行、100文字まで

        try{
          const raw = (col.raw_json>=0 && r[col.raw_json]) ? JSON.parse(r[col.raw_json]) : null;

          if (!sunrise || !sunset){
            sunrise = sunrise || raw?.start_tide?.sunrise || raw?.start_tide?.chart?.sun?.rise || '';
            sunset  = sunset  || raw?.start_tide?.sunset  || raw?.start_tide?.chart?.sun?.set  || '';
          }
          tideName = raw?.start_tide?.tideName || raw?.start_tide?.chart?.moon?.title || '';
          if (raw?.start_weather) startWeatherBrief = formatWeatherBrief(raw.start_weather);

          // ★追加: raw_json に start_water_temp があれば優先
          const wt = raw?.start_water_temp;
          if (wt){
            const c = (wt.temperature_c!=null && wt.temperature_c!=='') ? `${wt.temperature_c}℃` : '';
            const p = wt.point_name ? `（${wt.point_name}）` : '';
            waterTempBrief = [c && (c+p)].filter(Boolean).join('');
          } else {
            // フォールバック: 列 water_temp_* があれば使用
            const iWtC = hIdx(headers,'water_temp_c');
            const iWtP = hIdx(headers,'water_temp_point');
            const iWtT = hIdx(headers,'water_temp_time');
            const c = (iWtC>=0 ? r[iWtC] : '');
            const p = (iWtP>=0 ? r[iWtP] : '');
            const t = (iWtT>=0 ? r[iWtT] : '');
            if (c!=='' || p || t){
              const cText = (c!=='' ? `${c}℃` : '');
              const pText = p ? `（${p}）` : '';
              waterTempBrief = [cText && (cText+pText)].filter(Boolean).join('');
            }
          }
        }catch{}

        // === 折りたたみ型カード ===
        const wrap = document.createElement('details');
        wrap.className = 'rounded-2xl bg-slate-900 border border-slate-800 mb-2';

        // summary（一覧ヘッダ部）
        const summary = document.createElement('summary');
        summary.className = 'list-none p-3 flex items-center justify-between hover:bg-slate-800/60 cursor-pointer rounded-2xl';

        const left = document.createElement('div');
        left.className = 'min-w-0';
        left.innerHTML = `
          <div class="text-slate-200 font-medium flex flex-wrap gap-x-4 gap-y-1 items-center">
            <span>${started ? fmtYMD(started) : (ended ? fmtYMD(ended) : '—')}</span>
            ${tideName ? `${pill(tideName,'sky')}` : ''}
            ${moonV ? `<span class="text-xl leading-none">${moonV}</span>` : ''}
            ${(moonA||moonA===0) ? `<span class="text-slate-300 text-sm">月齢 <span class="text-slate-100">${moonA}</span></span>` : ''}
          </div>
          <div class="text-sm text-slate-300 mt-1 flex items-center gap-2">
            ${sunrise  ? `<span class="text-slate-400">日の出</span><span class="text-slate-200">${hm(sunrise)}</span>` : ''}
            ${sunset   ? `<span class="text-slate-400">日の入り</span><span class="text-slate-200">${hm(sunset)}</span>` : ''}
          </div>
          ${startWeatherBrief ? `<div class="text-sm text-slate-300 mt-2">${startWeatherBrief}</div>` : ''}
          <!-- ★追加: 水温の概要 -->
          ${waterTempBrief ? `<div class="text-sm text-slate-300 mt-1">水温: <span class="text-slate-100">${waterTempBrief}</span></div>` : ''}
          <!-- ★追加: メモを1行表示 -->
          ${memoDisplay ? `<div data-role="memo-summary" class="text-sm text-slate-300 mt-2 p-2 rounded bg-slate-800/50 border-l-2 border-slate-600 cursor-pointer hover:bg-slate-800/70 transition w-full flex items-center justify-between gap-2"><span class="text-slate-100 truncate flex-1">${memoDisplay.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</span>${memo && memo.length > memoDisplay.length ? ` <button type="button" data-role="memo-expand-inline" class="shrink-0 text-xs text-sky-400 hover:text-sky-300 hover:underline bg-transparent border-none p-0 font-normal">Read more</button>` : ''}</div>` : ''}
        `;

        const right = document.createElement('div');
        right.className = 'text-sm text-slate-200 shrink-0';
        right.textContent = `釣果：${isFinite(count)?count:0}匹`;

        summary.appendChild(left);
        summary.appendChild(right);
        wrap.appendChild(summary);

        // ★追加：一覧表示のメモ「Read more」ボタンのハンドラ
        if (memo) {
          const memoExpandBtn = left.querySelector('[data-role="memo-expand-inline"]');
          if (memoExpandBtn) {
            memoExpandBtn.onclick = (e) => {
              e.stopPropagation();
              // summary を非表示にして詳細部分にメモを拡張表示
              const memoSummaryDiv = left.querySelector('[data-role="memo-summary"]');
              if (memoSummaryDiv) {
                // メモ表示部分を拡張
                const expandedMemo = document.createElement('div');
                expandedMemo.className = 'text-sm text-slate-300 mt-2 p-2 rounded bg-slate-800/50 border-l-2 border-slate-600 w-full flex flex-col gap-2';
                expandedMemo.innerHTML = `
                  <div class="text-slate-100 whitespace-pre-wrap break-words">${memo.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>
                  <button type="button" data-role="memo-collapse-inline" class="self-end text-xs text-sky-400 hover:text-sky-300 hover:underline bg-transparent border-none p-0 font-normal cursor-pointer">▲ 閉じる</button>
                `;
                
                // 元のメモを置き換え
                memoSummaryDiv.replaceWith(expandedMemo);
                
                // 閉じるボタンハンドラ
                const collapseBtn = expandedMemo.querySelector('[data-role="memo-collapse-inline"]');
                if (collapseBtn) {
                  collapseBtn.onclick = (e) => {
                    e.stopPropagation();
                    // 元の状態に戻す
                    const contractedMemo = document.createElement('div');
                    contractedMemo.setAttribute('data-role', 'memo-summary');
                    contractedMemo.className = 'text-sm text-slate-300 mt-2 p-2 rounded bg-slate-800/50 border-l-2 border-slate-600 cursor-pointer hover:bg-slate-800/70 transition w-full flex items-center justify-between gap-2';
                    contractedMemo.innerHTML = `<span class="text-slate-100 truncate flex-1">${memoDisplay.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</span>${memo && memo.length > memoDisplay.length ? ` <button type="button" data-role="memo-expand-inline" class="shrink-0 text-xs text-sky-400 hover:text-sky-300 hover:underline bg-transparent border-none p-0 font-normal">Read more</button>` : ''}`;
                    expandedMemo.replaceWith(contractedMemo);
                    
                    // 再度ボタンハンドラを設定
                    const newBtn = contractedMemo.querySelector('[data-role="memo-expand-inline"]');
                    if (newBtn) {
                      newBtn.onclick = arguments.callee;  // 再帰的に呼び出し
                    }
                  };
                }
              }
            };
          }
        }

        // 展開ボディ（閉じるボタン付き）
        const detail = document.createElement('div');
        detail.className = 'px-3 pb-3';
        detail.innerHTML = `
          <div class="flex items-center justify-between mt-1 mb-2">
            <div class="text-xs text-slate-400">この釣行の釣果</div>
            <button type="button" data-role="trip-detail-close"
              class="text-xs px-2 py-1 rounded-lg border border-slate-700 hover:bg-slate-800">
              閉じる
            </button>
          </div>
          <div class="text-sm text-slate-400" data-role="trip-catches-loading">読み込み中...</div>
          <div class="grid md:grid-cols-2 gap-3 mt-2" data-role="trip-catches-list"></div>
          <div class="flex justify-end mt-3">
            <button type="button" data-role="trip-edit" class="px-3 py-1.5 bg-blue-600 hover:bg-blue-700 rounded text-white text-xs font-medium">✎ 編集</button>
          </div>
        `;
        wrap.appendChild(detail);

        // 「閉じる」ボタンでこの details を閉じる
        detail.querySelector('[data-role="trip-detail-close"]').onclick = (e)=>{
          e.stopPropagation();
          wrap.open = false;
        };

        // 「編集」ボタンの処理
        detail.querySelector('[data-role="trip-edit"]').onclick = async (e)=>{
          e.stopPropagation();
          console.log('[TripCard] edit button clicked, attempting to open modal');
          try {
            if (!tripsCache || tripsCache.length < 2) {
              alert('釣行データが見つかりません');
              return;
            }
            
            const headers = tripsCache[0];
            const col = {};
            for (let i = 0; i < headers.length; i++) {
              col[String(headers[i]).trim()] = i;
            }
            
            console.log('[TripCard] col keys available:', Object.keys(col).sort());
            console.log('[TripCard] tide_trend index:', col.tide_trend, 'tide_level_cm index:', col.tide_level_cm);

            // tripIdから該当行を検索
            const tripRow = tripsCache.find((t, idx) => idx > 0 && String(t[col.tripId]) === String(thisTripId));
            if (!tripRow) {
              alert('該当する釣行が見つかりません');
              return;
            }

            // draftを該当データで初期化
            // ★修正：釣果シートのカラムマッピングを作成
            let catchHeadersForEdit = (catchesCache || [])[0] || [];
            let colCatchForEdit = {};
            for (let i = 0; i < catchHeadersForEdit.length; i++) {
              colCatchForEdit[String(catchHeadersForEdit[i]).trim()] = i;
            }

            const tripCatches = (catchesCache || []).slice(1).filter(c => String(c[colCatchForEdit.tripId]) === String(thisTripId)) || [];
            console.log('[TripCard] tripCatches debug', {
              catchesCacheLength: catchesCache?.length || 0,
              catchHeaders: catchHeadersForEdit,
              colCatch: colCatchForEdit,
              thisTripId,
              col_catch_tripId: colCatchForEdit.tripId,
              tripCatchesLength: tripCatches.length,
              tripCatches: tripCatches,  // 全データを表示
              firstRow: tripCatches[0]   // 最初の行の詳細
            });
            
            // ★追加：raw_json から start_tide を取得
            let start_tide = null;
            if (col.raw_json >= 0) {
              const rawJson = tripRow[col.raw_json];
              try {
                if (rawJson) {
                  const raw = typeof rawJson === 'string' ? JSON.parse(rawJson) : rawJson;
                  start_tide = raw?.start_tide || null;
                }
              } catch (e) {
                // パース失敗時は start_tide = null
              }
            }
            
            draft = {
              tripId: tripRow[col.tripId] || '',
              status: tripRow[col.status] || 'ended',
              startedAt: tripRow[col.startedAt] || null,
              endedAt: tripRow[col.endedAt] || null,
              lat: parseFloat(tripRow[col.pos_lat]) || null,
              lng: parseFloat(tripRow[col.pos_lng]) || null,
              start_weather: tripRow[col.start_weather_main] ? {
                temp: parseFloat(tripRow[col.start_temp]) || null,
                wind_speed: parseFloat(tripRow[col.start_wind_speed]) || null,
                wind_deg: parseFloat(tripRow[col.start_wind_deg]) || null,
                weather_main: tripRow[col.start_weather_main] || '',
                weather_description: tripRow[col.start_weather_desc] || ''
              } : null,
              start_water_temp: tripRow[col.water_temp_c] ? {
                temperature_c: parseFloat(tripRow[col.water_temp_c]) || null,
                point_name: String(tripRow[col.water_temp_point] || '') || null,
                date: tripRow[col.water_temp_time] || null
              } : null,
              weather: tripRow[col.start_weather_main] || null,  // ★補完用：天気
              tide_trend: tripRow[col.tide_trend] || null,  // ★補完用：潮汐傾向
              tide_level_cm: tripRow[col.tide_level_cm] ? parseFloat(tripRow[col.tide_level_cm]) : null,  // ★補完用：潮位
              // ★修正：既存釣果を配列形式からオブジェクト形式に正規化
              catches: tripCatches.map(c => normalizeCatch(c, colCatchForEdit)),
              start_tide: start_tide,  // ★追加：raw_json から取得した潮汐データ
              tide_daily_cache: {},
              manualStarted: true,  // 既存データ編集なので手動扱い
              memo: tripRow[col.memo] || null  // ★追加：メモを保存
            };
            
            console.log('[TripCard] draft set:', {
              col_water_temp_c: col.water_temp_c,
              col_water_temp_point: col.water_temp_point,
              col_water_temp_time: col.water_temp_time,
              tripRow_water_temp_c: tripRow[col.water_temp_c],
              tripRow_water_temp_point: tripRow[col.water_temp_point],
              tripRow_water_temp_time: tripRow[col.water_temp_time],
              draft_start_water_temp: draft.start_water_temp
            });

            LOG.app('[TripCard] edit initiated', { tripId: thisTripId, draftCatches: draft.catches.length });
            
            // 編集モーダルを開く
            wrap.open = false;
            
            // ★釣行編集モーダルにデータを反映
            const editTripStarted = document.getElementById('editTripStarted');
            const editTripEnded = document.getElementById('editTripEnded');
            const editTripLat = document.getElementById('editTripLat');
            const editTripLng = document.getElementById('editTripLng');
            const editTripWeather = document.getElementById('editTripWeather');
            const editTripTide = document.getElementById('editTripTide');
            const editTripWaterTemp = document.getElementById('editTripWaterTemp');
            const editCatchList = document.getElementById('editCatchList');
            const editCatchCount = document.getElementById('editCatchCount');
            const uploadReviewModal = document.getElementById('uploadReviewModal');
            const tripEditModal = document.getElementById('tripEditModal');

            // 釣行基本情報を入力欄に反映
            if (draft.startedAt) {
              const d = new Date(draft.startedAt);
              editTripStarted.value = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
            } else {
              editTripStarted.value = '';
            }

            if (draft.endedAt) {
              const d = new Date(draft.endedAt);
              editTripEnded.value = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
            } else {
              editTripEnded.value = '';
            }

            editTripLat.value = typeof draft.lat === 'number' ? draft.lat : '';
            editTripLng.value = typeof draft.lng === 'number' ? draft.lng : '';

            // ★追加：メモを反映
            const editTripMemo = document.getElementById('editTripMemo');
            if (editTripMemo) {
              editTripMemo.value = draft.memo || '';
            }

            // 補完データを表示
            editTripWeather.textContent = draft.start_weather ? formatWeatherBrief(draft.start_weather) : '未設定';
            editTripTide.textContent = draft.start_tide 
              ? `${draft.start_tide.tideName || ''} / ${draft.start_tide.trendText || ''}`
              : '未設定';
            editTripWaterTemp.textContent = draft.start_water_temp && draft.start_water_temp.temperature_c != null
              ? `${draft.start_water_temp.temperature_c}℃${draft.start_water_temp.point_name ? `（${draft.start_water_temp.point_name}）` : ''}`
              : '未設定';

            // ★修正：釣果リストを表示（配列データをオブジェクトに変換）
            const cts = draft.catches || [];
            editCatchList.innerHTML = '';
            editCatchCount.textContent = cts.length;

            // ★修正：draft.catches は既に normalizeCatch() で正規化されているので、
            // そのまま使用する（再度normalizeCatch()は呼び出さない）
            console.log('[TripCard] Edit modal - draft.catches:', cts);

            cts.forEach((c, idx) => {
              // draft.catches のオブジェクトをそのまま使用
              const catchObj = c;
              console.log(`[TripCard] catch[${idx}]:`, catchObj);

              const item = document.createElement('div');
              item.className = 'bg-slate-800 rounded-lg p-3 flex items-start justify-between';

              const content = document.createElement('div');
              content.className = 'flex-1 cursor-pointer hover:bg-slate-700/30 rounded p-1 transition';
              
              // 時間のみを表示（HH:MM:SS形式）
              let timeStr = '';
              if (catchObj.timestamp) {
                const d = new Date(catchObj.timestamp);
                timeStr = `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}:${String(d.getSeconds()).padStart(2,'0')}`;
              }
              
              // 潮汐情報（下げ潮（7分）109 cm のような形式）
              const tideInfo = [];
              if (catchObj.tide_trend) tideInfo.push(catchObj.tide_trend);
              if (catchObj.tide_level_cm != null) tideInfo.push(catchObj.tide_level_cm + ' cm');
              const tideStr = tideInfo.length > 0 ? tideInfo.join(' ') : '';
              
              content.innerHTML = `
                <div class="font-semibold text-slate-100 text-sm">${catchObj.species || '(魚種未設定)'} ${catchObj.size_cm ? catchObj.size_cm + ' cm' : ''}</div>
                <div class="text-slate-400 text-xs mt-1">${timeStr}</div>
                ${tideStr ? `<div class="text-slate-300 text-xs mt-1">${tideStr}</div>` : ''}
              `;

              // ★追加：編集ボタン
              const btnEdit = document.createElement('button');
              btnEdit.className = 'text-xs py-1 px-2 rounded bg-blue-900 hover:bg-blue-800 text-blue-200 ml-2';
              btnEdit.textContent = '編集';
              btnEdit.onclick = (e) => {
                e.stopPropagation();
                // 編集フォームにデータを展開
                const editFormSection = document.getElementById('editCatchFormSection');
                const editFormTime = document.getElementById('editFormCatchTime');
                const editFormSpecies = document.getElementById('editFormCatchSpecies');
                const editFormSize = document.getElementById('editFormCatchSize');
                const editFormWeight = document.getElementById('editFormCatchWeight');
                const editFormMethod = document.getElementById('editFormCatchMethod');
                
                // ★追加：編集中のインデックスを保存（更新時に使用）
                editFormSection.dataset.editingIndex = idx;
                editFormSection.dataset.isEditing = 'true';
                
                // 既存データを展開
                if (catchObj.timestamp) {
                  // ★修正：toLocalInputValue 関数を使用（ローカルタイムゾーン対応）
                  try {
                    const dt = new Date(catchObj.timestamp);
                    editFormTime.value = toLocalInputValue(dt);
                    console.log('[TripEdit] timestamp converted:', {
                      original: catchObj.timestamp,
                      formatted: editFormTime.value
                    });
                  } catch (e) {
                    console.warn('[TripEdit] timestamp parse failed:', e);
                    editFormTime.value = '';
                  }
                } else {
                  editFormTime.value = '';
                }
                editFormSpecies.value = catchObj.species || '';
                editFormSize.value = catchObj.size_cm ? String(catchObj.size_cm) : '';
                editFormWeight.value = catchObj.weight_g ? String(catchObj.weight_g) : '';
                editFormMethod.value = catchObj.method || '';
                
                // 写真プレビューはクリア（既存の写真は表示しない、新規選択のみ対応）
                document.getElementById('editFormCatchPhoto').value = '';
                document.getElementById('editFormCatchPhotoPreview').classList.add('hidden');
                
                // フォームセクションを表示
                editFormSection.classList.remove('hidden');
                
                // 保存ボタンのテキストを変更
                document.getElementById('btnSaveCatchFormInEdit').textContent = '更新';
                
                // フォームにスクロール
                editFormSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
                
                console.log('[TripEdit] Editing catch at index:', idx, 'data:', catchObj);
              };

              const btnDelete = document.createElement('button');
              btnDelete.className = 'text-xs py-1 px-2 rounded bg-red-900 hover:bg-red-800 text-red-200 ml-2';
              btnDelete.textContent = '削除';
              btnDelete.onclick = async (e) => {
                e.stopPropagation();
                console.log('[DEBUG-EditDelete] 1. Delete button clicked in edit modal, idx:', idx);
                if (confirm('この釣果を削除しますか？')) {
                  console.log('[DEBUG-EditDelete] 2. Confirmed delete at idx:', idx);
                  
                  // ★修正：削除対象の釣果から photoFileId を取得
                  const catchToDelete = draft.catches[idx];
                  const photoFileId = catchToDelete?.photoFileId;
                  console.log('[DEBUG-EditDelete] 3. photoFileId:', photoFileId);
                  
                  console.log('[DEBUG-EditDelete] 4. Before splice, catches count:', draft.catches.length);
                  draft.catches.splice(idx, 1);
                  console.log('[DEBUG-EditDelete] 5. After splice, catches count:', draft.catches.length);
                  
                  console.log('[DEBUG-EditDelete] 6. Starting saveDraft...');
                  await saveDraft(draft);
                  console.log('[DEBUG-EditDelete] 7. saveDraft completed');
                  
                  // ★注記：画像削除は GAS の定期実行で自動削除（フロント側では何もしない）
                  console.log('[DEBUG-EditDelete] 8. Photo will be cleaned up by GAS scheduled trigger');
                  
                  // 手動釣行時は補完ロジックを実行、通常釣行時はローカル再描画
                  console.log('[DEBUG-EditDelete] 9. draft.manualStarted:', draft.manualStarted);
                  if (draft.manualStarted) {
                    console.log('[DEBUG-EditDelete] 10. Manual mode, recalculating times...');
                    // 手動釣行時は削除後に時刻を再計算してから画面更新
                    const validTimes = draft.catches
                      .map(c => c.timestamp)
                      .filter(ts => !!ts);
                    
                    console.log('[DEBUG-EditDelete] 11. Valid times count:', validTimes.length);
                    if (validTimes.length > 0) {
                      const earliestTime = validTimes.reduce((a, b) => a < b ? a : b);
                      const latestTime = validTimes.reduce((a, b) => a > b ? a : b);
                      draft.startedAt = earliestTime;
                      draft.endedAt = latestTime;
                      console.log('[DEBUG-EditDelete] 12. Updated times, saving...');
                      await saveDraft(draft);
                      console.log('[DEBUG-EditDelete] 13. Time save completed');
                    } else {
                      // 釣果が全て削除された場合
                      draft.startedAt = null;
                      draft.endedAt = null;
                      console.log('[DEBUG-EditDelete] 14. All catches deleted, saving empty times...');
                      await saveDraft(draft);
                      console.log('[DEBUG-EditDelete] 15. Empty save completed');
                    }
                  }
                  
                  console.log('[DEBUG-EditDelete] 16. Starting render catch list...');
                  // 釣果リストを再描画（スコープ内で再度ループ）
                  const renderEditCatchListAfterDelete = () => {
                    console.log('[DEBUG-EditDelete] 17. Inside renderEditCatchListAfterDelete');
                    const ctsList = draft.catches || [];
                    console.log('[DEBUG-EditDelete] 18. ctsList length:', ctsList.length);
                    editCatchList.innerHTML = '';
                    editCatchCount.textContent = ctsList.length;

                    // ★修正：ctsList は既に normalizeCatch() で正規化されたオブジェクト配列なので、
                    // そのまま使用する（再度normalizeCatch()は呼び出さない）
                    ctsList.forEach((c, i) => {
                      // ctsList のオブジェクトをそのまま使用
                      const catchObjTemp = c;

                      const itemTemp = document.createElement('div');
                      itemTemp.className = 'bg-slate-800 rounded-lg p-3 flex items-start justify-between';

                      const contentTemp = document.createElement('div');
                      contentTemp.className = 'flex-1 cursor-pointer hover:bg-slate-700/30 rounded p-1 transition';
                      
                      let timeStrTemp = '';
                      if (catchObjTemp.timestamp) {
                        const d = new Date(catchObjTemp.timestamp);
                        timeStrTemp = `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}:${String(d.getSeconds()).padStart(2,'0')}`;
                      }
                      
                      const tideInfoTemp = [];
                      if (catchObjTemp.tide_trend) tideInfoTemp.push(catchObjTemp.tide_trend);
                      if (catchObjTemp.tide_level_cm != null) tideInfoTemp.push(catchObjTemp.tide_level_cm + ' cm');
                      const tideStrTemp = tideInfoTemp.length > 0 ? tideInfoTemp.join(' ') : '';
                      
                      contentTemp.innerHTML = `
                        <div class="font-semibold text-slate-100 text-sm">${catchObjTemp.species || '(魚種未設定)'} ${catchObjTemp.size_cm ? catchObjTemp.size_cm + ' cm' : ''}</div>
                        <div class="text-slate-400 text-xs mt-1">${timeStrTemp}</div>
                        ${tideStrTemp ? `<div class="text-slate-300 text-xs mt-1">${tideStrTemp}</div>` : ''}
                      `;

                      const btnDeleteTemp = document.createElement('button');
                      btnDeleteTemp.className = 'text-xs py-1 px-2 rounded bg-red-900 hover:bg-red-800 text-red-200 ml-2';
                      btnDeleteTemp.textContent = '削除';
                      btnDeleteTemp.onclick = async (e) => {
                        e.stopPropagation();
                        console.log('[DEBUG-EditDeleteNested] 1. Nested delete button clicked, i:', i);
                        if (confirm('この釣果を削除しますか？')) {
                          console.log('[DEBUG-EditDeleteNested] 2. Confirmed nested delete at i:', i);
                          // ★修正：削除対象の釣果から photoFileId を取得
                          const catchToDeleteTemp = draft.catches[i];
                          const photoFileIdTemp = catchToDeleteTemp?.photoFileId;
                          console.log('[DEBUG-EditDeleteNested] 3. photoFileId:', photoFileIdTemp);
                          
                          console.log('[DEBUG-EditDeleteNested] 4. Before splice, catches count:', draft.catches.length);
                          draft.catches.splice(i, 1);
                          console.log('[DEBUG-EditDeleteNested] 5. After splice, catches count:', draft.catches.length);
                          
                          console.log('[DEBUG-EditDeleteNested] 6. Starting saveDraft...');
                          await saveDraft(draft);
                          console.log('[DEBUG-EditDeleteNested] 7. saveDraft completed');
                          
                          // ★注記：画像削除は GAS の定期実行で自動削除（フロント側では何もしない）
                          console.log('[DEBUG-EditDeleteNested] 8. Photo will be cleaned up by GAS scheduled trigger');
                          // 手動釣行時は時刻を再計算
                          console.log('[DEBUG-EditDeleteNested] 9. draft.manualStarted:', draft.manualStarted);
                          if (draft.manualStarted) {
                            console.log('[DEBUG-EditDeleteNested] 10. Recalculating times...');
                            const validTimes = draft.catches
                              .map(c => c.timestamp)
                              .filter(ts => !!ts);
                            
                            console.log('[DEBUG-EditDeleteNested] 11. Valid times count:', validTimes.length);
                            if (validTimes.length > 0) {
                              const earliestTime = validTimes.reduce((a, b) => a < b ? a : b);
                              const latestTime = validTimes.reduce((a, b) => a > b ? a : b);
                              draft.startedAt = earliestTime;
                              draft.endedAt = latestTime;
                              console.log('[DEBUG-EditDeleteNested] 12. Updated times, saving...');
                            } else {
                              draft.startedAt = null;
                              draft.endedAt = null;
                              console.log('[DEBUG-EditDeleteNested] 13. All catches deleted, saving empty times...');
                            }
                            console.log('[DEBUG-EditDeleteNested] 14. Saving times...');
                            await saveDraft(draft);
                            console.log('[DEBUG-EditDeleteNested] 15. Time save completed');
                          }
                          
                          console.log('[DEBUG-EditDeleteNested] 16. Calling renderEditCatchListAfterDelete...');
                          renderEditCatchListAfterDelete();
                          console.log('[DEBUG-EditDeleteNested] 17. Nested delete process completed');
                        }
                      };

                      itemTemp.appendChild(contentTemp);
                      itemTemp.appendChild(btnDeleteTemp);
                      editCatchList.appendChild(itemTemp);
                    });
                    console.log('[DEBUG-EditDelete] 19. forEach completed, renderEditCatchListAfterDelete done');
                  };
                  console.log('[DEBUG-EditDelete] 20. Calling renderEditCatchListAfterDelete...');
                  renderEditCatchListAfterDelete();
                  console.log('[DEBUG-EditDelete] 21. Edit delete process completed');
                }
              };

              item.appendChild(content);
              item.appendChild(btnEdit);
              item.appendChild(btnDelete);
              editCatchList.appendChild(item);
            });

            // モーダルを表示
            uploadReviewModal.classList.add('hidden');
            tripEditModal.classList.remove('hidden');
            
            // ★強制的に display を設定（inline style で上書き）
            tripEditModal.style.display = 'grid';
            
            // ★スクロール位置をモーダルに合わせる
            tripEditModal.scrollIntoView({ behavior: 'smooth', block: 'center' });

            LOG.app('[TripEdit] opened', { catchCount: draft.catches?.length || 0 });
            
            // ★デバッグ: モーダルが実際に表示されているか確認
            console.log('[TripCard] tripEditModal classes:', tripEditModal.className);
            console.log('[TripCard] tripEditModal display:', window.getComputedStyle(tripEditModal).display);
            console.log('[TripCard] tripEditModal visibility:', window.getComputedStyle(tripEditModal).visibility);
            console.log('[TripCard] tripEditModal style.display:', tripEditModal.style.display);

          } catch (err) {
            console.error('[TripCard] edit failed:', err);
            console.error('[TripCard] error stack:', err.stack);
            alert('編集中にエラーが発生しました: ' + err.message);
          }
        };

        // 開閉に合わせて hover を無効/有効化
        wrap.addEventListener('toggle', () => {
          if (wrap.open) summary.classList.remove('hover:bg-slate-800/60');
          else summary.classList.add('hover:bg-slate-800/60');
        });

        // 開いた時に Catches シートから tripId で該当釣果を読み込み
        wrap.addEventListener('toggle', async () => {
          if (!wrap.open) return;

          const listEl = detail.querySelector('[data-role="trip-catches-list"]');
          const loadingEl = detail.querySelector('[data-role="trip-catches-loading"]');
          if (listEl.dataset.loaded === '1') return; // 二重ロード防止

          try{
            const rowsC = await loadSheetViaGAS('Catches', SHEET_ID);
            const hs = rowsC[0].map(h=>String(h||'').trim());
            const cTrip   = hs.indexOf('tripId');
            const cSpec   = hs.indexOf('species');
            const cTime   = hs.indexOf('timestamp');
            const cSize   = hs.indexOf('size_cm');
            const cUrl    = hs.indexOf('photo_view_url');
            const cThumb  = hs.indexOf('photo_thumb_url');
            const cTrend  = hs.indexOf('tide_trend');
            const cTideLv = hs.indexOf('tide_level_cm');

            const items = [];
            for (let j=1;j<rowsC.length;j++){
              const rr = rowsC[j];
              if (String(rr[cTrip]||'') !== String(thisTripId)) continue;
              items.push({
                species: rr[cSpec] || '',
                ts: rr[cTime] || '',
                size: rr[cSize] || '',
                photo: rr[cThumb] || rr[cUrl] || '',
                tideTrend: rr[cTrend] || '',
                tideLevel: rr[cTideLv]
              });
            }

            loadingEl.remove();
            if (!items.length){
              const empty = document.createElement('div');
              empty.className = 'text-sm text-slate-500';
              empty.textContent = '該当する釣果はありません。';
              listEl.appendChild(empty);
            }else{
              items.forEach(c=>{
                const card = document.createElement('div');
                // 枠線を無くして控えめな背景のみ
                card.className = 'rounded-lg bg-slate-900/60 p-3 flex gap-3 items-start';
                const img = document.createElement('img');
                img.className = 'w-20 h-20 object-cover rounded-lg bg-slate-950';
                img.src = resolvePhotoUrl(c.photo) || '';
                img.alt = 'photo';
                card.appendChild(img);

                const info = document.createElement('div');
                info.className = 'flex-1 min-w-0';
                info.innerHTML = `
                  <div class="font-semibold truncate">
                    ${c.species||'(魚種不明)'} ${c.size?`<span class="text-sm text-slate-300 ml-1">${c.size} cm</span>`:''}
                  </div>
                  <div class="text-xs text-slate-400 mt-0.5">${c.ts ? new Date(c.ts).toLocaleString() : ''}</div>
                  <div class="mt-1 flex flex-wrap items-center gap-2">
                    ${c.tideTrend ? pill(c.tideTrend,'emerald') : ''}
                    ${(c.tideLevel || c.tideLevel===0) ? pill(`${c.tideLevel} cm`, 'violet') : ''}
                  </div>
                `;
                card.appendChild(info);
                listEl.appendChild(card);
              });
              listEl.dataset.loaded = '1';
            }
          }catch(e){
            loadingEl.textContent = '読み込みに失敗しました。';
          }
        });

        tripListEl.appendChild(wrap);
      }
    }

    // 既存の一覧カード見た目に寄せて小さめカードを生成
    function renderCatchMiniCardsForTrip(tripId, catchesRows){
      const headers = catchesRows[0];
      const cidx = {
        tripId: hIdx(headers,'tripId'),
        ts:     hIdx(headers,'timestamp'),
        sp:     hIdx(headers,'species'),
        size:   hIdx(headers,'size_cm'),
        photo:  hIdx(headers,'photo_thumb_url') >=0 ? hIdx(headers,'photo_thumb_url')
              : (hIdx(headers,'photo_view_url') >=0 ? hIdx(headers,'photo_view_url') : hIdx(headers,'photo_file_id')),
        tideName:  hIdx(headers,'tide_name'),
        tideTrend: hIdx(headers,'tide_trend'),
        tideLevel: hIdx(headers,'tide_level_cm'),
      };

      const wrap = document.createElement('div');
      wrap.className = 'grid sm:grid-cols-2 gap-3';

      for (let i=1;i<catchesRows.length;i++){
        const r = catchesRows[i];
        if (String(r[cidx.tripId]||'') !== String(tripId)) continue;

        const card = document.createElement('div');
        card.className = 'rounded-xl bg-slate-900 border border-slate-800 p-3 flex gap-3 items-start';

        const img = document.createElement('img');
        img.className = 'w-20 h-20 object-cover rounded-lg border border-slate-800 bg-slate-950';
        img.alt = 'photo';
        img.src = resolvePhotoUrl(r[cidx.photo] || '') || '';
        card.appendChild(img);

        const info = document.createElement('div');
        info.className = 'min-w-0 flex-1';
        const titleRow = document.createElement('div');
        titleRow.className = 'flex items-center justify-between gap-2';

        const t = document.createElement('div');
        t.className = 'font-semibold truncate';
        t.textContent = r[cidx.sp] || '(魚種不明)';
        const sz = document.createElement('span');
        sz.className = 'text-sm text-slate-300';
        if (r[cidx.size] || r[cidx.size]===0) sz.textContent = `${r[cidx.size]} cm`;
        titleRow.appendChild(t); titleRow.appendChild(sz);
        info.appendChild(titleRow);

        const meta = document.createElement('div');
        meta.className = 'mt-1 text-sm text-slate-300';
        const ts = r[cidx.ts] ? new Date(r[cidx.ts]).toLocaleString() : '';
        meta.textContent = ts;
        info.appendChild(meta);

        const cond = document.createElement('div');
        cond.className = 'mt-1 flex flex-wrap items-center gap-2';
        const tn = r[cidx.tideName]; const tt = r[cidx.tideTrend]; const tl = r[cidx.tideLevel];
        if (tn){ const b=document.createElement('span'); b.className='px-2 py-0.5 rounded-full text-[11px] border border-sky-700/60 bg-sky-900/30'; b.textContent=tn; cond.appendChild(b); }
        if (tt){ const b=document.createElement('span'); b.className='px-2 py-0.5 rounded-full text-[11px] border border-emerald-700/60 bg-emerald-900/30'; b.textContent=tt; cond.appendChild(b); }
        if (tl||tl===0){ const b=document.createElement('span'); b.className='px-2 py-0.5 rounded-full text-[11px] border border-violet-700/60 bg-violet-900/30'; b.textContent=`${tl} cm`; cond.appendChild(b); }
        info.appendChild(cond);

        card.appendChild(info);
        wrap.appendChild(card);
      }
      return wrap;
    }


    // ===== アクション =====
    async function startTrip(){
      if (draft.status==='active') return;
      draft.status='active'; draft.startedAt=nowIsoLocal();

      try{
        if (navigator.geolocation){
          await new Promise(res=>{
            navigator.geolocation.getCurrentPosition(
              p => { draft.lat=p.coords.latitude; draft.lng=p.coords.longitude; res(); },
              () => res(),
              { enableHighAccuracy:true, timeout:8000 }
            );
          });
        }
        // 天気
        if (typeof draft.lat === 'number' && typeof draft.lng === 'number'){
          try { draft.start_weather = await fetchWeather(draft.lat, draft.lng); } catch(e){ console.error('[3543] fetchWeather error:', e); }
        }
        // 潮汐（開始時の概況）
        try{
          if (typeof draft.lat === 'number' && typeof draft.lng === 'number'){
            const tide = await fetchTideForStart(draft.lat, draft.lng, draft.startedAt);
            draft.start_tide = tide || null;
            if (tide?.chart && tide?.chartDateKey){
              draft.tide_daily_cache = draft.tide_daily_cache || {};
              draft.tide_daily_cache[tide.chartDateKey] = {
                harbor: tide.harbor || null,
                chart: tide.chart
              };
            }
          }
        }catch(e){ console.warn("[Tide] startTrip fetch failed:", e?.message||e); }

        // ★追加：当日の水温（開始位置に最も近い地点コードをマッチングして取得）
        try{
          if (typeof draft.lat === 'number' && typeof draft.lng === 'number'){
            if (DEBUG_WATER) LOG.wt("startTrip: fetch water temp", { lat: draft.lat, lng: draft.lng });
            draft.start_water_temp = await fetchTodayWaterTempByNearest(draft.lat, draft.lng);
            if (DEBUG_WATER) LOG.wt("startTrip: water temp result", draft.start_water_temp);
          }
        }catch(e){
          console.warn("[WaterTemp] startTrip failed:", e?.message||e);
        }

      }catch(e){
        console.warn("[startTrip] unexpected error:", e?.message || e);
      } 
      saveDraft(draft);
      render();
    }

    // ★追加：既存釣果（配列形式）をオブジェクト形式に正規化する関数
    function normalizeCatch(catchRow, colMap) {
      // 既存釣果は配列形式 [value1, value2, ...] で、colMap はカラムインデックスマップ
      // オブジェクト形式に変換して返す
      // colMap に存在しないキーは undefined を返すので、それを null に置き換える
      const getValue = (key) => {
        const idx = colMap[key];
        return (idx !== undefined && idx !== -1) ? catchRow[idx] : null;
      };
      
      return {
        id: getValue('catchId') || uuid(),
        tripId: getValue('tripId') || '',
        timestamp: getValue('timestamp') || null,
        species: getValue('species') || '',
        size_cm: getValue('size_cm') ? parseFloat(getValue('size_cm')) : null,
        weight_g: getValue('weight_g') ? parseFloat(getValue('weight_g')) : null,
        method: getValue('method') || '',
        weather: null,  // 既存釣果には weather オブジェクトはない（フラットキーのみ）
        photoFileId: getValue('photo_file_id') || null,
        photoDriveUrl: getValue('photo_view_url') || null,
        photoDriveThumbUrl: getValue('photo_thumb_url') || null,
        tide_level_cm: getValue('tide_level_cm') ? parseFloat(getValue('tide_level_cm')) : null,
        tide_trend: getValue('tide_trend') || null,
        tide_name: getValue('tide_name') || null,
        tide_harbor_name: getValue('tide_harbor_name') || null,
        tide_high_times: getValue('tide_high_times') || null,
        tide_low_times: getValue('tide_low_times') || null,
        water_temp: null,  // 既存釣果には water_temp オブジェクトはない
        water_temp_c: getValue('water_temp_c') ? parseFloat(getValue('water_temp_c')) : null,
        water_temp_point: getValue('water_temp_point') || null,
        water_temp_time: getValue('water_temp_time') || null,
        wx_temp: getValue('wx_temp') ? parseFloat(getValue('wx_temp')) : null,
        wx_wind_speed: getValue('wx_wind_speed') ? parseFloat(getValue('wx_wind_speed')) : null,
        wx_wind_deg: getValue('wx_wind_deg') ? parseFloat(getValue('wx_wind_deg')) : null,
        wx_main: getValue('wx_main') || null,
        wx_desc: getValue('wx_desc') || null
      };
    }

    function openAddCatch(){
      if (draft.status!=='active' && !manualCatchMode){ alert('まず釣行を開始してください。'); return; }
      editMode=false; editingId=null; modalTitle.textContent='釣果を追加';

      // ★変更：手動釣行中（manualStarted または manualCatchMode）なら時刻初期値は空欄
      if (draft.manualStarted || manualCatchMode) {
        catchForm={ id:uuid(), timestamp:null, species:'', size_cm:null, weight_g:null, method:'', photoPreviewUrl:undefined };
        try{ inpCatchTime.value=''; }catch{ inpCatchTime.value=''; }
      } else {
        catchForm={ id:uuid(), timestamp:nowIsoLocal(), species:'', size_cm:null, weight_g:null, method:'', photoPreviewUrl:undefined };
        try{ inpCatchTime.value = toLocalInputValue(new Date(catchForm.timestamp)); }catch{ inpCatchTime.value=''; }
      }

      inpSpecies.value=''; inpSize.value=''; inpWeight.value=''; inpMethod.value=''; inpPhoto.value='';
      imgPreview.src=''; imgPreview.classList.add('hidden');

      // ★追加：年フィールド制限ロジック（手動釣行登録と同じ）
      if (inpCatchTime) {
        if (inpCatchTime._inputHandler) {
          inpCatchTime.removeEventListener('input', inpCatchTime._inputHandler);
        }
        if (inpCatchTime._keydownHandler) {
          inpCatchTime.removeEventListener('keydown', inpCatchTime._keydownHandler);
        }
        
        inpCatchTime._keydownHandler = (evt) => {
          if (evt.key.match(/[0-9]/)) {
            const digits = inpCatchTime.value.replace(/\D/g, '');
            if (digits.length >= 4) {
              setTimeout(() => {
                const newDigits = inpCatchTime.value.replace(/\D/g, '');
                if (newDigits.length > 4) {
                  const y  = newDigits.slice(0, 4);
                  const mo = newDigits.slice(4, 6);
                  const d  = newDigits.slice(6, 8);
                  const hh = newDigits.slice(8, 10);
                  const mm = newDigits.slice(10, 12);

                  let formatted = y;
                  if (mo) formatted += '-' + mo;
                  if (d)  formatted += '-' + d;
                  if (hh) formatted += 'T' + hh;
                  if (mm) formatted += ':' + mm;

                  inpCatchTime.value = formatted;
                }
              }, 0);
            }
          }
        };

        inpCatchTime._inputHandler = () => {
          const digits = inpCatchTime.value.replace(/\D/g, '');
          
          if (!digits) {
            inpCatchTime.value = '';
            return;
          }

          const y  = digits.slice(0, 4);
          const mo = digits.slice(4, 6);
          const d  = digits.slice(6, 8);
          const hh = digits.slice(8, 10);
          const mm = digits.slice(10, 12);

          let formatted = y;
          if (mo) formatted += '-' + mo;
          if (d)  formatted += '-' + d;
          if (hh) formatted += 'T' + hh;
          if (mm) formatted += ':' + mm;

          if (formatted !== inpCatchTime.value) {
            inpCatchTime.value = formatted;
          }
        };

        inpCatchTime.addEventListener('keydown', inpCatchTime._keydownHandler);
        inpCatchTime.addEventListener('input', inpCatchTime._inputHandler);
      }

      catchModal.classList.remove('hidden');
      console.log('[openAddCatch] catchModal display state:', {
        classList: catchModal.className,
        display: window.getComputedStyle(catchModal).display,
        visibility: window.getComputedStyle(catchModal).visibility
      });
    }
    function openEditCatch(id){
      const c = draft.catches.find(x=>x.id===id); if(!c) return;
      editMode=true; editingId=id; modalTitle.textContent='釣果を編集'; catchForm={...c};
      try{ inpCatchTime.value = toLocalInputValue(new Date(catchForm.timestamp)); }catch{ inpCatchTime.value=''; }
      inpSpecies.value=catchForm.species||''; inpSize.value=(catchForm.size_cm??''); inpWeight.value=(catchForm.weight_g??''); inpMethod.value=catchForm.method||'';
      inpPhoto.value=''; if (catchForm.photoPreviewUrl){ imgPreview.src=catchForm.photoPreviewUrl; imgPreview.classList.remove('hidden'); } else { imgPreview.src=''; imgPreview.classList.add('hidden'); }

      // ★追加：年フィールド制限ロジック（編集時も適用）
      if (inpCatchTime) {
        if (inpCatchTime._inputHandler) {
          inpCatchTime.removeEventListener('input', inpCatchTime._inputHandler);
        }
        if (inpCatchTime._keydownHandler) {
          inpCatchTime.removeEventListener('keydown', inpCatchTime._keydownHandler);
        }
        
        inpCatchTime._keydownHandler = (evt) => {
          if (evt.key.match(/[0-9]/)) {
            const digits = inpCatchTime.value.replace(/\D/g, '');
            if (digits.length >= 4) {
              setTimeout(() => {
                const newDigits = inpCatchTime.value.replace(/\D/g, '');
                if (newDigits.length > 4) {
                  const y  = newDigits.slice(0, 4);
                  const mo = newDigits.slice(4, 6);
                  const d  = newDigits.slice(6, 8);
                  const hh = newDigits.slice(8, 10);
                  const mm = newDigits.slice(10, 12);

                  let formatted = y;
                  if (mo) formatted += '-' + mo;
                  if (d)  formatted += '-' + d;
                  if (hh) formatted += 'T' + hh;
                  if (mm) formatted += ':' + mm;

                  inpCatchTime.value = formatted;
                }
              }, 0);
            }
          }
        };

        inpCatchTime._inputHandler = () => {
          const digits = inpCatchTime.value.replace(/\D/g, '');
          
          if (!digits) {
            inpCatchTime.value = '';
            return;
          }

          const y  = digits.slice(0, 4);
          const mo = digits.slice(4, 6);
          const d  = digits.slice(6, 8);
          const hh = digits.slice(8, 10);
          const mm = digits.slice(10, 12);

          let formatted = y;
          if (mo) formatted += '-' + mo;
          if (d)  formatted += '-' + d;
          if (hh) formatted += 'T' + hh;
          if (mm) formatted += ':' + mm;

          if (formatted !== inpCatchTime.value) {
            inpCatchTime.value = formatted;
          }
        };

        inpCatchTime.addEventListener('keydown', inpCatchTime._keydownHandler);
        inpCatchTime.addEventListener('input', inpCatchTime._inputHandler);
      }

      catchModal.classList.remove('hidden');
    }
    function closeCatchModal(){
      console.log('[CloseCatchModal] closeCatchModal called, flag:', window._returnToTripEditAfterCatch);
      catchModal.classList.add('hidden');
      
      // ★追加：編集モーダルから釣果を追加した場合、編集モーダルに戻す
      if (window._returnToTripEditAfterCatch) {
        console.log('[CloseCatchModal] Flag is true, returning to trip edit modal');
        window._returnToTripEditAfterCatch = false;
        
        // 要素参照を取得
        const tripEditModal = document.getElementById('tripEditModal');
        const editCatchList = document.getElementById('editCatchList');
        const editCatchCount = document.getElementById('editCatchCount');
        
        console.log('[CloseCatchModal] Elements found:', {
          tripEditModal: !!tripEditModal,
          editCatchList: !!editCatchList,
          editCatchCount: !!editCatchCount
        });
        
        if (!tripEditModal || !editCatchList || !editCatchCount) {
          console.error('[CloseCatchModal] Modal elements not found');
          return;
        }

        // 釣果リストを再描画
        const ctsList = draft.catches || [];
        console.log('[CloseCatchModal] Redrawing catch list, count:', ctsList.length);
        editCatchList.innerHTML = '';
        editCatchCount.textContent = ctsList.length;

        // カラムマッピングを作成
        let catchHeadersTemp = (catchesCache || [])[0] || [];
        let colCatchTemp = {};
        for (let i = 0; i < catchHeadersTemp.length; i++) {
          colCatchTemp[String(catchHeadersTemp[i]).trim()] = i;
        }
        console.log('[CloseCatchModal] Column mapping:', colCatchTemp);

        ctsList.forEach((c, i) => {
          const catchObjTemp = {
            species: c[colCatchTemp.species] || '',
            size_cm: parseFloat(c[colCatchTemp.size_cm]) || null,
            timestamp: c[colCatchTemp.timestamp] || '',
            tide_trend: c[colCatchTemp.tide_trend] || null,
            tide_level_cm: parseFloat(c[colCatchTemp.tide_level_cm]) || null
          };

          const itemTemp = document.createElement('div');
          itemTemp.className = 'bg-slate-800 rounded-lg p-3 flex items-start justify-between';

          const contentTemp = document.createElement('div');
          contentTemp.className = 'flex-1 cursor-pointer hover:bg-slate-700/30 rounded p-1 transition';
          
          let timeStrTemp = '';
          if (catchObjTemp.timestamp) {
            const d = new Date(catchObjTemp.timestamp);
            timeStrTemp = `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}:${String(d.getSeconds()).padStart(2,'0')}`;
          }
          
          const tideInfoTemp = [];
          if (catchObjTemp.tide_trend) tideInfoTemp.push(catchObjTemp.tide_trend);
          if (catchObjTemp.tide_level_cm != null) tideInfoTemp.push(catchObjTemp.tide_level_cm + ' cm');
          const tideStrTemp = tideInfoTemp.length > 0 ? tideInfoTemp.join(' ') : '';
          
          contentTemp.innerHTML = `
            <div class="font-semibold text-slate-100 text-sm">${catchObjTemp.species || '(魚種未設定)'} ${catchObjTemp.size_cm ? catchObjTemp.size_cm + ' cm' : ''}</div>
            <div class="text-slate-400 text-xs mt-1">${timeStrTemp}</div>
            ${tideStrTemp ? `<div class="text-slate-300 text-xs mt-1">${tideStrTemp}</div>` : ''}
          `;

          const btnDeleteTemp = document.createElement('button');
          btnDeleteTemp.className = 'text-xs py-1 px-2 rounded bg-red-900 hover:bg-red-800 text-red-200 ml-2';
          btnDeleteTemp.textContent = '削除';
          btnDeleteTemp.onclick = (e) => {
            e.stopPropagation();
            if (confirm('この釣果を削除しますか？')) {
              draft.catches.splice(i, 1);
              saveDraft(draft);
              closeCatchModal(); // 再度釣果リストを描画
            }
          };

          itemTemp.appendChild(contentTemp);
          itemTemp.appendChild(btnDeleteTemp);
          editCatchList.appendChild(itemTemp);
        });

        // モーダルを表示
        console.log('[CloseCatchModal] Before showing modal - current display:', window.getComputedStyle(tripEditModal).display);
        tripEditModal.style.display = 'grid';
        tripEditModal.classList.remove('hidden');
        console.log('[CloseCatchModal] After showing modal - display:', tripEditModal.style.display, 'classes:', tripEditModal.className);
      }
    }
    
    // ★追加：キャンセルしてホームに戻る際、データをクリアする関数
    function cancelAndReturnHome(){
      // 釣果フォームをクリア
      catchForm = { id:uuid(), timestamp:null, species:'', size_cm:null, weight_g:null, method:'', photoPreviewUrl:undefined };
      editMode = false;
      editingId = null;
      
      // 入力フィールドをクリア
      inpCatchTime.value = '';
      inpSpecies.value = '';
      inpSize.value = '';
      inpWeight.value = '';
      inpMethod.value = '';
      inpPhoto.value = '';
      imgPreview.src = '';
      imgPreview.classList.add('hidden');
      
      // ★修正: 釣行ステータスで分岐
      if (draft.status === 'active') {
        // 釣行中: フォームのみクリア、draft保持 → ステータス画面に遷移
        closeCatchModal();
        render();
      } else {
        // 釣行未開始（idle）: 全データクリア → ホーム
        draft = { tripId: uuid(), status: 'idle', catches: [], tide_daily_cache: {}, start_water_temp: null, memo: null };
        manualCatchMode = false;
        saveDraft(draft);
        closeCatchModal();
        showView('home');
      }
    }

    // ★追加：釣行中にキャンセルしてホームに戻る関数
    function cancelTripAndReturnHome(){
      if (!confirm('釣行を中止してホームに戻りますか？\n※登録したデータはクリアされます。')) {
        return;
      }
      
      // ドラフトをリセット（初期状態に戻す）
      draft = { tripId: uuid(), status: 'idle', catches: [], tide_daily_cache: {}, start_water_temp: null, memo: null };
      manualCatchMode = false;
      
      saveDraft(draft);
      
      // ホームに戻る
      showView('home');
      render();
    }

    async function submitCatch(){
      try {
        const species = inpSpecies.value.trim();
        if (!species){ 
          hideUploadingOverlay();
          alert('魚種を入力してください。'); 
          return; 
        }

     // 手動釣行中も「未入力なら現在時刻で補完しない」
      const treatAsManual = manualCatchMode || !!draft.manualStarted; // ★追加
      let whenLocal = null;
      if (inpCatchTime.value) {
        whenLocal = toOffsetIsoLocal(new Date(inpCatchTime.value));
      } else if (!treatAsManual) {
        // 自動記録など“手動ではない”ときのみ現在時刻で補完
        whenLocal = nowIsoLocal();
      }
      catchForm.timestamp = whenLocal;



      catchForm.species   = species;
      catchForm.size_cm   = inpSize.value ? Number(inpSize.value) : null;
      catchForm.weight_g  = inpWeight.value ? Number(inpWeight.value) : null;
      catchForm.method    = inpMethod.value || '';

      // 天気
      let wx = null;
      if (typeof draft.lat === 'number' && typeof draft.lng === 'number'){
        try { wx = await fetchWeather(draft.lat, draft.lng); } catch(e){ console.error('[3940] fetchWeather error:', e); }
      }
      catchForm.weather = wx;

      // ★修正：潮汐ロジックは写真処理(EXIF)後に移動

      // 写真アップロード
      if (inpPhoto.files && inpPhoto.files[0]) {
        try {
          const file = inpPhoto.files[0];

          // --- EXIF 解析（先に実施してログする）---
          LOG.app("[EXIF] start parse (pre-upload)", { name: file.name, size: file.size, type: file.type });
          try {
            const exifDate = await extractExifDate(file);
            const exifGps  = await extractExifGps(file);
            LOG.app("[EXIF] raw extracted", { exifDate, exifGps });
            console.log("[EXIF] 抽出した日時と場所:", { exifDate, exifGps });

            // 時刻：フォーム未入力（catchForm.timestamp が falsy）なら EXIF から補完
            if (!catchForm.timestamp && exifDate) {
              const jstIso = exifDateToJstIso(exifDate);
              if (jstIso) {
                catchForm.timestamp = jstIso;
                whenLocal = jstIso;  // ★追加：whenLocal も更新
                LOG.app("[EXIF] timestamp set from EXIF", { exifDate, jstIso });
              } else {
                console.warn("[EXIF] jstIso conversion failed:", exifDate);
              }
            }

            // 位置：釣果個票レベルに保存（代表位置補完ロジックが拾う）
            if (exifGps && typeof exifGps.lat === 'number' && typeof exifGps.lng === 'number') {
              catchForm.exif_lat = exifGps.lat;
              catchForm.exif_lng = exifGps.lng;
              LOG.app("[EXIF] GPS set on catchForm", { lat: catchForm.exif_lat, lng: catchForm.exif_lng });

              // ★追加：手動開始中で draft の代表位置が未設定なら、EXIF座標を即反映
              if (draft.manualStarted && !(typeof draft.lat==='number' && typeof draft.lng==='number')) {
                draft.lat = exifGps.lat;
                draft.lng = exifGps.lng;
                LOG.app("[EXIF→Trip] representative position set on draft", { lat: draft.lat, lng: draft.lng });
                saveDraft(draft);
              }
            }
          } catch (ex) {
            console.warn("[EXIF] parse failed:", ex?.message || ex);
          }

          // --- ドライブへアップロード（既存）---
          const up = await uploadPhotoToDrive(file);
          catchForm.photoFileId = up.fileId || '';
          catchForm.photoDriveUrl = up.viewUrl || '';
          catchForm.photoDriveThumbUrl = up.thumbUrl || '';
          LOG.app("[PhotoUpload] done", { fileId: catchForm.photoFileId });

        } catch (e) {
          console.warn("[PhotoUpload] failed:", e?.message || e);
        }
      } else {
        // 写真なしの時の観測ログ
        LOG.app("[EXIF] skip (no photo selected). catch timestamp?", { hasTimestamp: !!catchForm.timestamp });
      }

      // ★修正後：EXIF補完後に潮汐ロジックを実行
      // --- 潮位/傾向/港名/満潮・干潮 ---
      catchForm.tide_level_cm    = null;
      catchForm.tide_trend       = null;
      catchForm.tide_name        = null;
      catchForm.tide_harbor_name = null;
      catchForm.tide_high_times  = null;
      catchForm.tide_low_times   = null;

      // ★修正：EXIFから座標が抽出されている場合は、その座標を優先的に使用
      const tideCalcLat = typeof catchForm.exif_lat === 'number' ? catchForm.exif_lat : draft.lat;
      const tideCalcLng = typeof catchForm.exif_lng === 'number' ? catchForm.exif_lng : draft.lng;
      LOG.app("[Tide] using position for calc", { tideCalcLat, tideCalcLng, hasExif: !!(catchForm.exif_lat && catchForm.exif_lng), hasDraft: !!(draft.lat && draft.lng) });

      if (whenLocal && typeof tideCalcLat === 'number' && typeof tideCalcLng === 'number'){
        const dkey = dateKeyFromIso(whenLocal);
        let dayChart = null;

        if (draft.tide_daily_cache?.[dkey]?.chart){
          const chart = draft.tide_daily_cache[dkey].chart;
          const info = tideInfoFromChart(chart, whenLocal);
          catchForm.tide_level_cm    = info.level_cm;
          catchForm.tide_trend       = info.trend_text;
          catchForm.tide_name        = draft.start_tide?.tideName || null;
          catchForm.tide_harbor_name =
            draft.tide_daily_cache[dkey]?.harbor?. hn
            ?? draft.start_tide?.harbor?.hn
            ?? null;
          dayChart = chart;

        } else {
          const startKey = draft.start_tide?.chartDateKey;
          if (startKey && startKey === dkey && draft.start_tide?.chart){
            const chart = draft.start_tide.chart;
            const info = tideInfoFromChart(chart, whenLocal);
            catchForm.tide_level_cm    = info.level_cm;
            catchForm.tide_trend       = info.trend_text;
            catchForm.tide_name        = draft.start_tide?.tideName || null;
            catchForm.tide_harbor_name = draft.start_tide?.harbor?.hn ?? null;

            draft.tide_daily_cache = draft.tide_daily_cache || {};
            draft.tide_daily_cache[dkey] = {
              harbor: draft.start_tide?.harbor || null,
              chart
            };
            dayChart = chart;

          } else {
            try{
              const pack = await getTideChartForDate(tideCalcLat, tideCalcLng, whenLocal);
              if (pack?.chart){
                draft.tide_daily_cache = draft.tide_daily_cache || {};
                draft.tide_daily_cache[dkey] = { harbor: pack.harbor || null, chart: pack.chart };
                const info = tideInfoFromChart(pack.chart, whenLocal);
                catchForm.tide_level_cm    = info.level_cm;
                catchForm.tide_trend       = info.trend_text;
                catchForm.tide_name        = pack.chart?.moon?.title || null;
                catchForm.tide_harbor_name = pack.harbor?.hn ?? draft.start_tide?.harbor?.hn ?? null;
                dayChart = pack.chart;
                LOG.app("[Tide] fetched from Tide736", { lat: tideCalcLat, lng: tideCalcLng, dkey });
              }
            }catch(ex){
              console.warn("[Tide] getTideChartForDate failed:", ex?.message || ex);
            }
          }
        }

        // 満潮/干潮（最大2つ）を dayChart から確定
        if (dayChart){
          const hl = summarizeHighLowTimesFromChart(dayChart);
          catchForm.tide_high_times = hl.high;  // 例 "04:31／16:52"
          catchForm.tide_low_times  = hl.low;   // 例 "10:12／22:27"
        }
      }

      // ★追加: Catch に水温を付与（開始時に取得済みの水温をそのまま採用）
      // 形式: { temperature_c:number|null, point_name:string|null, date:string|null } または null
      catchForm.water_temp = draft.start_water_temp || null;

      // ★追加: 手動入力からの保存時に“釣行中”へ自動遷移 & 開始時刻補完
     // ★変更: 手動入力の保存時は start 時刻をここでは入れない（後で補完ロジックに任せる）
      if (draft.status !== 'active') {
        draft.status = 'active';
        // draft.startedAt は空のまま維持（null/undefined）
        draft.manualStarted = true;  // 手動開始フラグのみ設定
      }

      LOG.app("Catch (to be saved & uploaded)", {
        id: catchForm.id,
        timestamp: catchForm.timestamp,
        species: catchForm.species,
        size_cm: catchForm.size_cm,
        tide_cm: catchForm.tide_level_cm,
        trend: catchForm.tide_trend,
        tide_name: catchForm.tide_name,
        harbor: catchForm.tide_harbor_name,
        tide_high_times: catchForm.tide_high_times,
        tide_low_times: catchForm.tide_low_times,
        photoFileId: catchForm.photoFileId,
      });

      if (editMode && editingId) {
        const i = draft.catches.findIndex(x => x.id === editingId);
        if (i >= 0) { draft.catches[i] = { ...catchForm, id: editingId }; }
      } else {
        draft.catches.push({ ...catchForm });
      }
      saveDraft(draft);
      closeCatchModal();

      // ★修正①: 手動釣行時に登録釣果から開始/終了時刻を算出（render前に実行）
      if (manualCatchMode || !!draft.manualStarted) {
        const validTimes = draft.catches
          .map(c => c.timestamp)
          .filter(ts => !!ts);
        
        if (validTimes.length > 0) {
          // ★釣果がある場合：釣果タイムスタンプから時刻を設定
          const earliestTime = validTimes.reduce((a, b) => a < b ? a : b);
          const latestTime = validTimes.reduce((a, b) => a > b ? a : b);
          
          draft.startedAt = earliestTime;
          draft.endedAt = latestTime;
          saveDraft(draft);
          console.log('[submitCatch] Auto-calculated times from catches:', { startedAt: draft.startedAt, endedAt: draft.endedAt });
        }
        // ★釣果がない場合は何もしない（既存の draft.startedAt/endedAt を保持）
      }

      render();

      if (!editMode){
        // ★変更：手動釣行中は timestamp を null（時刻入力は空欄のまま）
        if (manualCatchMode || !!draft.manualStarted) {
          catchForm = { id: uuid(), timestamp: null, species:'', size_cm:null, weight_g:null, method:'', photoPreviewUrl: undefined };
        } else {
          catchForm = { id: uuid(), timestamp: nowIsoLocal(), species:'', size_cm:null, weight_g:null, method:'', photoPreviewUrl: undefined };
        }
      }

      // ★変更：手動モード時はモーダル表示なしで補完ロジックのみを実行
      if (manualCatchMode || !!draft.manualStarted) {
        // ★修正：手動釣行モード時は補完完了後にオーバーレイを消す（アップロード確認は表示しない）
        await _complementTripDataOnly();   // ← ステータス画面更新のみ、モーダル表示なし
        hideUploadingOverlay();
      } else if (!editMode) {
        // ★修正：通常の釣果登録時はモーダル表示後にオーバーレイを消す
        openUploadReview();
        hideUploadingOverlay();
      } else {
        // ★修正：編集モード時は即座にオーバーレイを消す
        hideUploadingOverlay();
      }
      } catch (e) {
        // ★追加：エラー時もオーバーレイを消す
        hideUploadingOverlay();
        console.error('[submitCatch] error:', e);
      }
    }

    // ★追加: JPEG EXIF から DateTimeOriginal を読み出す（"YYYY:MM:DD HH:mm:ss" を返す）
    async function extractExifDate(file) {
      return new Promise((resolve, reject) => {
        try {
          const reader = new FileReader();
          reader.onload = function(e) {
            try {
              const view = new DataView(e.target.result);
              // ---- JPEG APP1 (EXIF) を探索 ----
              let offset = 2; // SOI(0xFFD8)後から
              while (offset < view.byteLength) {
                if (view.getUint16(offset) === 0xFFE1) { // APP1
                  // APP1 長さ
                  const len = view.getUint16(offset + 2);
                  // "Exif\0\0" チェック
                  const exifHeader = offset + 4;
                  if (
                    view.getUint8(exifHeader) === 0x45 && // E
                    view.getUint8(exifHeader + 1) === 0x78 && // x
                    view.getUint8(exifHeader + 2) === 0x69 && // i
                    view.getUint8(exifHeader + 3) === 0x66 && // f
                    view.getUint8(exifHeader + 4) === 0x00 &&
                    view.getUint8(exifHeader + 5) === 0x00
                  ) {
                    const tiff = exifHeader + 6;
                    const little = view.getUint16(tiff) === 0x4949; // "II" or "MM"
                    const get16 = (p)=> view.getUint16(p, little);
                    const get32 = (p)=> view.getUint32(p, little);

                    // 0th IFD
                    const ifd0 = tiff + get32(tiff + 4);
                    const entries0 = get16(ifd0);
                    let exifIFDOffset = 0;

                    // 0th IFD の中から ExifIFDPointer (0x8769) を探す
                    for (let i=0; i<entries0; i++) {
                      const ent = ifd0 + 2 + 12 * i;
                      const tag = get16(ent);
                      if (tag === 0x8769) { // ExifIFDPointer
                        exifIFDOffset = get32(ent + 8);
                        break;
                      }
                    }
                    if (exifIFDOffset) {
                      const exifIFD = tiff + exifIFDOffset;
                      const exifEntries = get16(exifIFD);
                      for (let i=0; i<exifEntries; i++) {
                        const ent = exifIFD + 2 + 12 * i;
                        const tag = get16(ent);
                        if (tag === 0x9003) { // DateTimeOriginal
                          const type = get16(ent + 2);   // ASCII=2
                          const count = get32(ent + 4);  // 通常 20 程度
                          const valOff = get32(ent + 8);
                          const strOff = tiff + valOff;
                          let s = "";
                          for (let j=0; j<count && (strOff + j) < view.byteLength; j++) {
                            const code = view.getUint8(strOff + j);
                            if (code === 0) break;
                            s += String.fromCharCode(code);
                          }
                          resolve(s.trim() || null);
                          return;
                        }
                      }
                    }
                  }
                  offset += 2 + len;
                } else if (view.getUint16(offset) === 0xFFD9) { // EOI
                  break;
                } else {
                  offset += 2 + view.getUint16(offset + 2);
                }
              }
              resolve(null);
            } catch (err) { reject(err); }
          };
          reader.onerror = () => reject(reader.error);
          // 先頭 256KB までを読めば EXIF は十分
          reader.readAsArrayBuffer(file.slice(0, 262144));
        } catch (err) { reject(err); }
      });
    }

    // ★追加: JPEG EXIF から GPS 緯度経度を読み出す（{lat, lng} を返す / なければ null）
    async function extractExifGps(file) {
      return new Promise((resolve, reject) => {
        try {
          const reader = new FileReader();
          reader.onload = function(e) {
            try {
              const view = new DataView(e.target.result);

              let offset = 2;
              while (offset < view.byteLength) {
                if (view.getUint16(offset) === 0xFFE1) { // APP1 EXIF
                  const len = view.getUint16(offset + 2);
                  const exifHeader = offset + 4;
                  const isExif =
                    view.getUint8(exifHeader) === 0x45 &&
                    view.getUint8(exifHeader + 1) === 0x78 &&
                    view.getUint8(exifHeader + 2) === 0x69 &&
                    view.getUint8(exifHeader + 3) === 0x66 &&
                    view.getUint8(exifHeader + 4) === 0x00 &&
                    view.getUint8(exifHeader + 5) === 0x00;

                  if (isExif) {
                    const tiff = exifHeader + 6;
                    const little = view.getUint16(tiff) === 0x4949;
                    const get16 = (p)=> view.getUint16(p, little);
                    const get32 = (p)=> view.getUint32(p, little);

                    // 0th IFD
                    const ifd0 = tiff + get32(tiff + 4);
                    const entries0 = get16(ifd0);
                    let gpsIFDOffset = 0;

                    // 0th IFD 内の GPSIFDPointer (0x8825) を探す
                    for (let i=0; i<entries0; i++) {
                      const ent = ifd0 + 2 + 12 * i;
                      const tag = get16(ent);
                      if (tag === 0x8825) {
                        gpsIFDOffset = get32(ent + 8);
                        break;
                      }
                    }
                    if (!gpsIFDOffset) { resolve(null); return; }

                    // GPS IFD
                    const gpsIFD = tiff + gpsIFDOffset;
                    const gpsEntries = get16(gpsIFD);

                    let latRef = null, lngRef = null;
                    let latArr = null, lngArr = null;

                    const readRational = (base, count=1) => {
                      // numerator/denominator の配列を返す
                      const arr = [];
                      for (let i=0; i<count; i++) {
                        const num = get32(base + i*8);
                        const den = get32(base + i*8 + 4);
                        arr.push({num, den});
                      }
                      return arr;
                    };

                    for (let i=0; i<gpsEntries; i++) {
                      const ent = gpsIFD + 2 + 12 * i;
                      const tag = get16(ent);
                      const type = get16(ent + 2);
                      const count = get32(ent + 4);
                      const valOff = get32(ent + 8);

                      // ASCII=2, RATIONAL=5
                      if (tag === 0x0001 && type === 2) { // LatitudeRef: "N" / "S"
                        const off = (count <= 4) ? (ent + 8) : (tiff + valOff);
                        latRef = String.fromCharCode(view.getUint8(off)).toUpperCase();
                      }
                      if (tag === 0x0003 && type === 2) { // LongitudeRef: "E" / "W"
                        const off = (count <= 4) ? (ent + 8) : (tiff + valOff);
                        lngRef = String.fromCharCode(view.getUint8(off)).toUpperCase();
                      }
                      if (tag === 0x0002 && type === 5) { // Latitude: 3 rationals
                        const off = tiff + valOff;
                        latArr = readRational(off, 3);
                      }
                      if (tag === 0x0004 && type === 5) { // Longitude: 3 rationals
                        const off = tiff + valOff;
                        lngArr = readRational(off, 3);
                      }
                    }

                    // 変換：度分秒 → 10 進
                    const toDeg = (arr, ref) => {
                      if (!arr || arr.length < 3) return null;
                      const d = arr[0].den ? arr[0].num / arr[0].den : 0;
                      const m = arr[1].den ? arr[1].num / arr[1].den : 0;
                      const s = arr[2].den ? arr[2].num / arr[2].den : 0;
                      let v = d + (m / 60) + (s / 3600);
                      if (ref === 'S' || ref === 'W') v = -v;
                      return isFinite(v) ? v : null;
                    };

                    const lat = toDeg(latArr, latRef);
                    const lng = toDeg(lngArr, lngRef);

                    resolve((typeof lat === 'number' && typeof lng === 'number') ? {lat, lng} : null);
                    return;
                  }

                  offset += 2 + len;
                } else if (view.getUint16(offset) === 0xFFD9) { // EOI
                  break;
                } else {
                  offset += 2 + view.getUint16(offset + 2);
                }
              }
              resolve(null);
            } catch (err) { reject(err); }
          };
          reader.onerror = () => reject(reader.error);
          reader.readAsArrayBuffer(file.slice(0, 262144));
        } catch (err) { reject(err); }
      });
    }

    // ===== アップロード確認モーダル =====
    const uploadReviewModal = document.getElementById('uploadReviewModal');
    const uploadReviewBody  = document.getElementById('uploadReviewBody');
    const btnCloseUploadReview = document.getElementById('btnCloseUploadReview');
    const btnCancelUpload = document.getElementById('btnCancelUpload');
    const btnConfirmUpload = document.getElementById('btnConfirmUpload');
    
    // ★追加: 釣行編集モーダル要素
    const tripEditModal = document.getElementById('tripEditModal');
    const btnCloseTripEdit = document.getElementById('btnCloseTripEdit');
    const btnCancelTripEdit = document.getElementById('btnCancelTripEdit');
    const btnSaveTripEdit = document.getElementById('btnSaveTripEdit');
    const btnAddCatchInEdit = document.getElementById('btnAddCatchInEdit');
    const btnRefetchCompData = document.getElementById('btnRefetchCompData');
    const editTripStarted = document.getElementById('editTripStarted');
    const editTripEnded = document.getElementById('editTripEnded');
    const editTripLat = document.getElementById('editTripLat');
    const editTripLng = document.getElementById('editTripLng');
    const editTripWeather = document.getElementById('editTripWeather');
    const editTripTide = document.getElementById('editTripTide');
    const editTripWaterTemp = document.getElementById('editTripWaterTemp');
    const editCatchList = document.getElementById('editCatchList');
    const editCatchCount = document.getElementById('editCatchCount');
    
    // ★追加: 手動釣行モーダル要素
    const tripModal   = document.getElementById('tripModal');
    const inpTripStart= document.getElementById('inpTripStart');
    const inpTripLat  = document.getElementById('inpTripLat');
    const inpTripLng  = document.getElementById('inpTripLng');
    const btnCloseTripModal = document.getElementById('btnCloseTripModal');
    const btnCancelTripModal = document.getElementById('btnCancelTripModal');
    const btnSaveTrip   = document.getElementById('btnSaveTrip');

    // ★修正：釣行モーダルのキャンセルボタン
    if (btnCloseTripModal) btnCloseTripModal.onclick = ()=> {
      // ★修正: 釣行ステータスで分岐
      if (draft.status === 'active') {
        // 釣行中: 入力フィールドのみクリア → ステータス画面
        inpTripStart.value = '';
        inpTripLat.value = '';
        inpTripLng.value = '';
        tripModal && tripModal.classList.add('hidden');
        render();
      } else {
        // 釣行未開始（idle）: 入力フィールド＋全データクリア → ホーム
        inpTripStart.value = '';
        inpTripLat.value = '';
        inpTripLng.value = '';
        draft = { tripId: uuid(), status: 'idle', catches: [], tide_daily_cache: {}, start_water_temp: null, memo: null };
        manualCatchMode = false;
        saveDraft(draft);
        tripModal && tripModal.classList.add('hidden');
        showView('home');
      }
    };
    
    // ★追加：釣行モーダルのキャンセルボタン（モーダル下部）
    if (btnCancelTripModal) btnCancelTripModal.onclick = ()=> {
      // ★修正: 釣行ステータスで分岐（×ボタンと同じ動作）
      if (draft.status === 'active') {
        // 釣行中: 入力フィールドのみクリア → ステータス画面
        inpTripStart.value = '';
        inpTripLat.value = '';
        inpTripLng.value = '';
        tripModal && tripModal.classList.add('hidden');
        render();
      } else {
        // 釣行未開始（idle）: 入力フィールド＋全データクリア → ホーム
        inpTripStart.value = '';
        inpTripLat.value = '';
        inpTripLng.value = '';
        draft = { tripId: uuid(), status: 'idle', catches: [], tide_daily_cache: {}, start_water_temp: null, memo: null };
        manualCatchMode = false;
        saveDraft(draft);
        tripModal && tripModal.classList.add('hidden');
        showView('home');
      }
    };
    
    // ★追加：recordView 下部バーのキャンセルボタン（釣行中のキャンセル）
    const btnCancelTrip = document.getElementById('btnCancelTrip');
    if (btnCancelTrip) {
      btnCancelTrip.onclick = cancelTripAndReturnHome;
    };
    
    if (btnSaveTrip)   btnSaveTrip.onclick   = submitManualTrip;

    btnCloseUploadReview.onclick = () => { pendingEnd=null; uploadReviewModal.classList.add('hidden'); };
    btnCancelUpload.onclick      = () => { 
      isUploading = false;
      pendingEnd=null; 
      uploadReviewModal.classList.add('hidden'); 
    };

    btnConfirmUpload.onclick = async ()=>{
      // ★追加：多重アップロード防止
      if (isUploading) return;
      
      // ★修正：共通関数でローディングオーバーレイを表示（アップロード中テキスト）
      showUploadingOverlay('アップロード中...');

      const enqueue = (payload) => {
        try{
          const key='fishlog_upload_queue_v1';
          const q = JSON.parse(localStorage.getItem(key) || '[]');
          q.push({ t: Date.now(), payload });
          localStorage.setItem(key, JSON.stringify(q));
          console.log('[Upload] Queued locally (localStorage fallback)');
        }catch(e){
          console.warn('[Upload] Local queue failed:', e.message);
        }
      };
      const clearDraftAndUI = ()=>{
        // ★修正：共通関数でオーバーレイを消す
        hideUploadingOverlay();
        uploadReviewModal.classList.add('hidden');
        pendingEnd = null;
        draft = { tripId: uuid(), status: 'idle', catches: [], tide_daily_cache: {}, start_water_temp: null, memo: null };
        saveDraft(draft);

        // ★追加：手動モード解除
        manualCatchMode = false;

        render();
        showView('home');
        alert('アップロードが完了しました。');
      };

      try{
        if (pendingEnd){
          draft.status = 'ended';
          draft.endedAt = pendingEnd.endedAt;
          draft.end_weather = pendingEnd.end_weather || null;
          saveDraft(draft);
        }
        
        // ★追加：メモをdraftに保存（アップロード直前）
        const tripMemoInput = document.getElementById('tripMemoInput');
        if (tripMemoInput) {
          draft.memo = tripMemoInput.value.trim() || null;
          saveDraft(draft);
        }
        
        const payload = buildTripPayload(draft);

        // デバッグプレビュー（既存）
        try {
          const preview = (payload.catches || []).map(c => ({
            id: c.id, ts: c.timestamp, sp: c.species, size: c.size_cm,
            tide_cm: c.tide_level_cm, trend: c.tide_trend, tide_name: c.tide_name,
            harbor: c.tide_harbor_name, tide_high_times: c.tide_high_times, tide_low_times: c.tide_low_times, photoId: c.photoFileId
          }));
          LOG.app("Upload payload (Catches preview)", preview);
          if (console?.table) console.table(preview);
        } catch(_){}

        const res = await fetch(CONFIG.API.FISHING_TRIP_API_WORKER + '/api/upload', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-Auth-Token': CONFIG.API.WORKERS_AUTH_TOKEN },
          body: JSON.stringify(payload)
        });
        const text = await res.text();
        if (!res.ok) throw new Error(`HTTP ${res.status}: ${text.slice(0,200)}`);

        // 成功
        clearDraftAndUI();

      }catch(e){
        // 失敗 → キュー保存
        try{
          const payload = buildTripPayload(draft);
          enqueue(payload);
          clearDraftAndUI();
          alert('オフライン/エラーのため送信待ちキューに保存しました。オンライン復帰後に自動再送します。');
        }catch{
          isUploading = false;
          uploadingOverlay.classList.add('hidden');
          alert('アップロードに失敗しました。ネットワーク/エンドポイントを確認してください。');
        }
      }
    };

    function buildTripPayload(d, action = 'create'){
      // ★修正：species が空の釣果（未入力）はフィルタリング
      const validCatches = (d.catches||[]).filter(c => c.species && String(c.species).trim());
      
      return {
        action: action,  // ★追加：アクション（'create' または 'update'）
        tripId: d.tripId,
        status: d.status,
        startedAt: d.startedAt,
        endedAt: d.endedAt,
        position: (typeof d.lat==='number' && typeof d.lng==='number') ? {lat:d.lat, lng:d.lng} : null,
        start_weather: d.start_weather || null,
        end_weather: d.end_weather || null,
        start_tide: d.start_tide || null,
        water_temp_c: d.start_water_temp?.temperature_c ?? null,
        water_temp_point: d.start_water_temp?.point_name ?? null,
        water_temp_time: d.start_water_temp?.date ?? null,
        memo: d.memo || null,  // ★追加：メモ
        catches: validCatches.map(c => {
          // ★補完：既存釣果から不足フィールドを補完
          const sw = c.weather || d.start_weather || {};
          const tide = c.tide_name && c.tide_harbor_name ? {
            tide_name: c.tide_name,
            tide_harbor_name: c.tide_harbor_name,
            tide_high_times: c.tide_high_times,
            tide_low_times: c.tide_low_times
          } : null;
          
          return {
            id: c.id || uuid(),  // ★追加：id が無い場合は生成
            timestamp: c.timestamp,
            species: c.species,
            size_cm: c.size_cm,
            weight_g: c.weight_g,
            method: c.method,
            
            // ★追加：天気情報（釣行の開始天気から補完）
            wx_temp: (c.wx_temp !== undefined && c.wx_temp !== null) ? c.wx_temp : (sw.temp ?? null),
            wx_wind_speed: (c.wx_wind_speed !== undefined && c.wx_wind_speed !== null) ? c.wx_wind_speed : (sw.wind_speed ?? null),
            wx_wind_deg: (c.wx_wind_deg !== undefined && c.wx_wind_deg !== null) ? c.wx_wind_deg : (sw.wind_deg ?? null),
            wx_main: c.wx_main || (sw.weather_main ?? null),
            wx_desc: c.wx_desc || (sw.weather_description ?? null),
            
            // ★追加：潮汐情報
            tide_level_cm: c.tide_level_cm ?? null,
            tide_trend: c.tide_trend ?? null,
            tide_name: c.tide_name ?? (d.start_tide?.tideName ?? null),
            tide_harbor_name: c.tide_harbor_name ?? (d.start_tide?.harbor?.hn ?? null),
            tide_high_times: c.tide_high_times ?? (d.start_tide?.high_times ?? null),
            tide_low_times: c.tide_low_times ?? (d.start_tide?.low_times ?? null),
            
            // ★追加：水温情報
            water_temp_c: (c.water_temp_c !== undefined && c.water_temp_c !== null) ? c.water_temp_c : (d.start_water_temp?.temperature_c ?? null),
            water_temp_point: c.water_temp_point || (d.start_water_temp?.point_name ?? null),
            water_temp_time: c.water_temp_time || (d.start_water_temp?.date ?? null),
            
            // 写真情報
            photoFileId: c.photoFileId || null,
            photoDriveUrl: c.photoDriveUrl || null,
            photoDriveThumbUrl: c.photoDriveThumbUrl || null,
            
            // 後方互換キー
            weather: c.weather || null,
            water_temp: c.water_temp ?? null
          };
        }),
        
        // ★追加：潮汐チャート画像情報
        tide_chart_images: d.tide_chart_images || []
      };
    }

    // 終了前レビュー
    function openUploadReview(){
      const cts = draft.catches||[];
      const sum = document.createElement('div');
      sum.className = 'space-y-3';

        // ★確認用ログ
      LOG.app("[UploadReview] snapshot", {
        hasStartWeather: !!draft.start_weather,
        hasStartTide: !!draft.start_tide,
        startedAt: draft.startedAt || null,
        lat: draft.lat, lng: draft.lng
      });

      const endAtDisplay = pendingEnd?.endedAt ? new Date(pendingEnd.endedAt).toLocaleString() : (draft.endedAt ? new Date(draft.endedAt).toLocaleString() : '—');
      const head = document.createElement('div');
      head.innerHTML =
        `<div class="text-slate-300">Trip ID: <span class="text-slate-100">${draft.tripId.slice(0,8)}</span></div>
        <div class="text-slate-300">開始: <span class="text-slate-100">${draft.startedAt?new Date(draft.startedAt).toLocaleString():'—'}</span></div>
        <div class="text-slate-300">終了: <span class="text-slate-100">${endAtDisplay}</span></div>
        <div class="text-slate-300">件数: <span class="text-slate-100">${cts.length}</span></div>`;
      sum.appendChild(head);

      const wx = document.createElement('div');
      wx.className='grid grid-cols-1 sm:grid-cols-2 gap-2';
      const boxWx = (label, val) => {
        const d=document.createElement('div'); d.className='rounded-xl bg-slate-800/40 p-3';
        d.innerHTML = `<div class="text-xs text-slate-400">${label}</div>
                      <div class="text-sm text-slate-200 mt-0.5">${val||'—'}</div>`;
        return d;
      };
      const sw = draft.start_weather ? formatWeatherBrief(draft.start_weather) : null;
      const ew = pendingEnd?.end_weather || draft.end_weather ? formatWeatherBrief(pendingEnd?.end_weather || draft.end_weather) : null;
      const st = draft.start_tide ? `${draft.start_tide.tideName} / ${draft.start_tide.trendText}` : null;
      const wt = draft.start_water_temp && draft.start_water_temp.temperature_c!=null
        ? `${draft.start_water_temp.temperature_c}℃${draft.start_water_temp.point_name?`（${draft.start_water_temp.point_name}）`:''}`
        : null;

      wx.appendChild(boxWx('開始時の天気', sw));
      wx.appendChild(boxWx('終了時の天気', ew));
      wx.appendChild(boxWx('開始時の潮', st));
      wx.appendChild(boxWx('当日の水温', wt));
      sum.appendChild(wx);

      if (draft.start_tide?.chart){
        const tideWrap = document.createElement('div');
        tideWrap.className = 'rounded-2xl border border-slate-800 bg-slate-900 p-3';
        const harborName = draft.start_tide?.harbor?.hn || '';
        const dateKey    = draft.start_tide?.chartDateKey || '';
        const title = document.createElement('div');
        title.className = 'text-sm text-slate-300 mb-2';
        title.textContent = `開始日の潮汐グラフ ${harborName ? `（${harborName}）` : ''} ${dateKey ? `- ${dateKey}`:''}`;
        tideWrap.appendChild(title);
        const canvas = document.createElement('canvas');
        canvas.className = 'w-full h-[260px] bg-slate-950 rounded-lg';
        tideWrap.appendChild(canvas);
        sum.appendChild(tideWrap);
        setTimeout(()=> drawTideChartOnCanvas(canvas, draft.start_tide.chart), 0);
      }

      const list = document.createElement('div');
      list.className='divide-y divide-slate-800 rounded-xl border border-slate-800';
      cts.forEach((c, idx)=>{
        const row=document.createElement('div'); row.className='p-3 text-sm';
        const t   = c.timestamp? new Date(c.timestamp).toLocaleString(): '';
        const wxs = c.weather? formatWeatherBrief(c.weather): '';
        row.innerHTML =
          `<div class="font-semibold text-slate-100">${c.species||'(魚種未設定)'} <span class="text-slate-400 text-xs ml-2">${t}</span></div>
          <div class="text-slate-300 mt-1">${[c.size_cm!=null?`サイズ:${c.size_cm}cm`:null, c.weight_g!=null?`重量:${c.weight_g}g`:null, c.method||null].filter(Boolean).join(' / ')}</div>
          <div class="text-slate-400 text-xs mt-1">${wxs}</div>`;
      list.appendChild(row);
      });
      sum.appendChild(list);

      uploadReviewBody.innerHTML=''; uploadReviewBody.appendChild(sum);
      
      // ★追加：メモ入力欄を初期化（既存データがあれば表示）
      const tripMemoInput = document.getElementById('tripMemoInput');
      if (tripMemoInput) {
        tripMemoInput.value = draft.memo || '';
      }
      
      uploadReviewModal.classList.remove('hidden');
    }

    // ★追加: 不足情報の保管（最小実装）
    //  - 位置情報: EXIFのある釣果から初回の緯度経度を採用
    //  - （天候/潮汐/水温は既存ロジック準拠。必要に応じて拡張予定）
    function completeMissingTripInfoIfNeeded() {
      try {
        const needPos = !(typeof draft.lat === 'number' && typeof draft.lng === 'number');
        if (needPos && Array.isArray(draft.catches)) {
          const base = draft.catches.find(c =>
            typeof c.exif_lat === 'number' && typeof c.exif_lng === 'number'
          );
          if (base) {
            draft.lat = base.exif_lat;
            draft.lng = base.exif_lng;
            LOG.app("[Complete] 位置情報をEXIFから補完:", { lat: draft.lat, lng: draft.lng });
          }
        }
      } finally {
        saveDraft(draft);
      }
    }

    // ★新規追加: 補完ロジックのみを実行（モーダル表示なし）
    // submitCatch() から呼び出され、ステータス画面の更新のみを行う
    async function _complementTripDataOnly(){
      try {
        completeMissingTripInfoIfNeeded();

        LOG.app("[TripData] calling complementTripFromCatches(force=true)");
        await complementTripFromCatches(true);

        // ★追加：手動釣果モード時、全ての釣果に対して潮汐情報を補完
        if ((manualCatchMode || draft.manualStarted) && Array.isArray(draft.catches)) {
          LOG.app("[TripData] 補完未済の釣果に対して潮汐情報を補完開始", {
            catches: draft.catches.length,
            hasPos: (typeof draft.lat === 'number' && typeof draft.lng === 'number')
          });
          
          for (let i = 0; i < draft.catches.length; i++) {
            const catch_rec = draft.catches[i];
            
            // 既に潮汐情報がある場合はスキップ
            if (catch_rec.tide_level_cm != null && catch_rec.tide_trend != null) {
              LOG.app("[TripData] 釣果[" + i + "]は既に潮汐情報あり、スキップ");
              continue;
            }
            
            // 潮汐計算に必要な情報を確認
            if (!catch_rec.timestamp) {
              LOG.app("[TripData] 釣果[" + i + "]はタイムスタンプなし、スキップ");
              continue;
            }
            
            // 位置情報：EXIF優先、なければ代表位置
            let calc_lat = null, calc_lng = null;
            if (typeof catch_rec.exif_lat === 'number' && typeof catch_rec.exif_lng === 'number') {
              calc_lat = catch_rec.exif_lat;
              calc_lng = catch_rec.exif_lng;
            } else if (typeof draft.lat === 'number' && typeof draft.lng === 'number') {
              calc_lat = draft.lat;
              calc_lng = draft.lng;
            }
            
            if (calc_lat == null || calc_lng == null) {
              LOG.app("[TripData] 釣果[" + i + "]は位置情報なし、スキップ");
              continue;
            }
            
            // 潮汐データ取得
            try {
              const dkey = dateKeyFromIso(catch_rec.timestamp);
              let chart_data = null;
              
              // キャッシュを確認
              if (draft.tide_daily_cache?.[dkey]?.chart) {
                chart_data = draft.tide_daily_cache[dkey].chart;
                LOG.app("[TripData] 釣果[" + i + "]は潮汐キャッシュから取得");
              } else {
                // Tide736から取得
                const pack = await getTideChartForDate(calc_lat, calc_lng, catch_rec.timestamp);
                if (pack?.chart) {
                  chart_data = pack.chart;
                  draft.tide_daily_cache = draft.tide_daily_cache || {};
                  draft.tide_daily_cache[dkey] = { harbor: pack.harbor || null, chart: pack.chart };
                  LOG.app("[TripData] 釣果[" + i + "]は Tide736 から新規取得", { lat: calc_lat, lng: calc_lng });
                }
              }
              
              if (chart_data) {
                const info = tideInfoFromChart(chart_data, catch_rec.timestamp);
                catch_rec.tide_level_cm    = info.level_cm;
                catch_rec.tide_trend       = info.trend_text;
                catch_rec.tide_name        = chart_data?.moon?.title || null;
                
                // 港名を補完
                if (!catch_rec.tide_harbor_name) {
                  catch_rec.tide_harbor_name = 
                    draft.tide_daily_cache?.[dkey]?.harbor?.hn 
                    ?? draft.start_tide?.harbor?.hn 
                    ?? null;
                }
                
                // 満潮/干潮タイムス
                const hl = summarizeHighLowTimesFromChart(chart_data);
                catch_rec.tide_high_times = hl.high;
                catch_rec.tide_low_times  = hl.low;
                
                LOG.app("[TripData] 釣果[" + i + "]に潮汐情報を補完", {
                  tide_level_cm: catch_rec.tide_level_cm,
                  tide_trend: catch_rec.tide_trend,
                  harbor: catch_rec.tide_harbor_name
                });
              }
            } catch (ex) {
              console.warn("[TripData] 釣果[" + i + "]の潮汐補完失敗:", ex?.message || ex);
            }
          }
          
          saveDraft(draft);
          LOG.app("[TripData] 全釣果の潮汐補完完了");
        }

        LOG.app("[TripData] complementTripFromCatches completed", {
          startedAt: draft.startedAt || null,
          endedAt: draft.endedAt || null,
          lat: draft.lat, lng: draft.lng,
          hasStartTide: !!draft.start_tide
        });
      } catch(e) {
        console.warn("[TripData] complement failed:", e?.message || e);
      }

      // ★修正②: 釣行終了ボタン押下時、釣果がある場合のみ時刻を再計算
      // ★重要: render() の BEFORE に実行し、正確な時刻を draft に設定してから画面を描画
      if (draft.manualStarted) {
        const validTimes = draft.catches && Array.isArray(draft.catches)
          ? draft.catches.map(c => c.timestamp).filter(ts => !!ts)
          : [];
        
        if (validTimes.length > 0) {
          // ★釣果がある場合のみ、時刻を再計算・上書き
          const earliestTime = validTimes.reduce((a, b) => a < b ? a : b);
          const latestTime = validTimes.reduce((a, b) => a > b ? a : b);
          draft.startedAt = earliestTime;
          draft.endedAt = latestTime;
          console.log('[TripData] Auto-calculated from catches:', { startedAt: draft.startedAt, endedAt: draft.endedAt });
        }
        // ★釣果がない場合は、既に設定されている draft.startedAt/endedAt をそのまま保持
        saveDraft(draft);
      }

      // ★新規追加: 補完完了後、全ての情報が揃ってからステータス画面を再描画
      render();
    }

    async function openTripReview(){
      // ★追加：多重呼び出し防止
      if (isUploading) {
        alert('処理は既に進行中です。しばらくお待ちください。');
        return;
      }
      
      // ★修正：共通関数でローディングオーバーレイを表示（メッセージ指定）
      showUploadingOverlay('データを準備中...');

      // ★ログ追加：openTripReview の呼び出しを記録
      LOG.app("[TripReview] openTripReview called", {
        manualCatchMode,
        manualStarted: !!draft.manualStarted,
        status: draft.status,
        catches: Array.isArray(draft.catches) ? draft.catches.length : 0,
        startedAt: draft.startedAt || null,
        endedAt: draft.endedAt || null
      });

      // ★修正: 補完ロジックを _complementTripDataOnly() に統合
      await _complementTripDataOnly();

      // ★修正：手動釣行でも終了天気を取得してアップロード確認へ
      if (draft.manualStarted) {
        let endWx = null;
        if (typeof draft.lat === 'number' && typeof draft.lng === 'number'){
          try { endWx = await fetchWeather(draft.lat, draft.lng, draft.endedAt); } catch(e){ console.error('[4747] fetchWeather error:', e); }
        }
        draft.end_weather = endWx || null;
        
        // ★追加：潮汐チャート画像を取得・アップロード
        console.log('[openTripReview] Fetching tide images for manual trip');
        try {
          const tideResult = await fetchAndUploadTideImages(draft.startedAt, draft.endedAt);
          console.log('[openTripReview] Tide image fetch completed:', tideResult);
          if (tideResult.ok && tideResult.images.length > 0) {
            draft.tide_chart_images = tideResult.images;
            console.log('[openTripReview] Stored', tideResult.images.length, 'tide chart images');
          }
        } catch (err) {
          console.warn('[openTripReview] Tide image fetch error:', err);
        }
        
        saveDraft(draft);

        // ★修正③: openUploadReview()呼び出し前に登録釣果のデータで画面を更新
        // モーダルが既に表示中でも、最新の登録釣果データで内容を上書き更新
        const cts_manual = draft.catches||[];
        const sum_manual = document.createElement('div');
        sum_manual.className = 'space-y-3';

        const endAtDisplay_manual = draft.endedAt ? new Date(draft.endedAt).toLocaleString() : '—';
        const head_manual = document.createElement('div');
        head_manual.innerHTML =
          `<div class="text-slate-300">Trip ID: <span class="text-slate-100">${draft.tripId.slice(0,8)}</span></div>
          <div class="text-slate-300">開始: <span class="text-slate-100">${draft.startedAt?new Date(draft.startedAt).toLocaleString():'—'}</span></div>
          <div class="text-slate-300">終了: <span class="text-slate-100">${endAtDisplay_manual}</span></div>
          <div class="text-slate-300">件数: <span class="text-slate-100">${cts_manual.length}</span></div>`;
        sum_manual.appendChild(head_manual);

        const wx_manual = document.createElement('div');
        wx_manual.className='grid grid-cols-1 sm:grid-cols-2 gap-2';
        const boxWx_manual = (label, val) => {
          const d=document.createElement('div'); d.className='rounded-xl bg-slate-800/40 p-3';
          d.innerHTML = `<div class="text-xs text-slate-400">${label}</div>
                        <div class="text-sm text-slate-200 mt-0.5">${val||'—'}</div>`;
          return d;
        };
        const sw_manual = draft.start_weather ? formatWeatherBrief(draft.start_weather) : null;
        const ew_manual = draft.end_weather ? formatWeatherBrief(draft.end_weather) : null;
        const st_manual = draft.start_tide ? `${draft.start_tide.tideName} / ${draft.start_tide.trendText}` : null;
        const wt_manual = draft.start_water_temp && draft.start_water_temp.temperature_c!=null
          ? `${draft.start_water_temp.temperature_c}℃${draft.start_water_temp.point_name?`（${draft.start_water_temp.point_name}）`:''}`
          : null;

        wx_manual.appendChild(boxWx_manual('開始時の天気', sw_manual));
        wx_manual.appendChild(boxWx_manual('終了時の天気', ew_manual));
        wx_manual.appendChild(boxWx_manual('開始時の潮', st_manual));
        wx_manual.appendChild(boxWx_manual('当日の水温', wt_manual));
        sum_manual.appendChild(wx_manual);

        if (draft.start_tide?.chart){
          const tideWrap_manual = document.createElement('div');
          tideWrap_manual.className = 'rounded-2xl border border-slate-800 bg-slate-900 p-3';
          const harborName_manual = draft.start_tide?.harbor?.hn || '';
          const dateKey_manual    = draft.start_tide?.chartDateKey || '';
          const title_manual = document.createElement('div');
          title_manual.className = 'text-sm text-slate-300 mb-2';
          title_manual.textContent = `開始日の潮汐グラフ ${harborName_manual ? `（${harborName_manual}）` : ''} ${dateKey_manual ? `- ${dateKey_manual}`:''}`;
          tideWrap_manual.appendChild(title_manual);
          const canvas_manual = document.createElement('canvas');
          canvas_manual.className = 'w-full h-[260px] bg-slate-950 rounded-lg';
          tideWrap_manual.appendChild(canvas_manual);
          sum_manual.appendChild(tideWrap_manual);
          setTimeout(()=> drawTideChartOnCanvas(canvas_manual, draft.start_tide.chart), 0);
        }

        const list_manual = document.createElement('div');
        list_manual.className='divide-y divide-slate-800 rounded-xl border border-slate-800';
        cts_manual.forEach((c, idx)=>{
          const row_manual=document.createElement('div'); row_manual.className='p-3 text-sm';
          const t_manual   = c.timestamp? new Date(c.timestamp).toLocaleString(): '';
          const wxs_manual = c.weather? formatWeatherBrief(c.weather): '';
          row_manual.innerHTML =
            `<div class="font-semibold text-slate-100">${c.species||'(魚種未設定)'} <span class="text-slate-400 text-xs ml-2">${t_manual}</span></div>
            <div class="text-slate-300 mt-1">${[c.size_cm!=null?`サイズ:${c.size_cm}cm`:null, c.weight_g!=null?`重量:${c.weight_g}g`:null, c.method||null].filter(Boolean).join(' / ')}</div>
            <div class="text-slate-400 text-xs mt-1">${wxs_manual}</div>`;
          list_manual.appendChild(row_manual);
        });
        sum_manual.appendChild(list_manual);

        uploadReviewBody.innerHTML=''; uploadReviewBody.appendChild(sum_manual);
        uploadReviewModal.classList.remove('hidden');

        pendingEnd = null;
        // ★修正：共通関数でオーバーレイを消す
        hideUploadingOverlay();
        return;
      }

      // 従来の終了時天気取得
      let endWx = null;
      const endedAtTime = nowIsoLocal();
      if (typeof draft.lat === 'number' && typeof draft.lng === 'number'){
        try { endWx = await fetchWeather(draft.lat, draft.lng, new Date(endedAtTime)); } catch(e){ console.error('[4775] fetchWeather error:', e); }
      }
      pendingEnd = { endedAt: endedAtTime, end_weather: endWx };

      // ★追加：潮汐チャート画像を取得・アップロード
      console.log('[openTripReview] Fetching tide images');
      try {
        const tideResult = await fetchAndUploadTideImages(draft.startedAt, pendingEnd.endedAt);
        console.log('[openTripReview] Tide image fetch completed:', tideResult);
        if (tideResult.ok && tideResult.images.length > 0) {
          draft.tide_chart_images = tideResult.images;
          console.log('[openTripReview] Stored', tideResult.images.length, 'tide chart images');
        }
      } catch (err) {
        console.warn('[openTripReview] Tide image fetch error:', err);
      }

      // 従来どおりアップロード確認モーダルへ
      openUploadReview();
      
      // ★修正：共通関数でオーバーレイを消す
      hideUploadingOverlay();
    }

    // ★追加: EXIF日時→JST固定ISO（+09:00）へ正規化（EXIFロジック側から呼び出し想定）
    function exifDateToJstIso(exifLocal) {
      // exifLocal: "YYYY:MM:DD HH:mm:ss" など（一般的なEXIF表記）
      if (!exifLocal || typeof exifLocal !== 'string') return null;
      const m = exifLocal.match(/^(\d{4}):?(\d{2}):?(\d{2})[ T](\d{2}):(\d{2}):(\d{2})$/);
      if (!m) return null;
      const [_, y, mo, d, hh, mi, ss] = m;
      // JST固定のISO拡張
      return `${y}-${mo}-${d}T${hh}:${mi}:${ss}+09:00`;
    }

    // ★追加: 代表位置を「釣果の最初の写真EXIF（lat/lng）」優先で決める
    function pickRepresentativePositionFromCatches(catches) {
      if (!Array.isArray(catches) || !catches.length) return null;

      // 「最初に登録された釣果」を優先し、写真EXIFがない場合は次の釣果へ…
      for (let i = 0; i < catches.length; i++) {
        const c = catches[i];
        // EXIFロジックで c.exif_lat / c.exif_lng が設定されている前提（「確立済」とのこと）
        const lat = (typeof c.exif_lat === 'number') ? c.exif_lat : null;
        const lng = (typeof c.exif_lng === 'number') ? c.exif_lng : null;
        if (lat != null && lng != null && isFinite(lat) && isFinite(lng)) {
          return { lat, lng, from: 'catch_exif', index: i };
        }
      }
      return null;
    }

    // ★追加: 終了ボタン押下時に、不足項目（開始/終了時刻・代表位置・開始時潮汐）を補完
    async function complementTripFromCatches(force = false) {
      if (!draft) return;
      const cts = Array.isArray(draft.catches) ? draft.catches.slice() : [];
      
      // ★追加：開始日時の前の値を記録（変更検出用）
      const previousStartedAt = draft.startedAt;

      // ★ログ追加：関数の発火を記録
      LOG.app("[Complement] start", {
        force,
        catches: cts.length,
        hasStartedAt: !!draft.startedAt,
        hasEndedAt: !!draft.endedAt,
        hasPos: (typeof draft.lat === 'number' && typeof draft.lng === 'number'),
        hasStartTide: !!draft.start_tide
      });

      // startedAt 再評価
      // ★修正：手動釣行と自動釣行の両方で、最初に設定された開始日時を保持する
      if (cts.length) {
        // 通常釣行が釣行完了時：最初の釣果タイムスタンプで startedAt を再計算
        // 手動釣行：startedAt を保護（変更しない）
        const shouldComplementStartedAt = !draft.startedAt || 
          (!draft.manualStarted && draft.status === 'ended');
        
        if (shouldComplementStartedAt) {
          const xs = cts
            .filter(c => c.timestamp != null)
            .map(c => ({ t: new Date(c.timestamp).getTime(), raw: c.timestamp }))
            .filter(x => isFinite(x.t));
          if (xs.length) {
            const min = xs.reduce((a,b)=> a.t<b.t ? a : b);
            draft.startedAt = toOffsetIsoLocal(new Date(min.t));
            LOG.app("[Complement] decided startedAt", { startedAt: draft.startedAt, sample: xs[0]?.raw || null, manualStarted: draft.manualStarted });
          } else {
            LOG.app("[Complement] startedAt not decided (no valid timestamps)");
          }
        } else {
          LOG.app("[Complement] skipped startedAt (startedAt already set)", { manualStarted: draft.manualStarted, startedAt: draft.startedAt });
        }
      }
      
      // ★追加：開始日時が変更されたか判定
      const startedAtChanged = previousStartedAt !== draft.startedAt;
      LOG.app("[Complement] startedAtChanged check", { previous: previousStartedAt, current: draft.startedAt, changed: startedAtChanged });

      // endedAt 再評価（手動開始でも“未設定なら”補完OK）
      if ( ( (!draft.endedAt && cts.length) || (force && !draft.manualStarted) ) ) {
        const xs = cts
          .filter(c => c.timestamp != null)
          .map(c => ({ t: new Date(c.timestamp).getTime(), raw: c.timestamp }))
          .filter(x => isFinite(x.t));
        if (xs.length) {
          const max = xs.reduce((a,b)=> a.t>b.t ? a : b);
          draft.endedAt = toOffsetIsoLocal(new Date(max.t));
          LOG.app("[Complement] decided endedAt", { endedAt: draft.endedAt, sample: xs[0]?.raw || null });
        } else {
          LOG.app("[Complement] endedAt not decided (no valid timestamps)");
        }
      }

      // 代表位置（EXIF）再評価（手動開始を尊重して上書きしない）
      if (!draft.manualStarted && ( force || !(typeof draft.lat === 'number' && typeof draft.lng === 'number') )) {
        const pick = pickRepresentativePositionFromCatches(cts);
        if (pick && pick.lat != null && pick.lng != null) {
          draft.lat = pick.lat;
          draft.lng = pick.lng;
          LOG.app("[Complement] decided position from EXIF", { lat: draft.lat, lng: draft.lng, index: pick.index });
        } else {
          LOG.app("[Complement] position not decided (no EXIF lat/lng in catches)");
        }
      }

      if ((force || !draft.start_tide) &&
          typeof draft.lat === 'number' && typeof draft.lng === 'number' && draft.startedAt) {
        try {
          LOG.app("[Complement] fetching start_tide...", { lat: draft.lat, lng: draft.lng, startedAt: draft.startedAt });
          const tide = await fetchTideForStart(draft.lat, draft.lng, draft.startedAt);
          draft.start_tide = tide || null;
          if (tide?.chart && tide?.chartDateKey) {
            draft.tide_daily_cache = draft.tide_daily_cache || {};
            draft.tide_daily_cache[tide.chartDateKey] = {
              harbor: tide.harbor || null,
              chart: tide.chart
            };
          }
          // ★ログ追加：潮汐決定
          LOG.app("[Complement] decided start_tide", {
            hasTide: !!draft.start_tide,
            harbor: draft.start_tide?.harbor?.hn || null,
            dateKey: draft.start_tide?.chartDateKey || null
          });
        } catch (e) {
          console.warn("[complementTripFromCatches] tide fetch failed:", e?.message || e);
          LOG.app("[Complement] start_tide fetch failed", { error: e?.message || String(e) });
        }
      } else {
        LOG.app("[Complement] skip tide (insufficient lat/lng or startedAt)", {
          hasPos: (typeof draft.lat === 'number' && typeof draft.lng === 'number'),
          hasStartedAt: !!draft.startedAt
        });
      }

      // ★追記（移動先）: 開始天気の補完を潮汐の直後に実行し、最初の save 前に確定させる
      // ★修正：開始日時が変更された場合も再取得
      if ((force || !draft.start_weather || startedAtChanged) &&
          typeof draft.lat === 'number' && typeof draft.lng === 'number' &&
          draft.startedAt) {
        try {
          LOG.app("[Complement] fetching start_weather...", { lat: draft.lat, lng: draft.lng, startedAt: draft.startedAt });
          draft.start_weather = await fetchWeather(draft.lat, draft.lng, draft.startedAt);
          LOG.app("[Complement] decided start_weather", { ok: !!draft.start_weather });
        } catch (e) {
          console.warn("[Complement] start_weather fetch failed:", e?.message || e);
          LOG.app("[Complement] start_weather fetch failed", { error: e?.message || String(e) });
        }
      }

      // ★追加：手動追加時の水温補完（開始日が今日以外なら過去データから取得）
      // ★修正：開始日時が変更された場合も再取得
      if ((force || !draft.start_water_temp || (startedAtChanged && draft.manualStarted)) &&
          typeof draft.lat === 'number' && typeof draft.lng === 'number' &&
          draft.startedAt && draft.manualStarted) {
        try {
          LOG.app("[Complement] fetching water temp for manual entry", { 
            lat: draft.lat, lng: draft.lng, startedAt: draft.startedAt 
          });
          
          // 開始日が今日以外なら過去データから取得
          let waterTemp = await getWaterTempForManualEntry(draft.lat, draft.lng, draft.startedAt, true);
          
          // 過去データが見つからない場合は現在の水温を取得
          if (!waterTemp) {
            waterTemp = await fetchTodayWaterTempByNearest(draft.lat, draft.lng);
          }
          
          draft.start_water_temp = waterTemp;
          LOG.app("[Complement] decided start_water_temp", { 
            hasData: !!draft.start_water_temp,
            temperature_c: draft.start_water_temp?.temperature_c || null
          });
        } catch (e) {
          console.warn("[Complement] start_water_temp fetch failed:", e?.message || e);
          LOG.app("[Complement] start_water_temp fetch failed", { error: e?.message || String(e) });
        }
      }

      // ここまでで startedAt / endedAt / 代表位置 / start_tide / start_weather / start_water_temp を確定済み
      saveDraft(draft);
      LOG.app("[Complement] saved", {
        startedAt: draft.startedAt || null,
        endedAt: draft.endedAt || null,
        lat: draft.lat, lng: draft.lng,
        hasStartTide: !!draft.start_tide,
        hasStartWeather: !!draft.start_weather
      });
    }
    
    // ===== Catches キャッシュ =====
    async function ensureCatchesCache(){
      if (catchesCache) return catchesCache;
      catchesCache = await loadSheetViaGAS(SHEET_NAME, SHEET_ID);
      return catchesCache;
    }

    // ★追記: アップロード再送（オンライン/起動時）
    async function retryUploadQueue(){
      const key='fishlog_upload_queue_v1';
      let q=[]; 
      try { 
        q = JSON.parse(localStorage.getItem(key) || '[]'); 
      } catch { 
        q=[]; 
      }
      if (!Array.isArray(q) || !q.length) return;
      
      // ★追加：多重実行防止
      if (isUploading) return;
      
      // ★修正：共通関数でローディングオーバーレイを表示（アップロード中テキスト）
      showUploadingOverlay('保留中のアップロードを再送中...');

      const remain=[];
      for (const item of q){
        try{
          const res = await fetch(CONFIG.API.FISHING_TRIP_API_WORKER + '/api/upload', {
            method:'POST',
            headers: { 'Content-Type': 'application/json', 'X-Auth-Token': CONFIG.API.WORKERS_AUTH_TOKEN },
            body: JSON.stringify(item.payload)
          });
          if (!res.ok){ remain.push(item); continue; }
          await res.text(); // 消費
          console.log('[UploadQueue] Item sent successfully');
        }catch(e){
          console.warn('[UploadQueue] Send failed:', e.message);
          remain.push(item);
        }
      }
      try {
        localStorage.setItem(key, JSON.stringify(remain));
      } catch (e) {
        console.warn('[UploadQueue] Failed to update queue:', e.message);
      }
      // ★修正：完了時に共通関数でオーバーレイを消す
      hideUploadingOverlay();
      if (q.length && !remain.length) { try{ alert('保留中のアップロードを再送し、すべて完了しました。'); }catch{} }
    }
    window.addEventListener('online', ()=> retryUploadQueue());
    // 初期表示後に一度だけ試行
    setTimeout(()=> retryUploadQueue(), 1000);

    function openManualTripForm(){
      // ★追加: モーダル親の recordView を表示させる（親の hidden を外す）
      showView('record');

      // 入力初期化
      try {
        inpTripStart.value = '';
        inpTripLat.value   = (typeof draft.lat==='number') ? String(draft.lat) : '';
        inpTripLng.value   = (typeof draft.lng==='number') ? String(draft.lng) : '';
      } catch(_) {}

      // 入力初期化
      try {
        inpTripStart.value = '';
        inpTripLat.value   = (typeof draft.lat==='number') ? String(draft.lat) : '';
        inpTripLng.value   = (typeof draft.lng==='number') ? String(draft.lng) : '';
      } catch(_) {}

      // ★修正：年は4桁に厳密に制限（keydown + input で確実に制御）
      if (inpTripStart) {
        // 古いハンドラをクリア
        if (inpTripStart._inputHandler) {
          inpTripStart.removeEventListener('input', inpTripStart._inputHandler);
        }
        if (inpTripStart._keydownHandler) {
          inpTripStart.removeEventListener('keydown', inpTripStart._keydownHandler);
        }
        
        // keydown：5文字目入力を検知して、年を切り詰める
        inpTripStart._keydownHandler = (evt) => {
          if (evt.key.match(/[0-9]/)) {
            const digits = inpTripStart.value.replace(/\D/g, '');
            // 年が既に4桁あり、5文字目以降を入力しようとしているなら許可しない
            if (digits.length >= 4) {
              // 5文字目を入力する際は、イベント直後に値を書き直す
              setTimeout(() => {
                const newDigits = inpTripStart.value.replace(/\D/g, '');
                if (newDigits.length > 4) {
                  // 年を4桁に制限し、5文字目以降を月・日・時・分に振り分ける
                  const y  = newDigits.slice(0, 4);
                  const mo = newDigits.slice(4, 6);
                  const d  = newDigits.slice(6, 8);
                  const hh = newDigits.slice(8, 10);
                  const mm = newDigits.slice(10, 12);

                  let formatted = y;
                  if (mo) formatted += '-' + mo;
                  if (d)  formatted += '-' + d;
                  if (hh) formatted += 'T' + hh;
                  if (mm) formatted += ':' + mm;

                  inpTripStart.value = formatted;
                }
              }, 0);
            }
          }
        };

        inpTripStart._inputHandler = () => {
          const digits = inpTripStart.value.replace(/\D/g, '');
          
          if (!digits) {
            inpTripStart.value = '';
            return;
          }

          const y  = digits.slice(0, 4);
          const mo = digits.slice(4, 6);
          const d  = digits.slice(6, 8);
          const hh = digits.slice(8, 10);
          const mm = digits.slice(10, 12);

          let formatted = y;
          if (mo) formatted += '-' + mo;
          if (d)  formatted += '-' + d;
          if (hh) formatted += 'T' + hh;
          if (mm) formatted += ':' + mm;

          if (formatted !== inpTripStart.value) {
            inpTripStart.value = formatted;
          }
        };

        inpTripStart.addEventListener('keydown', inpTripStart._keydownHandler);
        inpTripStart.addEventListener('input', inpTripStart._inputHandler);
      }

      // ★追加: 要素未挿入時の安全対策
      if (!tripModal) { alert('釣行入力モーダルのHTML（id="tripModal"）が見つかりません。HTMLを確認してください。'); return; }

      tripModal.classList.remove('hidden');
    }

    // ★追記: 手動釣果フォーム（最小項目）
    function openManualCatchForm(){
      // 釣行ステータスに関係なく、既存の釣果追加モーダルをそのまま使う
      showView('record');                       // 記録ビューへ
      editMode = false; 
      editingId = null; 
      modalTitle.textContent = '手動で釣果を追加';
      manualCatchMode = true;

      // ★追加：手動モードフラグを明示的にオン
      manualCatchMode = true;

      // 既存 openAddCatch と同等の初期化（status チェックはしない）
      catchForm = { 
        id: uuid(),
        timestamp: null,                        // ← 時刻は入れない（null）
        species:'', 
        size_cm:null, 
        weight_g:null, 
        method:'', 
        photoPreviewUrl: undefined 
      };

      // ← 入力欄は空のまま
      inpCatchTime.value = '';
      inpSpecies.value   = '';
      inpSize.value      = '';
      inpWeight.value    = '';
      inpMethod.value    = '';
      inpPhoto.value     = '';
      imgPreview.src     = '';
      imgPreview.classList.add('hidden');

      // モーダルを開く
      catchModal.classList.remove('hidden');
    }

    // ★変更: 手動釣行の登録（写真・現在地の取得は行わず、モーダル入力だけで確定。登録時に不足補完を実行）
    async function submitManualTrip(){
      let startedIso = null;
      let lat = null, lng = null;

      // 1) モーダル入力のみ採用（未入力は未設定のまま）
      if (inpTripStart && inpTripStart.value) {
        try {
          startedIso = toOffsetIsoLocal(new Date(inpTripStart.value));
        } catch(e) {
          console.warn("[TripManual] Failed to parse start time:", e);
          startedIso = null;
        }
      }
      if (inpTripLat && inpTripLat.value)     lat = Number(inpTripLat.value);
      if (inpTripLng && inpTripLng.value)     lng = Number(inpTripLng.value);

      // 2) ★修正: 入力がないなら startedIso は null のまま（自動補完なし）

      // 3) draft に反映（位置は入力が両方あるときのみ採用）
      draft.status        = 'active';
      draft.startedAt     = startedIso;  // ★修正: null の場合は null のまま
      draft.manualStarted = true; // ★追加：手動開始フラグを明示的にON
      
      // ★修正①: 釣果がない場合に備えて、endedAt を現在時刻で初期化
      if (!draft.endedAt) {
        draft.endedAt = nowIsoLocal();  // 釣行終了時刻の初期値
      }
      
      if (typeof lat === 'number' && typeof lng === 'number' && isFinite(lat) && isFinite(lng)) {
        draft.lat = lat;
        draft.lng = lng;
      } else {
        LOG.app("[TripManual] position not provided; skip weather/tide/water completion at this time");
      }

      // 4) 未入力情報の補完（この登録ボタン押下時に実行）
      try{
        if (typeof draft.lat === 'number' && typeof draft.lng === 'number'){
          // 天気
          try { draft.start_weather = await fetchWeather(draft.lat, draft.lng); }
          catch(e){ console.warn("[Weather] manualTrip fetch failed:", e?.message||e); }

          // 潮（開始時）
          try{
            const tide = await fetchTideForStart(draft.lat, draft.lng, draft.startedAt);
            draft.start_tide = tide || null;
            if (tide?.chart && tide?.chartDateKey){
              draft.tide_daily_cache = draft.tide_daily_cache || {};
              draft.tide_daily_cache[tide.chartDateKey] = {
                harbor: tide.harbor || null, chart: tide.chart
              };
            }
          }catch(e){ console.warn("[Tide] manualTrip fetch failed:", e?.message||e); }

          // 水温（当日・最寄り、または開始日の過去データ）
          try{
            if (DEBUG_WATER) LOG.wt("manualTrip: fetch water temp", { lat: draft.lat, lng: draft.lng, startedAt: draft.startedAt });
            
            let waterTemp = null;
            
            // ★修正：手動追加かつ開始日が今日以外なら過去データから取得を試みる
            if (draft.manualStarted && draft.startedAt) {
              waterTemp = await getWaterTempForManualEntry(draft.lat, draft.lng, draft.startedAt, true);
            }
            
            // 過去データが見つからない、または開始日が今日の場合は現在の水温を取得
            if (!waterTemp) {
              waterTemp = await fetchTodayWaterTempByNearest(draft.lat, draft.lng);
            }
            
            draft.start_water_temp = waterTemp;
            if (DEBUG_WATER) LOG.wt("manualTrip: water temp result", draft.start_water_temp);
          }catch(e){ console.warn("[WaterTemp] manualTrip failed:", e?.message||e); }
        }
      }catch(e){
        console.warn("[TripManual] unexpected:", e?.message||e);
      }

      // 5) 保存とUI
      saveDraft(draft);
      LOG.app("[TripManual] saved (no photo, no geolocation)", {
        startedAt: draft.startedAt,
        lat: draft.lat, lng: draft.lng,
        hasStartWeather: !!draft.start_weather,
        hasStartTide: !!draft.start_tide,
        hasWater: !!(draft.start_water_temp && draft.start_water_temp.temperature_c!=null)
      });

      tripModal && tripModal.classList.add('hidden');
      
      // ★修正①: openTripReview() → _complementTripDataOnly() に変更（モーダル表示なし）
      await _complementTripDataOnly();
    }

    // ★追加：オーバーレイメッセージを設定して表示する共通関数
    function showUploadingOverlay(message = 'アップロード中...') {
      console.log('[showUploadingOverlay] START', { message, isUploading });
      uploadingMessage = message;
      const messageEl = document.getElementById('uploadingMessage');
      if (messageEl) messageEl.textContent = message;
      
      isUploading = true;
      const uploadingOverlay = document.getElementById('uploadingOverlay');
      console.log('[showUploadingOverlay] element found:', !!uploadingOverlay);
      
      if (!uploadingOverlay) {
        console.error('[showUploadingOverlay] uploadingOverlay NOT FOUND!');
        return;
      }
      
      // ★颅於：hiddenクラスを明示的に削除
      if (uploadingOverlay.classList.contains('hidden')) {
        console.log('[showUploadingOverlay] removing hidden class');
        uploadingOverlay.classList.remove('hidden');
      }
      uploadingOverlay.style.display = 'flex';
      uploadingOverlay.style.visibility = 'visible';
      uploadingOverlay.style.opacity = '1';
      uploadingOverlay.style.pointerEvents = 'auto';
      
      console.log('[showUploadingOverlay] styles applied:', {
        display: uploadingOverlay.style.display,
        computed: window.getComputedStyle(uploadingOverlay).display
      });
      console.log('[showUploadingOverlay] END');
    }

    function hideUploadingOverlay() {
      console.log('[hideUploadingOverlay] START');
      isUploading = false;
      const uploadingOverlay = document.getElementById('uploadingOverlay');
      if (!uploadingOverlay) {
        console.error('[hideUploadingOverlay] uploadingOverlay NOT FOUND!');
        return;
      }
      uploadingOverlay.classList.add('hidden');
      uploadingOverlay.style.display = 'none';
      uploadingOverlay.style.visibility = 'hidden';
      uploadingOverlay.style.opacity = '0';
      uploadingOverlay.style.pointerEvents = 'none';
      console.log('[hideUploadingOverlay] END');
    }

    // ===== モーダル操作 =====
    const uploadReviewModalEl = document.getElementById('uploadReviewModal');
    document.getElementById('btnCloseModal').onclick  = ()=> cancelAndReturnHome();
    document.getElementById('btnCancelCatch').onclick = ()=> cancelAndReturnHome();
    document.getElementById('btnSaveCatch').onclick   = async (e) => {
      // ★追加：ボタンクリック時に最初に操作ブロック＆オーバーレイ表示
      if (isUploading) return;
      isUploading = true;
      showUploadingOverlay('釣果アップロード中...');
      await new Promise(resolve => requestAnimationFrame(resolve));
      
      // その後で実際の処理を実行
      try {
        await submitCatch();
      } catch (e) {
        console.error('[btnSaveCatch] error:', e);
      }
    };
    catchModal.addEventListener('click', (e)=>{ if (e.target === catchModal) cancelAndReturnHome(); });

    // 下部バー
    btnAddCatchBottom.onclick=openAddCatch;
    btnEndBottom.onclick = openTripReview;

    // 初期表示
    render();
    // ★追加：釣行編集モーダルを開く
    // ★追加：補完データを UI に反映する関数
    function updateEditModalCompData() {
      editTripWeather.textContent = draft.start_weather ? formatWeatherBrief(draft.start_weather) : '未設定';
      editTripTide.textContent = draft.start_tide 
        ? `${draft.start_tide.tideName || ''} / ${draft.start_tide.trendText || ''}`
        : '未設定';
      editTripWaterTemp.textContent = draft.start_water_temp && draft.start_water_temp.temperature_c != null
        ? `${draft.start_water_temp.temperature_c}℃${draft.start_water_temp.point_name ? `（${draft.start_water_temp.point_name}）` : ''}`
        : '未設定';
    }

    function openTripEditModal(catchIndexToSelect = -1) {
      if (!draft) {
        alert('データが見つかりません');
        return;
      }

      // 釣行基本情報を入力欄に反映
      if (draft.startedAt) {
        const d = new Date(draft.startedAt);
        editTripStarted.value = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
      } else {
        editTripStarted.value = '';
      }

      if (draft.endedAt) {
        const d = new Date(draft.endedAt);
        editTripEnded.value = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
      } else {
        editTripEnded.value = '';
      }

      editTripLat.value = typeof draft.lat === 'number' ? draft.lat : '';
      editTripLng.value = typeof draft.lng === 'number' ? draft.lng : '';

      // ★追加：メモを反映
      const editTripMemo = document.getElementById('editTripMemo');
      if (editTripMemo) {
        editTripMemo.value = draft.memo || '';
      }

      // 補完データを表示
      updateEditModalCompData();
      
      // 釣果リストを表示
      renderEditCatchList();

      // モーダルを表示
      uploadReviewModal.classList.add('hidden');
      tripEditModal.classList.remove('hidden');

      LOG.app('[TripEdit] opened', { catchCount: draft.catches?.length || 0 });
    }

    // ★グローバルスコープにアサイン（trips セクションから呼び出せるようにする）
    window._openTripEditModal = openTripEditModal;

    // ★追加：釣行編集モーダル内の釣果リストを描画
    function renderEditCatchList() {
      const cts = draft.catches || [];
      editCatchList.innerHTML = '';
      editCatchCount.textContent = cts.length;

      // ★修正：カラムマッピングをループの外で作成
      const catchHeaders = (catchesCache || [])[0] || [];
      const colCatch = {};
      for (let i = 0; i < catchHeaders.length; i++) {
        colCatch[String(catchHeaders[i]).trim()] = i;
      }
      console.log('[renderEditCatchList] colCatch mapping:', colCatch);

      cts.forEach((c, idx) => {
        // 配列行データをオブジェクトに変換
        const catchObj = {
          species: c[colCatch.species] || '',
          size_cm: parseFloat(c[colCatch.size_cm]) || null,
          weight_g: parseFloat(c[colCatch.weight_g]) || null,
          method: c[colCatch.method] || '',
          timestamp: c[colCatch.timestamp] || ''
        };
        
        console.log(`[renderEditCatchList] catch[${idx}]:`, { raw: c, converted: catchObj });

        const item = document.createElement('div');
        item.className = 'bg-slate-800 rounded-lg p-3 flex items-start justify-between';

        const content = document.createElement('div');
        content.className = 'flex-1 cursor-pointer hover:bg-slate-700/30 rounded p-1 transition';
        content.innerHTML = `
          <div class="font-semibold text-slate-100 text-sm">${catchObj.species || '(魚種未設定)'}</div>
          <div class="text-slate-300 text-xs mt-1">${[
            catchObj.size_cm != null ? `サイズ: ${catchObj.size_cm}cm` : null,
            catchObj.weight_g != null ? `重量: ${catchObj.weight_g}g` : null,
            catchObj.method || null
          ].filter(Boolean).join(' / ')}</div>
          <div class="text-slate-400 text-xs mt-1">${catchObj.timestamp ? new Date(catchObj.timestamp).toLocaleString() : ''}</div>
        `;
        content.onclick = () => {
          // 釣果編集フォームを開く（同じフォーム使用）
          editCatchForm(idx);
        };

        const btnDelete = document.createElement('button');
        btnDelete.className = 'text-xs py-1 px-2 rounded bg-red-900 hover:bg-red-800 text-red-200 ml-2';
        btnDelete.textContent = '削除';
        btnDelete.onclick = () => {
          if (confirm('この釣果を削除しますか？')) {
            draft.catches.splice(idx, 1);
            saveDraft(draft);
            renderEditCatchList();
          }
        };

        item.appendChild(content);
        item.appendChild(btnDelete);
        editCatchList.appendChild(item);
      });
    }

    // ★追加：釣行編集モーダル内で釣果を編集
    function editCatchForm(catchIndex) {
      // 既存の釣果フォームを使用
      if (catchIndex >= 0 && catchIndex < draft.catches.length) {
        catchForm = { ...draft.catches[catchIndex] };
        LOG.app('[EditCatch] editing catch', { index: catchIndex });
      } else {
        catchForm = { timestamp: null, species: '', size_cm: null, weight_g: null, method: '', photoPreviewUrl: undefined };
        LOG.app('[EditCatch] adding new catch');
      }

      // 入力欄に反映
      if (catchForm.timestamp) {
        const d = new Date(catchForm.timestamp);
        inpCatchTime.value = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}T${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
      } else {
        inpCatchTime.value = '';
      }
      inpSpecies.value = catchForm.species || '';
      inpSize.value = catchForm.size_cm ?? '';
      inpWeight.value = catchForm.weight_g ?? '';
      inpMethod.value = catchForm.method || '';
      
      if (catchForm.photoPreviewUrl) {
        imgPreview.src = catchForm.photoPreviewUrl;
        imgPreview.classList.remove('hidden');
      } else {
        imgPreview.src = '';
        imgPreview.classList.add('hidden');
      }
      inpPhoto.value = '';

      // 釣行編集モーダルを閉じ、釣果フォームモーダルを開く
      tripEditModal.classList.add('hidden');
      catchModal.classList.remove('hidden');

      // submitCatch後に釣行編集モーダルに戻るフラグを設定
      window._returnToTripEditAfterCatch = true;
    }

    // 釣果保存後に釣行編集モーダルに戻るための修正
    const originalSubmitCatch = submitCatch;
    submitCatch = function() {
      originalSubmitCatch.call(this);
      if (window._returnToTripEditAfterCatch) {
        window._returnToTripEditAfterCatch = false;
        setTimeout(() => {
          catchModal.classList.add('hidden');
          tripEditModal.classList.remove('hidden');
          renderEditCatchList();
        }, 100);
      }
    };

    // ★追加：釣行編集モーダルのボタンイベント
    console.log('[ModalSetup] Setting up trip edit modal buttons', { 
      btnCloseTripEdit: !!btnCloseTripEdit, 
      btnCancelTripEdit: !!btnCancelTripEdit,
      tripEditModal: !!tripEditModal 
    });
    if (btnCloseTripEdit) {
      btnCloseTripEdit.onclick = () => {
        console.log('[ModalButton] Close button clicked');
        tripEditModal.style.display = 'none';
        tripEditModal.classList.add('hidden');
      };
    }
    if (btnCancelTripEdit) {
      btnCancelTripEdit.onclick = () => {
        // ★追加：アップロード中はキャンセルできない
        if (isUploading) return;
        
        console.log('[ModalButton] Cancel button clicked');
        tripEditModal.style.display = 'none';
        tripEditModal.classList.add('hidden');
      };
    }
    if (btnAddCatchInEdit) {
      btnAddCatchInEdit.onclick = () => {
        console.log('[EditModal] Add catch button clicked');
        // 釣果追加フォームを表示
        const formSection = document.getElementById('editCatchFormSection');
        if (formSection) {
          formSection.classList.remove('hidden');
          document.getElementById('editFormCatchTime').focus();
        }
      };
    }
    
    // ★追加：データ再取得ボタンのハンドラ
    if (btnRefetchCompData) {
      btnRefetchCompData.onclick = async () => {
        console.log('[btnRefetchCompData] clicked');
        
        // 入力値から日時と位置を取得
        let startedAt = null;
        if (editTripStarted.value) {
          try {
            const dt = new Date(editTripStarted.value.replace(' ', 'T'));
            startedAt = toOffsetIsoLocal(dt);
          } catch (e) {
            alert('開始日時の形式が正しくありません');
            return;
          }
        }
        
        let lat = parseFloat(editTripLat.value);
        let lng = parseFloat(editTripLng.value);
        
        if (!isFinite(lat) || !isFinite(lng)) {
          // 入力がなければ draft から取得
          lat = parseFloat(draft.lat);
          lng = parseFloat(draft.lng);
        }
        
        if (!isFinite(lat) || !isFinite(lng)) {
          alert('位置情報が設定されていません');
          return;
        }
        
        if (!startedAt) {
          alert('開始日時が設定されていません');
          return;
        }
        
        console.log('[btnRefetchCompData] refetching with:', { lat, lng, startedAt });
        
        try {
          // ボタンを無効化
          btnRefetchCompData.disabled = true;
          btnRefetchCompData.style.opacity = '0.5';
          
          // 天気を再取得
          try {
            const weatherTargetDate = new Date(startedAt);
            const weather = await fetchWeather(lat, lng, weatherTargetDate);
            draft.start_weather = weather;
            console.log('[btnRefetchCompData] Weather refetched:', weather);
          } catch (weatherErr) {
            console.error('[btnRefetchCompData] Weather fetch error:', weatherErr);
            draft.start_weather = null;
          }
          
          // 潮汐を再取得（重要：新しい潮汐データで上書き）
          try {
            const tide = await fetchTideForStart(lat, lng, startedAt);
            draft.start_tide = tide || null;
            console.log('[btnRefetchCompData] Tide refetched:', tide);
            
            // 潮汐キャッシュも更新
            if (tide?.chart && tide?.chartDateKey) {
              draft.tide_daily_cache = draft.tide_daily_cache || {};
              draft.tide_daily_cache[tide.chartDateKey] = {
                harbor: tide.harbor || null,
                chart: tide.chart
              };
              console.log('[btnRefetchCompData] Tide cache updated');
            }
          } catch (tideErr) {
            console.error('[btnRefetchCompData] Tide fetch error:', tideErr);
            draft.start_tide = null;
          }
          
          // draft を保存
          saveDraft(draft);
          
          // UI を更新（editTripWeather, editTripTide を更新）
          updateEditModalCompData();
          
          alert('データを再取得しました');
        } catch (e) {
          console.error('[btnRefetchCompData] error:', e);
          alert('再取得に失敗しました: ' + (e?.message || e));
        } finally {
          // ボタンを有効化
          btnRefetchCompData.disabled = false;
          btnRefetchCompData.style.opacity = '1';
        }
      };
    }
    
    // 写真プレビュー + EXIF から日時を補完
    const editFormCatchPhoto = document.getElementById('editFormCatchPhoto');
    if (editFormCatchPhoto) {
      editFormCatchPhoto.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        const preview = document.getElementById('editFormCatchPhotoPreview');
        if (file && preview) {
          const reader = new FileReader();
          reader.onload = (ev) => {
            preview.src = ev.target.result;
            preview.classList.remove('hidden');
          };
          reader.readAsDataURL(file);
          
          // EXIF から日時を抽出して日時フィールドに補完
          try {
            const exifDate = await extractExifDate(file);
            console.log('[EditModal] EXIF date extracted:', exifDate);
            if (exifDate) {
              // EXIF 日時形式: "YYYY:MM:DD HH:MM:SS" → "YYYY-MM-DDTHH:MM"
              const [datePart, timePart] = exifDate.split(' ');
              if (datePart && timePart) {
                const [y, mo, d] = datePart.split(':');
                const [hh, mm] = timePart.split(':');
                const formattedDateTime = `${y}-${mo}-${d}T${hh}:${mm}`;
                const timeInput = document.getElementById('editFormCatchTime');
                if (timeInput && !timeInput.value) {
                  timeInput.value = formattedDateTime;
                }
              }
            }
          } catch (err) {
            console.warn('[EditModal] Failed to extract EXIF date:', err);
          }
        }
      });
    }
    
    // 釣果追加フォームのクローズボタン
    const btnCloseCatchFormInEdit = document.getElementById('btnCloseCatchFormInEdit');
    if (btnCloseCatchFormInEdit) {
      btnCloseCatchFormInEdit.onclick = () => {
        const formSection = document.getElementById('editCatchFormSection');
        if (formSection) {
          formSection.classList.add('hidden');
        }
      };
    }
    
    // 釣果追加フォームのキャンセルボタン
    const btnCancelCatchFormInEdit = document.getElementById('btnCancelCatchFormInEdit');
    if (btnCancelCatchFormInEdit) {
      btnCancelCatchFormInEdit.onclick = () => {
        const formSection = document.getElementById('editCatchFormSection');
        if (formSection) {
          // ★修正：編集状態をリセット
          formSection.dataset.isEditing = 'false';
          formSection.dataset.editingIndex = '-1';
          formSection.classList.add('hidden');
          
          // フォームをクリア
          document.getElementById('editFormCatchTime').value = '';
          document.getElementById('editFormCatchSpecies').value = '';
          document.getElementById('editFormCatchSize').value = '';
          document.getElementById('editFormCatchWeight').value = '';
          document.getElementById('editFormCatchMethod').value = '';
          document.getElementById('editFormCatchPhoto').value = '';
          document.getElementById('editFormCatchPhotoPreview').classList.add('hidden');
          
          // ★修正：写真フィールドを再表示（追加モード用）
          const photoLabel = document.querySelector('label:has(#editFormCatchPhoto)');
          if (photoLabel) photoLabel.classList.remove('hidden');
          
          // ボタンテキストをリセット
          document.getElementById('btnSaveCatchFormInEdit').textContent = '追加';
        }
      };
    }
    
    // 釣果追加フォームの保存ボタン
    const btnSaveCatchFormInEdit = document.getElementById('btnSaveCatchFormInEdit');
    if (btnSaveCatchFormInEdit) {
      btnSaveCatchFormInEdit.onclick = async () => {
        const timeInput = document.getElementById('editFormCatchTime').value.trim();
        const species = document.getElementById('editFormCatchSpecies').value.trim();
        const size = document.getElementById('editFormCatchSize').value.trim();
        const weight = document.getElementById('editFormCatchWeight').value.trim();
        const method = document.getElementById('editFormCatchMethod').value.trim();
        const photoInput = document.getElementById('editFormCatchPhoto');
        
        if (!species) {
          alert('魚種を入力してください');
          return;
        }
        
        // 新しい釣果オブジェクトを作成
        const newCatch = {
          id: uuid(),  // ★追加：catchId を生成
          tripId: draft.tripId,
          timestamp: null,
          species: species,
          size_cm: size ? parseFloat(size) : null,
          weight_g: weight ? parseFloat(weight) : null,
          method: method || '',
          
          // ★追加：天気情報（釣行の開始天気から初期設定）
          wx_temp: draft.start_weather?.temp ?? null,
          wx_wind_speed: draft.start_weather?.wind_speed ?? null,
          wx_wind_deg: draft.start_weather?.wind_deg ?? null,
          wx_main: draft.start_weather?.weather_main ?? null,
          wx_desc: draft.start_weather?.weather_description ?? null,
          
          // ★追加：潮汐情報（後で補完）
          tide_trend: null,  // ★潮汐ロジックで補完予定
          tide_level_cm: null,  // ★潮汐ロジックで補完予定
          tide_name: draft.start_tide?.tideName ?? null,
          tide_harbor_name: draft.start_tide?.harbor?.hn ?? null,
          tide_high_times: draft.start_tide?.high_times ?? null,
          tide_low_times: draft.start_tide?.low_times ?? null,
          
          // ★追加：水温情報（釣行の開始水温から初期設定）
          water_temp_c: draft.start_water_temp?.temperature_c ?? null,
          water_temp_point: draft.start_water_temp?.point_name ?? null,
          water_temp_time: draft.start_water_temp?.date ?? null,
          
          // 写真
          weather: draft.weather || null,
          photoFileId: null,
          photoDriveUrl: null,
          photoDriveThumbUrl: null
        };
        
        // タイムスタンプを設定
        const editFormSection = document.getElementById('editCatchFormSection');
        const isEditing = editFormSection?.dataset.isEditing === 'true';
        const editingIndex = parseInt(editFormSection?.dataset.editingIndex) || -1;
        
        if (isEditing && editingIndex >= 0 && editingIndex < draft.catches.length) {
          // ★編集モード：編集元の釣果があればそのtimestampを保持
          const existingCatch = draft.catches[editingIndex];
          if (timeInput) {
            // timeInputが入力されている場合は新しい値を使う
            if (timeInput.includes('T')) {
              newCatch.timestamp = new Date(timeInput).toISOString();
            } else if (timeInput.includes(':')) {
              const [hh, mm, ss] = timeInput.split(':').map(x => parseInt(x) || 0);
              const now = new Date();
              newCatch.timestamp = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hh, mm, ss).toISOString();
            }
          } else {
            // timeInputが空の場合は編集元の時刻を保持
            newCatch.timestamp = existingCatch.timestamp;
          }
        } else {
          // ★追加モード：通常のタイムスタンプ設定
          if (timeInput) {
            // YYYY-MM-DDTHH:MM形式またはHH:MM:SS形式に対応
            if (timeInput.includes('T')) {
              // YYYY-MM-DDTHH:MM形式
              newCatch.timestamp = new Date(timeInput).toISOString();
            } else if (timeInput.includes(':')) {
              // HH:MM:SS形式 → 今日の日付 + 指定時間
              const [hh, mm, ss] = timeInput.split(':').map(x => parseInt(x) || 0);
              const now = new Date();
              newCatch.timestamp = new Date(
                now.getFullYear(), 
                now.getMonth(), 
                now.getDate(), 
                hh, 
                mm, 
                ss
              ).toISOString();
            }
          } else {
            newCatch.timestamp = new Date().toISOString();
          }
        }
        
        // ★修正：写真のアップロード処理（新規作成時、編集時の両方で写真変更可能）
        if (photoInput && photoInput.files && photoInput.files.length > 0) {
          // 新規作成または編集時に新しい写真が選択されている場合
          const file = photoInput.files[0];
          try {
            const photoResult = await uploadPhotoToDrive(file);
            if (photoResult) {
              newCatch.photoFileId = photoResult.fileId || null;
              newCatch.photoDriveUrl = photoResult.viewUrl || null;
              newCatch.photoDriveThumbUrl = photoResult.thumbUrl || null;
              console.log('[EditModal] Photo uploaded:', photoResult);
            }
          } catch (ex) {
            console.warn('[EditModal] Photo upload failed:', ex?.message || ex);
          }
        } else if (isEditing && editingIndex >= 0 && editingIndex < draft.catches.length) {
          // 編集時で新しい写真が選択されていない場合は既存写真を保持
          const existingCatch = draft.catches[editingIndex];
          newCatch.photoFileId = existingCatch.photoFileId;
          newCatch.photoDriveUrl = existingCatch.photoDriveUrl;
          newCatch.photoDriveThumbUrl = existingCatch.photoDriveThumbUrl;
        }
        
        // ★潮汐情報を補完するロジック（submitCatch と同じ）
        if (newCatch.timestamp && typeof draft.lat === 'number' && typeof draft.lng === 'number') {
          const dkey = dateKeyFromIso(newCatch.timestamp);
          
          try {
            let dayChart = null;
            // draft.tide_daily_cache にキャッシュがあるか確認
            if (draft.tide_daily_cache?.[dkey]?.chart) {
              dayChart = draft.tide_daily_cache[dkey].chart;
              const info = tideInfoFromChart(dayChart, newCatch.timestamp);
              newCatch.tide_level_cm = info.level_cm;
              newCatch.tide_trend = info.trend_text;
              console.log('[EditModal] Tide from cache:', info);
            } else {
              // キャッシュになければ API から取得
              const pack = await getTideChartForDate(draft.lat, draft.lng, newCatch.timestamp);
              if (pack?.chart) {
                dayChart = pack.chart;
                draft.tide_daily_cache = draft.tide_daily_cache || {};
                draft.tide_daily_cache[dkey] = { harbor: pack.harbor || null, chart: pack.chart };
                const info = tideInfoFromChart(pack.chart, newCatch.timestamp);
                newCatch.tide_level_cm = info.level_cm;
                newCatch.tide_trend = info.trend_text;
                // ★潮汐チャートから満潮・干潮時刻を計算
                const hl = summarizeHighLowTimesFromChart(dayChart);
                newCatch.tide_high_times = hl.high;
                newCatch.tide_low_times = hl.low;
                console.log('[EditModal] Tide from API:', info, 'high/low:', hl);
              }
            }
            
            // ★キャッシュから取得した場合も満潮・干潮を計算
            if (dayChart && !newCatch.tide_high_times && !newCatch.tide_low_times) {
              const hl = summarizeHighLowTimesFromChart(dayChart);
              newCatch.tide_high_times = hl.high;
              newCatch.tide_low_times = hl.low;
            }
            
            // ★潮汐名と港名を設定
            if (dayChart) {
              newCatch.tide_name = dayChart?.moon?.title || draft.start_tide?.tideName || null;
              if (draft.tide_daily_cache?.[dkey]?.harbor) {
                newCatch.tide_harbor_name = draft.tide_daily_cache[dkey].harbor.hn || null;
              } else {
                newCatch.tide_harbor_name = draft.start_tide?.harbor?.hn || null;
              }
            }
          } catch (ex) {
            console.warn('[EditModal] Tide calculation failed:', ex?.message || ex);
          }
        }
        
        // ★天気情報を補完するロジック（submitCatch と同じ）
        console.log('[EditModal] Weather check - draft.lat:', draft.lat, 'draft.lng:', draft.lng, 'type check:', typeof draft.lat === 'number' && typeof draft.lng === 'number');
        if (typeof draft.lat === 'number' && typeof draft.lng === 'number') {
          console.log('[EditModal] Entering weather fetch block, lat:', draft.lat, 'lng:', draft.lng);
          try {
            console.log('[EditModal] About to call fetchWeather...');
            const wx = await fetchWeather(draft.lat, draft.lng);
            console.log('[EditModal] fetchWeather returned:', wx);
            if (wx) {
              console.log('[EditModal] Weather object is truthy, assigning fields...');
              newCatch.wx_temp = wx.temp ?? null;
              console.log('[EditModal] Assigned wx_temp:', newCatch.wx_temp, '(from wx.temp:', wx.temp, ')');
              newCatch.wx_wind_speed = wx.wind_speed ?? null;
              console.log('[EditModal] Assigned wx_wind_speed:', newCatch.wx_wind_speed, '(from wx.wind_speed:', wx.wind_speed, ')');
              newCatch.wx_wind_deg = wx.wind_deg ?? null;
              console.log('[EditModal] Assigned wx_wind_deg:', newCatch.wx_wind_deg, '(from wx.wind_deg:', wx.wind_deg, ')');
              newCatch.wx_main = wx.weather_main ?? null;
              console.log('[EditModal] Assigned wx_main:', newCatch.wx_main, '(from wx.weather_main:', wx.weather_main, ')');
              newCatch.wx_desc = wx.weather_description ?? null;
              console.log('[EditModal] Assigned wx_desc:', newCatch.wx_desc, '(from wx.weather_description:', wx.weather_description, ')');
              console.log('[EditModal] Weather fields assignment complete. newCatch weather fields:', {
                wx_temp: newCatch.wx_temp,
                wx_wind_speed: newCatch.wx_wind_speed,
                wx_wind_deg: newCatch.wx_wind_deg,
                wx_main: newCatch.wx_main,
                wx_desc: newCatch.wx_desc
              });
            } else {
              console.warn('[EditModal] fetchWeather returned falsy:', wx);
            }
          } catch (ex) {
            console.warn('[EditModal] Weather fetch failed:', ex?.message || ex);
          }
        } else {
          console.log('[EditModal] Skipping weather fetch - lat or lng not a number');
        }
        console.log('[EditModal] Before draft.catches.push, newCatch:', newCatch);
        
        // ★修正：前で既に定義した editFormSection, isEditing, editingIndex を使用
        // (再定義しない)
        
        if (isEditing && editingIndex >= 0 && editingIndex < draft.catches.length) {
          // ★編集モード：既存釣果を上書き
          const existingCatch = draft.catches[editingIndex];
          newCatch.id = existingCatch.id;  // IDは保持
          draft.catches[editingIndex] = newCatch;
          console.log('[EditModal] Catch updated at index:', editingIndex, newCatch);
        } else {
          // ★追加モード：新規釣果を追加
          draft.catches.push(newCatch);
          console.log('[EditModal] Catch added with tide completion:', newCatch);
        }
        
        saveDraft(draft);
        
        // ★修正：編集フラグをリセット（次回作成を防ぐ）
        const formSection = document.getElementById('editCatchFormSection');
        if (formSection) {
          formSection.dataset.isEditing = 'false';
          formSection.dataset.editingIndex = '-1';
        }
        
        // フォームをクリアして隠す
        document.getElementById('editFormCatchTime').value = '';
        document.getElementById('editFormCatchSpecies').value = '';
        document.getElementById('editFormCatchSize').value = '';
        document.getElementById('editFormCatchWeight').value = '';
        document.getElementById('editFormCatchMethod').value = '';
        document.getElementById('editFormCatchPhoto').value = '';
        const photoPreview = document.getElementById('editFormCatchPhotoPreview');
        if (photoPreview) {
          photoPreview.classList.add('hidden');
          photoPreview.src = '';
        }
        if (formSection) {
          formSection.classList.add('hidden');
        }
        
        // 釣果リストを再描画
        const renderEditCatchListLocal = () => {
          const cts = draft.catches || [];
          const editCatchList = document.getElementById('editCatchList');
          const editCatchCount = document.getElementById('editCatchCount');
          editCatchList.innerHTML = '';
          editCatchCount.textContent = cts.length;

          cts.forEach((c, i) => {
            // ★修正：既に正規化されたオブジェクト形式なので直接使用
            const catchObjTemp = c;

            const itemTemp = document.createElement('div');
            itemTemp.className = 'bg-slate-800 rounded-lg p-3 flex items-start justify-between';

            const contentTemp = document.createElement('div');
            contentTemp.className = 'flex-1 cursor-pointer hover:bg-slate-700/30 rounded p-1 transition';
            
            let timeStrTemp = '';
            if (catchObjTemp.timestamp) {
              const d = new Date(catchObjTemp.timestamp);
              timeStrTemp = `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}:${String(d.getSeconds()).padStart(2,'0')}`;
            }
            
            const tideInfoTemp = [];
            if (catchObjTemp.tide_trend) tideInfoTemp.push(catchObjTemp.tide_trend);
            if (catchObjTemp.tide_level_cm != null) tideInfoTemp.push(catchObjTemp.tide_level_cm + ' cm');
            const tideStrTemp = tideInfoTemp.length > 0 ? tideInfoTemp.join(' ') : '';
            
            contentTemp.innerHTML = `
              <div class="font-semibold text-slate-100 text-sm">${catchObjTemp.species || '(魚種未設定)'} ${catchObjTemp.size_cm ? catchObjTemp.size_cm + ' cm' : ''}</div>
              <div class="text-slate-400 text-xs mt-1">${timeStrTemp}</div>
              ${tideStrTemp ? `<div class="text-slate-300 text-xs mt-1">${tideStrTemp}</div>` : ''}
            `;

            // ★追加：編集ボタン
            const btnEditTemp = document.createElement('button');
            btnEditTemp.className = 'text-xs py-1 px-2 rounded bg-blue-900 hover:bg-blue-800 text-blue-200 ml-2';
            btnEditTemp.textContent = '編集';
            btnEditTemp.onclick = (e) => {
              e.stopPropagation();
              // 編集フォームにデータを展開
              const editFormSection = document.getElementById('editCatchFormSection');
              const editFormTime = document.getElementById('editFormCatchTime');
              const editFormSpecies = document.getElementById('editFormCatchSpecies');
              const editFormSize = document.getElementById('editFormCatchSize');
              const editFormWeight = document.getElementById('editFormCatchWeight');
              const editFormMethod = document.getElementById('editFormCatchMethod');
              
              // ★追加：編集中のインデックスを保存（更新時に使用）
              editFormSection.dataset.editingIndex = i;
              editFormSection.dataset.isEditing = 'true';
              
              // 既存データを展開
              if (catchObjTemp.timestamp) {
                // ★修正：toLocalInputValue 関数を使用（ローカルタイムゾーン対応）
                try {
                  const dt = new Date(catchObjTemp.timestamp);
                  editFormTime.value = toLocalInputValue(dt);
                  console.log('[TripEdit] timestamp converted:', {
                    original: catchObjTemp.timestamp,
                    formatted: editFormTime.value
                  });
                } catch (e) {
                  console.warn('[TripEdit] timestamp parse failed:', e);
                  editFormTime.value = '';
                }
              } else {
                editFormTime.value = '';
              }
              editFormSpecies.value = catchObjTemp.species || '';
              editFormSize.value = catchObjTemp.size_cm ? String(catchObjTemp.size_cm) : '';
              editFormWeight.value = catchObjTemp.weight_g ? String(catchObjTemp.weight_g) : '';
              editFormMethod.value = catchObjTemp.method || '';
              
                // ★追加：写真フィールドを表示（編集時でも写真変更可能に）
                const photoLabel = document.querySelector('label:has(#editFormCatchPhoto)');
                if (photoLabel) photoLabel.classList.remove('hidden');
                
                // フォームセクションを表示
                editFormSection.classList.remove('hidden');
              // 保存ボタンのテキストを変更
              document.getElementById('btnSaveCatchFormInEdit').textContent = '更新';
              
              // フォームにスクロール
              editFormSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
              
              console.log('[TripEdit] Editing catch at index:', i, 'data:', catchObjTemp);
            };

            const btnDeleteTemp = document.createElement('button');
            btnDeleteTemp.className = 'text-xs py-1 px-2 rounded bg-red-900 hover:bg-red-800 text-red-200 ml-2';
            btnDeleteTemp.textContent = '削除';
            btnDeleteTemp.onclick = (e) => {
              e.stopPropagation();
              if (confirm('この釣果を削除しますか？')) {
                draft.catches.splice(i, 1);
                saveDraft(draft);
                renderEditCatchListLocal();
              }
            };

            itemTemp.appendChild(contentTemp);
            itemTemp.appendChild(btnEditTemp);
            itemTemp.appendChild(btnDeleteTemp);
            editCatchList.appendChild(itemTemp);
          });
        };
        renderEditCatchListLocal();
      };
    }
    if (btnSaveTripEdit) {
      btnSaveTripEdit.onclick = async (e) => {
        console.log('[btnSaveTripEdit] clicked', { isUploading });
        // ★修正：ボタンクリック時に最初に操作ブロック＆オーバーレイ表示
        if (isUploading) {
          console.log('[btnSaveTripEdit] already uploading, returning');
          return;
        }
        
        console.log('[btnSaveTripEdit] calling showUploadingOverlay');
        showUploadingOverlay('保存中...');
        
        // ★追加：モーダル内のすべてのボタンと入力を無効化
        const tripEditModalContent = tripEditModal.querySelector('div.w-full');
        console.log('[btnSaveTripEdit] tripEditModalContent:', !!tripEditModalContent);
        if (tripEditModalContent) {
          const buttons = tripEditModalContent.querySelectorAll('button, input, textarea');
          console.log('[btnSaveTripEdit] disabling', buttons.length, 'elements');
          buttons.forEach(btn => {
            btn.disabled = true;
            btn.style.opacity = '0.5';
            btn.style.pointerEvents = 'none';
          });
        }
        
        console.log('[btnSaveTripEdit] waiting for requestAnimationFrame');
        await new Promise(resolve => requestAnimationFrame(resolve));
        
        console.log('[btnSaveTripEdit] calling submitTripEditData');
        // その後で実際の処理を実行
        try {
          await submitTripEditData();
          console.log('[btnSaveTripEdit] submitTripEditData completed');
        } catch (e) {
          console.error('[btnSaveTripEdit] error:', e);
          hideUploadingOverlay();
          // ★追加：エラー時もボタンを再度有効化
          if (tripEditModalContent) {
            const buttons = tripEditModalContent.querySelectorAll('button, input, textarea');
            buttons.forEach(btn => {
              btn.disabled = false;
              btn.style.opacity = '1';
              btn.style.pointerEvents = 'auto';
            });
          }
        }
      };
    }

    // ★追加：釣行編集データを上書き保存
    async function submitTripEditData() {
      // ★追加：保存時に Trips シートから全データを再度取得して draft に反映（未編集データの喪失を防ぐ）
      try {
        const headers = tripsCache[0];
        const col = {};
        for (let i = 0; i < headers.length; i++) {
          col[String(headers[i]).trim()] = i;
        }
        const tripRow = tripsCache.find((t, idx) => idx > 0 && String(t[col.tripId]) === String(draft.tripId));
        
        if (tripRow) {
          // 元データから全カラムを draft に反映
          draft.status = tripRow[col.status] || draft.status || 'ended';
          
          // 天気データ（開始・終了）を全て引き継ぐ
          if (tripRow[col.start_weather_main]) {
            draft.start_weather = {
              temp: parseFloat(tripRow[col.start_temp]) || null,
              wind_speed: parseFloat(tripRow[col.start_wind_speed]) || null,
              wind_deg: parseFloat(tripRow[col.start_wind_deg]) || null,
              weather_main: tripRow[col.start_weather_main] || '',
              weather_description: tripRow[col.start_weather_desc] || ''
            };
          }
          if (tripRow[col.end_weather_main]) {
            draft.end_weather = {
              temp: parseFloat(tripRow[col.end_temp]) || null,
              wind_speed: parseFloat(tripRow[col.end_wind_speed]) || null,
              wind_deg: parseFloat(tripRow[col.end_wind_deg]) || null,
              weather_main: tripRow[col.end_weather_main] || '',
              weather_description: tripRow[col.end_weather_desc] || ''
            };
          }
          
          // 水温データを引き継ぐ
          if (tripRow[col.water_temp_c]) {
            draft.start_water_temp = {
              temperature_c: parseFloat(tripRow[col.water_temp_c]) || null,
              point_name: String(tripRow[col.water_temp_point] || '') || null,
              date: tripRow[col.water_temp_time] || null
            };
          }
          
          // 潮汐データを引き継ぐ
          let start_tide = null;
          if (col.raw_json >= 0) {
            const rawJson = tripRow[col.raw_json];
            try {
              if (rawJson) {
                const raw = typeof rawJson === 'string' ? JSON.parse(rawJson) : rawJson;
                start_tide = raw?.start_tide || null;
              }
            } catch (e) {
              // パース失敗時は start_tide = null
            }
          }
          if (start_tide) {
            draft.start_tide = start_tide;
          }
          
          // その他の補完用カラム
          draft.weather = tripRow[col.start_weather_main] || draft.weather || null;
          draft.tide_trend = tripRow[col.tide_trend] || draft.tide_trend || null;
          draft.tide_level_cm = tripRow[col.tide_level_cm] ? parseFloat(tripRow[col.tide_level_cm]) : (draft.tide_level_cm || null);
          draft.memo = tripRow[col.memo] || draft.memo || null;
          
          // moon データを引き継ぐ
          if (tripRow[col.moon_v]) draft.moon_v = tripRow[col.moon_v];
          if (tripRow[col.moon_a]) draft.moon_a = tripRow[col.moon_a];
          if (tripRow[col.sunrise]) draft.sunrise = tripRow[col.sunrise];
          if (tripRow[col.sunset]) draft.sunset = tripRow[col.sunset];
        }
      } catch (e) {
        console.error('[TripEdit] Error restoring full trip data:', e);
      }
      
      // 入力値から釣行データを更新
      if (editTripStarted.value) {
        try {
          const dt = new Date(editTripStarted.value.replace(' ', 'T'));
          draft.startedAt = toOffsetIsoLocal(dt);
        } catch (e) {
          alert('開始日時の形式が正しくありません');
          return;
        }
      }

      if (editTripEnded.value) {
        try {
          const dt = new Date(editTripEnded.value.replace(' ', 'T'));
          draft.endedAt = toOffsetIsoLocal(dt);
        } catch (e) {
          alert('終了日時の形式が正しくありません');
          return;
        }
      }

      let lat = parseFloat(editTripLat.value);
      let lng = parseFloat(editTripLng.value);
      if (isFinite(lat) && isFinite(lng)) {
        draft.lat = lat;
        draft.lng = lng;
      }

      // ★追加：メモを draft に反映
      const editTripMemo = document.getElementById('editTripMemo');
      if (editTripMemo) {
        draft.memo = editTripMemo.value || null;
      }

      // ★修正：常に補完データを再取得（位置情報の有無に関わらず）
      const hasPosition = isFinite(lat) && isFinite(lng);
      if (!hasPosition && isFinite(parseFloat(draft.lat)) && isFinite(parseFloat(draft.lng))) {
        lat = parseFloat(draft.lat);
        lng = parseFloat(draft.lng);
      }

      // 有効な位置情報がある場合は補完データを再取得
      if (isFinite(lat) && isFinite(lng)) {
        // ★修正：水温を保持してからリセット
        const preservedWaterTemp = draft.start_water_temp;
        
        // 補完データをリセット
        draft.start_weather = null;
        draft.start_tide = null;
        draft.start_water_temp = null;
        draft.tide_daily_cache = {};
        
        try {
          // 天気を再取得（開始時刻がある場合はその日付で）
          try {
            const weatherTargetDate = draft.startedAt ? new Date(draft.startedAt) : null;
            draft.start_weather = await fetchWeather(lat, lng, weatherTargetDate);
          } catch (weatherErr) {
            draft.start_weather = null;
          }
          
          // 潮汐を再取得（開始時刻がある場合）
          if (draft.startedAt) {
            try {
              const tide = await fetchTideForStart(lat, lng, draft.startedAt);
              draft.start_tide = tide || null;
              if (tide?.chart && tide?.chartDateKey) {
                draft.tide_daily_cache = draft.tide_daily_cache || {};
                draft.tide_daily_cache[tide.chartDateKey] = {
                  harbor: tide.harbor || null,
                  chart: tide.chart
                };
              }
            } catch (tideErr) {
              draft.start_tide = null;
            }
          }
          
          // ★修正：水温は再取得せず、保持した値を復元
          draft.start_water_temp = preservedWaterTemp;
        } catch (e) {
          // Refetch error - continue with whatever data is available
        }
      }

      saveDraft(draft);
      LOG.app('[TripEdit] saved', { tripId: draft.tripId, catches: draft.catches?.length || 0 });

      // ★修正：ボタンハンドラ内でオーバーレイは既に表示されているため、ここからはアップロード処理のみ実行
      try {
        await uploadTripToSpreadsheet(draft);
        alert('釣行データを上書き保存しました');
        
        tripEditModal.style.display = 'none';
        tripEditModal.classList.add('hidden');
        
        showView('trips');
        loadTrips();
        
        draft = { tripId: uuid(), status: 'idle', catches: [], tide_daily_cache: {}, start_water_temp: null, memo: null };
        saveDraft(draft);
        
        // ★修正：モーダルを完全に閉じた後にオーバーレイを隠す
        hideUploadingOverlay();
      } catch (e) {
        // ★修正：エラー時もオーバーレイを隠す
        hideUploadingOverlay();
        alert('アップロードに失敗しました: ' + (e?.message || e));
      }
    }

    // ★修正：釣行データ更新用アップロード関数
    async function uploadTripToSpreadsheet(tripData) {
      try {
        LOG.app('[Upload] starting trip data upload', { 
          tripId: tripData.tripId, 
          catches: Array.isArray(tripData.catches) ? tripData.catches.length : 0 
        });

        // 既存トリップの更新アクションを指定
        const payload = buildTripPayload(tripData, 'update');

        LOG.app('[Upload] payload ready', { 
          action: payload.action,
          payloadSize: JSON.stringify(payload).length 
        });

        // ★修正：手動アップロードと同じ方式で Worker 経由で送信（secrets 保護）
        const workerUrl = CONFIG.API.FISHING_TRIP_API_WORKER + '/api/upload';
        const response = await fetch(workerUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Auth-Token': CONFIG.API.WORKERS_AUTH_TOKEN
          },
          body: JSON.stringify(payload)
        });

        const text = await response.text();
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${text.slice(0,200)}`);
        }

        let result = {};
        try { result = JSON.parse(text); } catch(pe) {}
        
        LOG.app('[Upload] response received', { 
          status: response.status, 
          saved: result.saved,
          images: result.saved?.images || 0
        });

        return { ok: true, message: 'Upload successful', ...result };

      } catch (err) {
        LOG.app('[Upload] error', { error: err?.message || String(err) });
        throw err;
      }
    }

    // ★修正: ホームボタンのセットアップ
    (function setupHomeButtons(){
      const btnManualTrip = document.getElementById('btnManualTripHome');
      const btnAddManualCatch = document.getElementById('homeAddManualCatch');
      
      if (btnManualTrip) {
        btnManualTrip.onclick = openManualTripForm;
      }
      if (btnAddManualCatch) {
        btnAddManualCatch.onclick = openManualCatchForm;
      }
    })();
  </script>
</body>
</html>
