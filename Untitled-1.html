<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0f172a" />
  <meta name="description" content="é‡£è¡Œã®è¨˜éŒ²ã€é‡£æœã®ç®¡ç†ã€æ½®æ±æƒ…å ±ã®è‡ªå‹•å–å¾—ãŒã§ãã‚‹PWAã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³" />
  <link rel="manifest" href="/dev_Fish_Log/manifest.json">
  <link rel="apple-touch-icon" href="/dev_Fish_Log/icon-192.png">
  <link rel="icon" type="image/png" href="/dev_Fish_Log/icon-192.png" sizes="192x192">
  <link rel="icon" type="image/png" href="/dev_Fish_Log/icon-512.png" sizes="512x512">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="FishTrip">
  <title>é‡£è¡Œè¨˜éŒ²ï¼ˆPWAãƒ•ãƒ­ãƒ³ãƒˆ / ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆUIï¼‰</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="min-h-screen bg-slate-950 text-slate-50">
  <header class="sticky top-0 z-10 backdrop-blur bg-slate-950/70 border-b border-slate-800">
    <div class="max-w-4xl mx-auto px-4 py-3">
      <div class="mb-3 text-center">
        <h1 class="text-3xl font-bold">Fishing_Log</h1>
      </div>
      <nav class="flex gap-2 text-sm items-center justify-between">
        <div class="flex gap-2">
          <button id="navHome" class="px-3 py-1.5 rounded-xl border border-slate-700 hover:bg-slate-800">ãƒ›ãƒ¼ãƒ </button>
          <button id="navRecord" class="px-3 py-1.5 rounded-xl bg-emerald-600 hover:bg-emerald-500 font-semibold">é‡£è¡Œã®è¨˜éŒ²</button>
          <button id="navTrips" class="px-3 py-1.5 rounded-xl bg-amber-700 hover:bg-amber-600 font-semibold">é‡£è¡Œã®ç¢ºèª</button>
          <button id="navCatches" class="px-3 py-1.5 rounded-xl bg-sky-700 hover:bg-sky-600 font-semibold">é‡£æœã®ç¢ºèª</button>
        </div>
        <button id="navSettings" class="px-3 py-1.5 rounded-xl hover:bg-slate-700 text-xl">âš™ï¸</button>
      </nav>
    </div>
  </header>

  <!-- â˜…è¿½åŠ ï¼šé‡£è¡Œç·¨é›†ç”¨ãƒ¢ãƒ¼ãƒ€ãƒ«ï¼ˆ<main> ã®å¤–ã«é…ç½®ï¼‰ -->
  <div id="tripEditModal" class="hidden fixed inset-0 z-30 bg-black/60 grid place-items-center p-4">
    <div class="w-full max-w-2xl rounded-2xl bg-slate-900 border border-slate-800 p-4" onclick="event.stopPropagation()">
      <div class="flex items-center justify-between mb-4">
        <h3 class="font-semibold text-lg">é‡£è¡Œãƒ‡ãƒ¼ã‚¿ç·¨é›†</h3>
        <button id="btnCloseTripEdit" class="text-slate-400 hover:text-slate-200">Ã—</button>
      </div>
      
      <div class="space-y-4 max-h-[65vh] overflow-auto">
        <!-- é‡£è¡ŒåŸºæœ¬æƒ…å ± -->
        <div class="border-b border-slate-700 pb-4">
          <h4 class="text-sm font-semibold text-slate-300 mb-3">é‡£è¡Œæƒ…å ±</h4>
          
          <label class="block mb-3"><span class="text-sm text-slate-300">é–‹å§‹æ—¥æ™‚</span>
            <input id="editTripStarted" type="text" placeholder="yyyy-mm-dd hh:mm" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm" />
          </label>
          
          <label class="block mb-3"><span class="text-sm text-slate-300">çµ‚äº†æ—¥æ™‚</span>
            <input id="editTripEnded" type="text" placeholder="yyyy-mm-dd hh:mm" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm" />
          </label>
          
          <label class="block mb-3"><span class="text-sm text-slate-300">é‡£å ´ä½ç½®ï¼ˆç·¯åº¦ï¼‰</span>
            <input id="editTripLat" type="number" step="0.00001" placeholder="34.68173" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm" />
          </label>
          
          <label class="block mb-3"><span class="text-sm text-slate-300">é‡£å ´ä½ç½®ï¼ˆçµŒåº¦ï¼‰</span>
            <input id="editTripLng" type="number" step="0.00001" placeholder="135.18006" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm" />
          </label>

          <label class="block mb-3"><span class="text-sm text-slate-300">ãƒ¡ãƒ¢</span>
            <textarea id="editTripMemo" placeholder="é‡£è¡Œã®ãƒ¡ãƒ¢ã‚’å…¥åŠ›..." class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm h-24 resize-none"></textarea>
          </label>
        </div>

        <!-- è£œå®Œãƒ‡ãƒ¼ã‚¿è¡¨ç¤º -->
        <div class="border-b border-slate-700 pb-4">
          <h4 class="text-sm font-semibold text-slate-300 mb-3">è£œå®Œãƒ‡ãƒ¼ã‚¿</h4>
          
          <div class="grid grid-cols-2 gap-3">
            <div class="bg-slate-950 rounded-lg p-3">
              <div class="text-xs text-slate-500">å¤©æ°—</div>
              <div id="editTripWeather" class="text-sm text-slate-200 mt-1 break-words">æœªè¨­å®š</div>
            </div>
            <div class="bg-slate-950 rounded-lg p-3">
              <div class="text-xs text-slate-500">æ½®æ±</div>
              <div id="editTripTide" class="text-sm text-slate-200 mt-1 break-words">æœªè¨­å®š</div>
            </div>
            <div class="bg-slate-950 rounded-lg p-3">
              <div class="text-xs text-slate-500">æ°´æ¸©</div>
              <div id="editTripWaterTemp" class="text-sm text-slate-200 mt-1 break-words">æœªè¨­å®š</div>
            </div>
          </div>
          
          <!-- â˜…è¿½åŠ ï¼šãƒ‡ãƒ¼ã‚¿å†å–å¾—ãƒœã‚¿ãƒ³ -->
          <button id="btnRefetchCompData" class="mt-3 w-full py-2 rounded-lg bg-slate-700 hover:bg-slate-600 text-sm font-semibold">ğŸ”„ ãƒ‡ãƒ¼ã‚¿å†å–å¾—ï¼ˆå¤©æ°—ãƒ»æ½®æ±ï¼‰</button>
        </div>

        <!-- é‡£æœãƒªã‚¹ãƒˆ -->
        <div class="border-b border-slate-700 pb-4">
          <div class="flex items-center justify-between mb-3">
            <h4 class="text-sm font-semibold text-slate-300">é‡£æœï¼ˆ<span id="editCatchCount">0</span>ä»¶ï¼‰</h4>
            <button id="btnAddCatchInEdit" class="text-xs py-1 px-3 rounded-lg bg-sky-600 hover:bg-sky-500 font-semibold">ï¼‹é‡£æœè¿½åŠ </button>
          </div>
          <div id="editCatchList" class="space-y-2"></div>
        </div>

        <!-- â˜…è¿½åŠ ï¼šç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã®é‡£æœè¿½åŠ ãƒ•ã‚©ãƒ¼ãƒ  -->
        <div id="editCatchFormSection" class="hidden border-b border-slate-700 pb-4">
          <div class="flex items-center justify-between mb-3">
            <h4 class="text-sm font-semibold text-slate-300">é‡£æœã‚’è¿½åŠ </h4>
            <button id="btnCloseCatchFormInEdit" class="text-xs text-slate-400 hover:text-slate-200">é–‰ã˜ã‚‹</button>
          </div>
          
          <div class="space-y-2 max-h-80 overflow-auto">
            <label class="block"><span class="text-xs text-slate-400">æ—¥æ™‚</span>
              <input id="editFormCatchTime" type="text" placeholder="YYYY-MM-DDTHH:MM" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-lg px-2 py-1 text-sm" />
            </label>
            
            <label class="block"><span class="text-xs text-slate-400">é­šç¨®</span>
              <input id="editFormCatchSpecies" type="text" placeholder="ä¾‹ï¼šãƒ’ãƒ©ãƒ¡" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-lg px-2 py-1 text-sm" />
            </label>
            
            <div class="grid grid-cols-2 gap-2">
              <label class="block"><span class="text-xs text-slate-400">ã‚µã‚¤ã‚ºï¼ˆcmï¼‰</span>
                <input id="editFormCatchSize" type="number" inputmode="decimal" placeholder="50" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-lg px-2 py-1 text-sm" />
              </label>
              
              <label class="block"><span class="text-xs text-slate-400">é‡é‡ï¼ˆgï¼‰</span>
                <input id="editFormCatchWeight" type="number" inputmode="decimal" placeholder="500" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-lg px-2 py-1 text-sm" />
              </label>
            </div>
            
            <label class="block"><span class="text-xs text-slate-400">æ–¹æ³•</span>
              <input id="editFormCatchMethod" type="text" placeholder="ä¾‹ï¼šãƒ¡ã‚¿ãƒ«ã‚¸ã‚° 20g" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-lg px-2 py-1 text-sm" />
            </label>
            
            <label class="block"><span class="text-xs text-slate-400">å†™çœŸ</span>
              <input id="editFormCatchPhoto" type="file" accept="image/*" class="mt-1 w-full text-xs" />
              <img id="editFormCatchPhotoPreview" class="hidden mt-2 w-full rounded-lg max-h-40 object-cover" />
            </label>
            
            <div class="flex gap-2 mt-3">
              <button id="btnSaveCatchFormInEdit" class="flex-1 py-1 rounded-lg bg-green-600 hover:bg-green-500 text-xs font-semibold">è¿½åŠ </button>
              <button id="btnCancelCatchFormInEdit" class="flex-1 py-1 rounded-lg bg-slate-700 hover:bg-slate-600 text-xs font-semibold">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            </div>
          </div>
        </div>
      </div>

      <div class="flex gap-2 mt-4">
        <button id="btnCancelTripEdit" class="flex-1 py-2 rounded-xl border border-slate-700 hover:bg-slate-800">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
        <button id="btnSaveTripEdit" class="flex-1 py-2 rounded-2xl bg-purple-600 hover:bg-purple-500 font-semibold">ä¸Šæ›¸ãä¿å­˜</button>
      </div>
    </div>
  </div>

  <main class="max-w-4xl mx-auto px-4 pb-28 pt-4">
    <!-- ãƒ›ãƒ¼ãƒ  -->
    <section id="homeView" class="space-y-4">
      <!-- é‡£è¡Œè¨˜éŒ²ï¼ˆ1åˆ—ã€æœ€ä¸Šæ®µï¼‰ -->
      <div class="rounded-2xl bg-slate-900 border border-slate-800 p-4 flex flex-col gap-3">
        <div class="text-lg font-semibold">é‡£è¡Œã®è¨˜éŒ²</div>
        <button id="homeGoRecord" class="w-full py-8 rounded-xl bg-emerald-600 hover:bg-emerald-500 font-semibold">é‡£è¡Œè¨˜éŒ²</button>
      </div>
      <!-- ç¢ºèªMenu ã¨ ç™»éŒ²Menu ã‚’ç¸¦ä¸¦ã³ã§è¡¨ç¤º -->
      <div class="pt-4"></div>
      <div class="space-y-4">
        <!-- ç¢ºèª -->
        <div class="rounded-2xl bg-slate-900 border border-slate-800 p-4">
          <div class="text-lg font-semibold text-slate-50 mb-3">ç¢ºèª</div>
          <div class="flex flex-row gap-2">
            <button id="homeGoTrips" class="flex-1 py-2 rounded-xl bg-amber-700 hover:bg-amber-600 font-semibold text-sm sm:text-base">é‡£è¡Œã®ç¢ºèª</button>
            <button id="homeGoCatches" class="flex-1 py-2 rounded-xl bg-sky-700 hover:bg-sky-600 font-semibold text-sm sm:text-base">é‡£æœã®ç¢ºèª</button>
          </div>
        </div>
        <!-- ç™»éŒ² -->
        <div class="rounded-2xl bg-slate-900 border border-slate-800 p-4">
          <div class="text-lg font-semibold text-slate-50 mb-3">ç™»éŒ²</div>
          <div class="flex flex-row gap-2">
            <button id="btnManualTripHome" class="flex-1 py-2 rounded-xl bg-amber-700 hover:bg-amber-600 font-semibold text-sm sm:text-base">æ‰‹å‹•ã§é‡£è¡Œã‚’ç™»éŒ²</button>
            <button id="homeAddManualCatch" class="flex-1 py-2 rounded-xl bg-sky-700 hover:bg-sky-600 font-semibold text-sm sm:text-base">æ‰‹å‹•ã§é‡£æœã‚’è¿½åŠ </button>
          </div>
        </div>
      </div>
    </section>

    <!-- â˜…æ–°è¦ï¼šã‚·ãƒ¼ãƒˆè¨­å®šï¼ˆãƒ›ãƒ¼ãƒ ç”»é¢ã®ç›´å¾Œï¼‰ -->
    <section id="settingsView" class="hidden">
      <div class="rounded-2xl bg-slate-900 border border-slate-800 p-4 mb-4">
        <h2 class="text-xl font-semibold">è¨­å®š</h2>
        <p class="text-sm text-slate-400 mt-1">ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆã®è¨­å®š</p>
      </div>

      <!-- ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆ ID è¨­å®šï¼ˆçµ±åˆï¼‰ -->
      <div class="rounded-2xl bg-slate-900 border border-slate-800 p-4 mb-4">
        <h3 class="text-base font-semibold mb-3">ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆ ID</h3>
        <div class="space-y-3">
          <label class="block">
            <span class="text-xs text-slate-400">ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆIDï¼ˆTrips/Catches ä¸¡æ–¹ã§ä½¿ç”¨ï¼‰</span>
            <input id="sheetId" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm" placeholder="ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰ã‚·ãƒ¼ãƒˆID ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„" />
          </label>
          <div class="flex gap-2">
            <button id="btnSaveSheetConfig" class="px-3 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500 font-semibold text-sm">ä¿å­˜</button>
            <div id="sheetConfigStatus" class="text-sm text-slate-300 self-center"></div>
          </div>
        </div>
      </div>
      
      <!-- åˆ—ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆè¨­å®šç”»é¢ã«ç§»å‹•ï¼‰ -->
      <details class="rounded-2xl bg-slate-900 border border-slate-800 p-4 mb-4">
        <summary class="cursor-pointer text-base font-semibold">åˆ—ãƒãƒƒãƒ”ãƒ³ã‚°è¨­å®š</summary>
        <div class="mt-3">
          <div class="grid sm:grid-cols-3 gap-3">
            <label class="block text-sm">å†™çœŸ<select id="mapPhoto" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">æ—¥ä»˜<select id="mapDate" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">æ™‚åˆ»<select id="mapTime" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">é­šç¨®<select id="mapSpecies" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">ã‚µã‚¤ã‚º(cm)<select id="mapSize" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">åœ°ç‚¹å<select id="mapPlace" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">ç·¯åº¦<select id="mapLat" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">çµŒåº¦<select id="mapLng" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">æ½®<select id="mapTideName" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">æ½®ä½<select id="mapTideLevel" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">æ½®ä½å‚¾å‘<select id="mapTideTrend" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">æº€æ½®<select id="mapHighTide" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">å¹²æ½®<select id="mapLowTide" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
            <label class="block text-sm">ãƒ¡ãƒ¢<select id="mapNotes" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm"></select></label>
          </div>
          <div class="mt-3 flex gap-2">
            <button id="btnSaveMapping" class="px-3 py-1.5 rounded-xl bg-sky-600 hover:bg-sky-500 text-sm font-semibold">
              ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ä¿å­˜
            </button>
            <button id="btnResetMapping" class="px-3 py-1.5 rounded-xl border border-slate-700 hover:bg-slate-800 text-sm">
              ä¿å­˜ã‚’ã‚¯ãƒªã‚¢
            </button>
            <span id="mappingStatus" class="text-sm text-slate-300 ml-auto"></span>
          </div>
        </div>
      </details>

      <!-- â˜…è¿½åŠ ï¼šç§˜å¯†æƒ…å ±è¨­å®šï¼ˆãƒˆãƒ¼ã‚¯ãƒ³ãƒ»ã‚­ãƒ¼ï¼‰ -->
      <div class="rounded-2xl bg-slate-900 border border-slate-800 p-4 mb-4">
        <h3 class="text-base font-semibold mb-3">èªè¨¼æƒ…å ±</h3>
        <p class="text-xs text-slate-400 mb-3">API èªè¨¼ã«å¿…è¦ãªç§˜å¯†æƒ…å ±ã‚’è¨­å®šã—ã¦ãã ã•ã„</p>
        <div class="space-y-3">
          <!-- Worker èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ -->
          <label class="block">
            <span class="text-xs text-slate-400">Worker èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³</span>
            <input id="workersAuthTokenEl" type="password" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm" placeholder="Worker èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„" />
          </label>

          <div class="flex gap-2">
            <button id="btnSaveSecrets" class="px-3 py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500 font-semibold text-sm">ä¿å­˜</button>
            <div id="secretsStatus" class="text-sm text-slate-300 self-center"></div>
          </div>
        </div>
      </div>
    </section>

    <!-- é‡£è¡Œã®ç¢ºèªï¼ˆTrips / GVizï¼‰ -->
    <section id="tripsView" class="hidden">
      <div class="rounded-2xl bg-slate-900 border border-slate-800 p-4 mb-4">
        <h2 class="text-base font-semibold">é‡£è¡Œã®ç¢ºèª</h2>
        <div id="tripStatus" class="text-sm text-slate-300 mt-2"></div>
        <div class="mt-3 flex gap-2">
          <button id="btnLoadTrips" class="px-3 py-2 rounded-xl bg-amber-700 hover:bg-amber-600 font-semibold text-sm">èª­è¾¼</button>
          <button id="btnClearTrips" class="px-3 py-2 rounded-xl border border-slate-700 hover:bg-slate-800 text-sm">ã‚¯ãƒªã‚¢</button>
        </div>
      </div>

      <!-- ä¸€è¦§ -->
      <div class="grid grid-cols-1 gap-3" id="tripList"></div>

      <!-- è©³ç´° -->
      <div id="tripDetail" class="hidden mt-4 rounded-2xl bg-slate-900 border border-slate-800 p-4">
        <div class="flex items-center justify-between mb-3">
          <h3 class="font-semibold">é‡£è¡Œã®è©³ç´°</h3>
          <button id="btnCloseTripDetail" class="text-sm px-3 py-1.5 rounded-xl border border-slate-700 hover:bg-slate-800">é–‰ã˜ã‚‹</button>
        </div>
        <div id="tripDetailBody" class="space-y-4"></div>
        <button id="tripEditBtn" class="w-full mt-4 px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded font-semibold text-white text-sm">âœ ç·¨é›†</button>
      </div>
    </section>

    <!-- é‡£æœã®ç¢ºèªï¼ˆGVizï¼‰ -->
    <section id="catchesView" class="hidden">
      <div class="rounded-2xl bg-slate-900 border border-slate-800 p-4 mb-4">
        <h2 class="text-base font-semibold">é‡£æœã®ç¢ºèª</h2>
        <div id="catchesStatus" class="text-sm text-slate-300 mt-2"></div>
        <div class="mt-3 flex gap-2">
          <button id="btnLoadSheet" class="px-3 py-2 rounded-xl bg-sky-600 hover:bg-sky-500 font-semibold text-sm">èª­è¾¼</button>
          <button id="btnClearSheet" class="px-3 py-2 rounded-xl border border-slate-700 hover:bg-slate-800 text-sm">ã‚¯ãƒªã‚¢</button>
        </div>
      </div>

      </div>

        <!-- ä¸€è¦§ -->
        <div class="grid grid-cols-1 gap-3" id="remoteCatchList"></div>

        <!-- è©³ç´°ãƒ‘ãƒãƒ« -->
        <div id="remoteCatchDetail" class="hidden mt-4 rounded-2xl bg-slate-900 border border-slate-800 p-4">
          <div class="flex items-center justify-between mb-3">
            <h3 class="font-semibold">è©³ç´°</h3>
            <button id="btnCloseDetail" class="text-sm px-3 py-1.5 rounded-xl border border-slate-700 hover:bg-slate-800">é–‰ã˜ã‚‹</button>
          </div>
          <div id="detailBody" class="space-y-4"></div>
        </div>
      </section>

    <!-- é‡£è¡Œã®è¨˜éŒ² -->
    <section id="recordView" class="hidden">
      <div class="rounded-2xl bg-slate-900 border border-slate-800 p-4 flex flex-col gap-2 mb-4">
        <div class="flex items-center justify-between">
          <div>
            <div class="text-slate-400 text-sm">ç¾åœ¨ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</div>
            <div id="txtStatus" class="text-xl font-bold">æœªé–‹å§‹</div>
          </div>
          <div class="text-right text-sm text-slate-400">
            <div>Trip ID: <span id="txtTripId">â€”</span></div>
            <div id="txtPos" class="hidden">ä½ç½®: <span id="txtLat"></span>, <span id="txtLng"></span></div>
          </div>
        </div>

        <!-- é–‹å§‹æ™‚é–“ã¨å¤©æ°—ã‚’2ã‚«ãƒ©ãƒ  -->
        <div class="grid grid-cols-2 gap-2 mt-2">
          <div class="rounded-xl bg-slate-800/40 p-3">
            <div class="text-xs text-slate-400">é–‹å§‹</div>
            <div id="txtStartedAt" class="text-sm break-all">â€”</div>
          </div>
          <div id="tripWeatherBoxTop" class="rounded-xl bg-slate-800/40 p-3">
            <div class="text-xs text-slate-400">å¤©æ°—</div>
            <div id="tripWeatherTop" class="text-sm">â€”</div>
          </div>
        </div>

        <!-- æ½®æƒ…å ±ãƒ»æ°´æ¸©ã‚’1ã‚«ãƒ©ãƒ ã§ã¾ã¨ã‚ã‚‹ -->
        <div id="tripWeatherRow" class="grid grid-cols-1 gap-2 mt-2"></div>

        <div id="buttonRow" class="flex gap-2 mt-2"></div>
      </div>

      <section>
        <div class="flex items-baseline gap-3 mb-2">
          <h2 class="text-base font-semibold">é‡£æœ</h2>
          <div id="txtCatchCount" class="text-2xl font-bold text-sky-300">0 ä»¶</div>
        </div>
        <div id="catchListEmpty" class="text-slate-400 text-sm">ã¾ã ç™»éŒ²ãŒã‚ã‚Šã¾ã›ã‚“ã€‚<span id="hintAddWhenActive" class="hidden">ã€Œï¼‹é‡£æœã€ã‹ã‚‰è¿½åŠ ã§ãã¾ã™ã€‚</span></div>
        <ul id="catchList" class="space-y-2"></ul>
      </section>

      <div id="bottomBar" class="hidden fixed bottom-0 left-0 right-0 border-t border-slate-800 bg-slate-950/80 backdrop-blur">
        <div class="max-w-4xl mx-auto px-4 py-3 grid grid-cols-3 gap-2">
          <button id="btnAddCatchBottom" class="py-3 rounded-2xl bg-sky-600 hover:bg-sky-500 font-semibold">ï¼‹é‡£æœ</button>
          <button id="btnCancelTrip" class="py-3 rounded-2xl bg-slate-700 hover:bg-slate-600 font-semibold">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
          <button id="btnEndBottom" class="py-3 rounded-2xl bg-rose-600 hover:bg-rose-500 font-semibold">é‡£è¡Œçµ‚äº†</button>
        </div>
      </div>

      <!-- é‡£æœãƒ¢ãƒ¼ãƒ€ãƒ« -->
      <div id="catchModal" class="hidden fixed inset-0 z-20 bg-black/60 grid place-items-center p-4">
        <div class="w-full max-w-md rounded-2xl bg-slate-900 border border-slate-800 p-4" onclick="event.stopPropagation()">
          <div class="flex items-center justify-between mb-2">
            <h3 id="modalTitle" class="font-semibold">é‡£æœã‚’è¿½åŠ </h3>
            <button id="btnCloseModal" class="text-slate-400 hover:text-slate-200">Ã—</button>
          </div>
          <div class="space-y-3">
            <label class="block"><span class="text-sm text-slate-300">æ™‚åˆ»</span>
              <input id="inpCatchTime" type="text" placeholder="YYYY-MM-DDTHH:MM" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" />
            </label>
            <label class="block"><span class="text-sm text-slate-300">é­šç¨®</span>
              <input id="inpSpecies" type="text" placeholder="ä¾‹ï¼šã‚¢ã‚¸" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" />
            </label>
            <div class="grid grid-cols-2 gap-3">
              <label class="block"><span class="text-sm text-slate-300">ã‚µã‚¤ã‚º(cm)</span>
                <input id="inpSize" type="number" inputmode="decimal" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" />
              </label>
              <label class="block"><span class="text-sm text-slate-300">é‡é‡(g)</span>
                <input id="inpWeight" type="number" inputmode="decimal" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" />
              </label>
            </div>
            <label class="block"><span class="text-sm text-slate-300">æ–¹æ³•ï¼ˆãƒ«ã‚¢ãƒ¼/ãƒªã‚° ç­‰ï¼‰</span>
              <input id="inpMethod" type="text" placeholder="ä¾‹ï¼šãƒ¡ã‚¿ãƒ«ã‚¸ã‚° 20g" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" />
            </label>
            <label class="block"><span class="text-sm text-slate-300">å†™çœŸ</span>
              <input id="inpPhoto" type="file" accept="image/*" class="mt-1 w-full text-sm" />
              <img id="imgPreview" alt="preview" class="hidden mt-2 h-32 w-full object-cover rounded-xl border border-slate-800" />
            </label>
          </div>
          <div class="flex gap-2 mt-4">
            <button id="btnCancelCatch" class="flex-1 py-2 rounded-xl border border-slate-700 hover:bg-slate-800">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            <button id="btnSaveCatch" class="flex-1 py-2 rounded-2xl bg-sky-600 hover:bg-sky-500 font-semibold">ä¿å­˜</button>
          </div>
        </div>
      </div>

      <!-- â˜…è¿½åŠ : æ‰‹å‹•é‡£è¡Œç™»éŒ²ãƒ¢ãƒ¼ãƒ€ãƒ« -->
      <div id="tripModal" class="hidden fixed inset-0 z-20 bg-black/60 grid place-items-center p-4">
        <div class="w-full max-w-lg rounded-2xl bg-slate-900 border border-slate-800 p-4" onclick="event.stopPropagation()">
          <div class="flex items-center justify-between mb-2">
            <h3 class="font-semibold">æ‰‹å‹•ã§é‡£è¡Œã‚’ç™»éŒ²</h3>
            <button id="btnCloseTripModal" class="text-slate-400 hover:text-slate-200">Ã—</button>
          </div>
          <div class="space-y-3">
            <label class="block"><span class="text-sm text-slate-300">é–‹å§‹æ—¥æ™‚ï¼ˆç©ºãªã‚‰EXIFã‹ã‚‰è£œå®Œï¼‰</span>
              <input id="inpTripStart" type="text" placeholder="YYYY-MM-DDTHH:MM" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" />
            </label>
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
              <label class="block">
                <span class="text-sm text-slate-300">ç·¯åº¦ï¼ˆä»»æ„ï¼‰</span>
                <input id="inpTripLat" type="number" step="any" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" />
              </label>
              <label class="block">
                <span class="text-sm text-slate-300">çµŒåº¦ï¼ˆä»»æ„ï¼‰</span>
                <input id="inpTripLng" type="number" step="any" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" />
              </label>
            </div>
            <p class="text-xs text-slate-400">â€» ç·¯åº¦ãƒ»çµŒåº¦ãŒã‚ã‚‹ã¨ã€é–‹å§‹å¤©æ°—ãƒ»é–‹å§‹æ½®æ±ãƒ»æ°´æ¸©ã‚’è‡ªå‹•å–å¾—ã—ã¾ã™ã€‚</p>
          </div>
          <div class="flex gap-2 mt-4">
            <button id="btnCancelTripModal" class="flex-1 py-2 rounded-2xl bg-slate-700 hover:bg-slate-600 font-semibold">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            <button id="btnSaveTrip" class="flex-1 py-2 rounded-2xl bg-indigo-600 hover:bg-indigo-500 font-semibold">ç™»éŒ²</button>
          </div>
        </div>
      </div>


      <!-- é‡£è¡Œã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ« -->
      <div id="uploadReviewModal" class="hidden fixed inset-0 z-30 bg-black/60 grid place-items-center p-4">
        <div class="w-full max-w-lg rounded-2xl bg-slate-900 border border-slate-800 p-4" onclick="event.stopPropagation()">
          <div class="flex items-center justify-between mb-2">
            <h3 class="font-semibold">ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã®ç¢ºèª</h3>
            <button id="btnCloseUploadReview" class="text-slate-400 hover:text-slate-200">Ã—</button>
          </div>
          <div id="uploadReviewBody" class="text-sm text-slate-200 space-y-2 max-h-[45vh] overflow-auto"></div>
          
          <!-- â˜…è¿½åŠ ï¼šãƒ¡ãƒ¢å…¥åŠ›æ¬„ -->
          <div class="mt-4 pt-4 border-t border-slate-800">
            <label class="block">
              <span class="text-sm text-slate-300 mb-2 block">ãƒ¡ãƒ¢ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰</span>
              <textarea id="tripMemoInput" 
                class="w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2 text-sm text-slate-100 placeholder-slate-600"
                placeholder="ã“ã®é‡£è¡Œã«ã¤ã„ã¦ã®ãƒ¡ãƒ¢ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„..."
                rows="3"></textarea>
            </label>
          </div>
          
          <div class="flex gap-2 mt-4">
            <button id="btnCancelUpload" class="flex-1 py-2 rounded-xl border border-slate-700 hover:bg-slate-800">é‡£è¡Œã‚’ç¶šã‘ã‚‹</button>
            <button id="btnConfirmUpload" class="flex-1 py-2 rounded-2xl bg-sky-600 hover:bg-sky-500 font-semibold">ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰</button>
          </div>
        </div>
      </div>

    </section>
  </main>

  <!-- â˜…ä¿®æ­£ï¼šã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’ main ã®å¤–ã«ç§»å‹•ï¼ˆz-index ãŒåŠ¹ãã‚ˆã†ã«ã™ã‚‹ãŸã‚ï¼‰ -->
  <div id="uploadingOverlay" class="hidden fixed inset-0 z-[9999] bg-black/80 flex items-center justify-center" style="pointer-events: auto;">
    <div class="text-center pointer-events-none">
      <div class="mb-4">
        <div class="inline-block">
          <div class="animate-spin rounded-full h-12 w-12 border-4 border-slate-600 border-t-sky-500"></div>
        </div>
      </div>
      <div id="uploadingMessage" class="text-slate-100 text-lg font-semibold">å‡¦ç†ä¸­...</div>
      <div class="text-slate-400 text-sm mt-2">ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„</div>
    </div>
  </div>

  <script>
    // ===== Development: Initialize localStorage for testing =====
    // â˜…ä¿®æ­£ï¼šç§˜å¯†æƒ…å ±ï¼ˆãƒˆãƒ¼ã‚¯ãƒ³ã€ã‚­ãƒ¼ï¼‰ã‚’ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã‹ã‚‰å‰Šé™¤
    const devConfig = {
      // å…¬é–‹æƒ…å ±ã®ã¿ï¼ˆç§˜å¯†æƒ…å ±ã¯è¨­å®šç”»é¢ã§å…¥åŠ›ï¼‰
      'FISHING_TRIP_API_WORKER': 'https://fishing-trip-api.yuji-fallline2999m.workers.dev',
      'WATER_WORKER_URL': 'https://rough-math-5fec.yuji-fallline2999m.workers.dev',
      'CLOUDINARY_CLOUD_NAME': 'drcaeidmm',
      'CLOUDINARY_UPLOAD_PRESET': 'unsigned'
      // â˜…å‰Šé™¤ï¼šWORKER_PROXY_URLï¼ˆä¸è¦ - storage ã‹ã‚‰å–å¾—ï¼‰
      // â˜…å‰Šé™¤ï¼šTIDE_PROXY_URLï¼ˆä¸è¦ - storage ã‹ã‚‰å–å¾—ï¼‰
      // â˜…å‰Šé™¤ï¼šWORKERS_AUTH_TOKENï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¨­å®šç”»é¢ã§å…¥åŠ›ï¼‰
      // â˜…å‰Šé™¤ï¼šRAPIDAPI_KEYï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒè¨­å®šç”»é¢ã§å…¥åŠ›ï¼‰
    };

    // â˜…è¿½åŠ ï¼šãƒ­ãƒ¼ã‚«ãƒ«ãƒ›ã‚¹ãƒˆç’°å¢ƒã‹ã‚’åˆ¤å®š
    const isLocalhost = () => {
      return window.location.hostname === 'localhost' || 
             window.location.hostname === '127.0.0.1' ||
             window.location.hostname === '::1';
    };

    // â˜…ä¿®æ­£ï¼šdevConfig ã‚’å¸¸ã«åˆæœŸåŒ–ï¼ˆisLocalhost ãƒã‚§ãƒƒã‚¯å‰Šé™¤ï¼‰
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼è¨­å®šå¯¾è±¡ã® WORKERS_AUTH_TOKEN ã¯ä¸Šæ›¸ãã—ãªã„
    const initializeDevConfig = async () => {
      for (const [key, value] of Object.entries(devConfig)) {
        const existing = await configStorage.getItem(key);
        if (!existing) {
          await configStorage.setItem(key, value);
          // â˜…è¿½åŠ ï¼šå„ã‚»ãƒƒãƒˆå¾Œã«å¾…æ©Ÿï¼ˆIndexedDB ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å®Œäº†å¾…æ©Ÿï¼‰
          await new Promise(resolve => setTimeout(resolve, 10));
        }
      }
      // â˜…è¿½åŠ ï¼šæœ€å¾Œã«è¿½åŠ ã®å¾…æ©Ÿï¼ˆã™ã¹ã¦ã®ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å®Œäº†ç¢ºèªï¼‰
      await new Promise(resolve => setTimeout(resolve, 50));
    };

    // ===== ã‚¤ãƒ³ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ï¼ˆlocalStorage/IndexedDB ãŒä½¿ç”¨ä¸å¯ãªå ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰ =====
    class MemoryStorage {
      constructor() {
        this.data = {};
      }
      getItem(key) {
        return this.data[key] ?? null;
      }
      setItem(key, value) {
        this.data[key] = value;
      }
      removeItem(key) {
        delete this.data[key];
      }
    }

    // ===== ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ï¼ˆIndexedDB + localStorage + MemoryStorageï¼‰ =====
    class ConfigStorage {
      constructor() {
        this.db = null;
        this.memStorage = new MemoryStorage();
        this.isIndexedDBAvailable = 'indexedDB' in window;
      }

      async init() {
        if (!this.isIndexedDBAvailable) return;
        return new Promise((resolve) => {
          const req = indexedDB.open('FishLogConfig', 1);
          req.onupgradeneeded = (e) => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains('config')) {
              db.createObjectStore('config', { keyPath: 'key' });
            }
          };
          req.onsuccess = () => {
            this.db = req.result;
            resolve();
          };
          req.onerror = () => {
            console.warn('[ConfigStorage] IndexedDB init failed');
            resolve();
          };
        });
      }

      async getItem(key) {
        // IndexedDB ã‹ã‚‰å€¤ã‚’å–å¾—ï¼ˆã‚ˆã‚Šæ–°ã—ã„å¯èƒ½æ€§ãŒã‚ã‚‹ï¼‰
        if (this.db) {
          return new Promise((resolve) => {
            const tx = this.db.transaction('config', 'readonly');
            const req = tx.objectStore('config').get(key);
            req.onsuccess = () => {
              const idbValue = req.result?.value;
              if (idbValue) {
                resolve(idbValue);
                return;
              }
              
              // IndexedDB ã«ãªã‘ã‚Œã° localStorage ã‹ã‚‰å–å¾—
              try {
                const lsValue = localStorage.getItem(key);
                if (lsValue !== null) {
                  // localStorage ã‹ã‚‰å–å¾—ã—ãŸå€¤ã‚’ IndexedDB ã«åŒæœŸ
                  const syncTx = this.db.transaction('config', 'readwrite');
                  syncTx.objectStore('config').put({ key, value: lsValue });
                  // ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ã‚‚åŒæœŸ
                  this.memStorage.setItem(key, lsValue);
                }
                resolve(lsValue);
              } catch (e) {
                console.warn('[ConfigStorage] localStorage unavailable:', e.message);
                // ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰å–å¾—
                const memValue = this.memStorage.getItem(key);
                resolve(memValue || null);
              }
            };
            req.onerror = () => {
              // IndexedDB ã‚¨ãƒ©ãƒ¼æ™‚ã¯ localStorage ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
              try {
                const lsValue = localStorage.getItem(key);
                if (lsValue !== null) {
                  this.memStorage.setItem(key, lsValue);
                }
                resolve(lsValue);
              } catch (e) {
                console.warn('[ConfigStorage] localStorage unavailable:', e.message);
                // ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰å–å¾—
                const memValue = this.memStorage.getItem(key);
                resolve(memValue || null);
              }
            };
          });
        }

        // IndexedDB ãªã—ã®å ´åˆã¯ localStorage ã‹ã‚‰å–å¾—
        try {
          const value = localStorage.getItem(key);
          if (value !== null) {
            this.memStorage.setItem(key, value);
          }
          return value;
        } catch (e) {
          console.warn('[ConfigStorage] localStorage unavailable:', e.message);
          // ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰å–å¾—
          const memValue = this.memStorage.getItem(key);
          return memValue || null;
        }
      }

      async setItem(key, value) {
        let lsSuccess = false;
        
        // localStorage ã«ä¿å­˜ã‚’è©¦ã¿ã‚‹ï¼ˆä½†ã—ã€ã‚¨ãƒ©ãƒ¼ãªã‚‰ç„¡è¦–ï¼‰
        try {
          localStorage.setItem(key, value);
          lsSuccess = true;
        } catch (e) {
          console.warn('[ConfigStorage] localStorage unavailable (skipping):', e.message);
          // localStorage ãŒåˆ©ç”¨ä¸å¯ã§ã‚‚å‡¦ç†ã‚’ç¶šè¡Œ
        }

        // ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«å¸¸ã«ä¿å­˜
        this.memStorage.setItem(key, value);

        // IndexedDB ã«ã‚‚ä¿å­˜ï¼ˆåˆ©ç”¨å¯èƒ½ãªå ´åˆï¼‰
        if (this.db) {
          return new Promise((resolve) => {
            const tx = this.db.transaction('config', 'readwrite');
            const req = tx.objectStore('config').put({ key, value });
            req.onsuccess = () => {
              resolve();
            };
            req.onerror = () => {
              console.warn('[ConfigStorage] IndexedDB save failed');
              resolve();
            };
          });
        } else {
          // IndexedDB ãŒåˆ©ç”¨ä¸å¯ã®å ´åˆã‚‚ Promise ã§è¿”ã™
          return Promise.resolve();
        }
      }

      async removeItem(key) {
        try {
          localStorage.removeItem(key);
        } catch (e) {
          console.warn('[ConfigStorage] localStorage unavailable');
        }

        // ãƒ¡ãƒ¢ãƒªã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰ã‚‚å‰Šé™¤
        this.memStorage.removeItem(key);

        if (this.db) {
          return new Promise((resolve) => {
            const tx = this.db.transaction('config', 'readwrite');
            tx.objectStore('config').delete(key);
            resolve();
          });
        }
      }
    }

    const configStorage = new ConfigStorage();
    
    // ===== Configuration (ç’°å¢ƒå¤‰æ•°ã‹ã‚‰èª­ã¿è¾¼ã¿ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ç”¨) =====
    let CONFIG = {
      API: {
        FISHING_TRIP_API_WORKER: 'https://fishing-trip-api.yuji-fallline2999m.workers.dev',
        WORKERS_AUTH_TOKEN: "",
        WEATHER_WORKER_URL: "",
        TIDE_WORKER_URL: "",
        EXIF_WORKER_URL: "",
        CLOUDINARY_CLOUD_NAME: "drcaeidmm",
        CLOUDINARY_UPLOAD_PRESET: "unsigned"
      },
      TIMEOUT: {
        WEATHER: 10000,
        TIDE: 8000,
        WATER: 8000,
        GAS: 15000
      }
    };

    // â˜…Worker URL å–å¾—ï¼†ä¿å­˜ãƒ­ã‚¸ãƒƒã‚¯
    async function fetchAndSaveWorkerUrls() {
      try {
        // ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ storage ã‹ã‚‰å–å¾—
        const token = await configStorage.getItem('WORKERS_AUTH_TOKEN');
        
        const headers = { 
          'Content-Type': 'application/json'
        };
        
        // ãƒˆãƒ¼ã‚¯ãƒ³ãŒã‚ã‚Œã° X-Auth-Token ãƒ˜ãƒƒãƒ€ãƒ¼ã«è¿½åŠ 
        if (token) {
          headers['X-Auth-Token'] = token;
        }
        
        const response = await fetch(`${CONFIG.API.FISHING_TRIP_API_WORKER}/api/get-worker-urls`, {
          method: 'GET',
          headers: headers
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const data = await response.json();

        // storage ã«ä¿å­˜
        await configStorage.setItem('WORKER_URLS', JSON.stringify(data));

        // CONFIG ã«åæ˜ 
        CONFIG.API.WEATHER_WORKER_URL = data.WEATHER_WORKER_URL || '';
        CONFIG.API.TIDE_WORKER_URL = data.TIDE_WORKER_URL || '';
        CONFIG.API.EXIF_WORKER_URL = data.EXIF_WORKER_URL || '';

      } catch (error) {
        console.error('[fetchAndSaveWorkerUrls] Error:', error);
      }
    }

    // â˜…storage ã‹ã‚‰ Worker URLs ã‚’èª­ã¿è¾¼ã‚€
    async function loadWorkerUrlsFromStorage() {
      try {
        const stored = await configStorage.getItem('WORKER_URLS');
        
        if (stored) {
          const data = typeof stored === 'string' ? JSON.parse(stored) : stored;
          CONFIG.API.WEATHER_WORKER_URL = data.WEATHER_WORKER_URL || '';
          CONFIG.API.TIDE_WORKER_URL = data.TIDE_WORKER_URL || '';
          CONFIG.API.EXIF_WORKER_URL = data.EXIF_WORKER_URL || '';
        } else {
          await fetchAndSaveWorkerUrls();
        }
      } catch (error) {
        console.error('[loadWorkerUrlsFromStorage] Error:', error);
      }
    }

    // éåŒæœŸã§è¨­å®šå€¤ã‚’èª­ã¿è¾¼ã¿
    const loadConfigFromStorage = async () => {
      // â˜…ãƒ‡ãƒãƒƒã‚°ï¼šå„å€¤ã‚’èª­ã¿è¾¼ã‚“ã§ãƒ­ã‚°å‡ºåŠ›
      const val_FISHING_TRIP_API_WORKER = await configStorage.getItem('FISHING_TRIP_API_WORKER');
      CONFIG.API.FISHING_TRIP_API_WORKER = val_FISHING_TRIP_API_WORKER || 'https://fishing-trip-api.yuji-fallline2999m.workers.dev';
      
      const val_WORKERS_AUTH_TOKEN = await configStorage.getItem('WORKERS_AUTH_TOKEN');
      CONFIG.API.WORKERS_AUTH_TOKEN = val_WORKERS_AUTH_TOKEN || "";
      
      // â˜…Worker URL ã‚’ storage ã‹ã‚‰èª­ã¿è¾¼ã‚€ï¼ˆã¾ãŸã¯æ–°è¦å–å¾—ï¼‰
      await loadWorkerUrlsFromStorage();
      
      const val_CLOUDINARY_CLOUD_NAME = await configStorage.getItem('CLOUDINARY_CLOUD_NAME');
      CONFIG.API.CLOUDINARY_CLOUD_NAME = val_CLOUDINARY_CLOUD_NAME || "drcaeidmm";
      
      const val_CLOUDINARY_UPLOAD_PRESET = await configStorage.getItem('CLOUDINARY_UPLOAD_PRESET');
      CONFIG.API.CLOUDINARY_UPLOAD_PRESET = val_CLOUDINARY_UPLOAD_PRESET || "unsigned";
      
      // â˜…è¿½åŠ ï¼šãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ï¼šèª­ã¿è¾¼ã‚“ã å€¤ã‚’è¡¨ç¤º
      
      // ãƒ‡ãƒãƒƒã‚°ï¼šlocalStorage ã¨ IndexedDB ã®å€¤ã‚’æ¯”è¼ƒï¼ˆã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ä»˜ãï¼‰
      try {
        let lsToken = null;
        try {
          lsToken = localStorage.getItem('WORKERS_AUTH_TOKEN');
        } catch (lsError) {
          console.warn('[CONFIG] localStorage unavailable for debugging:', lsError.message);
        }
        
        if (lsToken && CONFIG.API.WORKERS_AUTH_TOKEN && lsToken !== CONFIG.API.WORKERS_AUTH_TOKEN) {
          console.warn('[CONFIG] WARNING: localStorage and loaded token mismatch!');
        }
      } catch (e) {
        console.warn('[CONFIG] Could not compare tokens:', e.message);
      }
    };

    // IndexedDB ã®åˆæœŸåŒ–ã¨è¨­å®šèª­ã¿è¾¼ã¿
    // â˜…ä¿®æ­£ï¼šCONFIGåˆæœŸåŒ–å®Œäº†ãƒ•ãƒ©ã‚°ã¨ Promise
    let CONFIG_INITIALIZED = false;
    const configInitPromise = (async () => {
      await configStorage.init();
      await initializeDevConfig();
      
      // â˜…è¿½åŠ ï¼šinitializeDevConfig() å®Œäº†å¾Œã€IndexedDB ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³å®Œäº†å¾…æ©Ÿ
      await new Promise(resolve => setTimeout(resolve, 100));
      
      await loadConfigFromStorage();
      CONFIG_INITIALIZED = true;
      await initializeSheetId();
      window.dispatchEvent(new Event('CONFIG_READY'));
    })();

    // ===== Logger =====
    const DEBUG_WATER = true; // å¿…è¦ã«å¿œã˜ã¦ true/false ã§å‡ºåŠ›ã‚’åˆ‡æ›¿

    window.LOG = window.LOG || {};
    window.LOG.geo  = window.LOG.geo  || ((...a)=>console.debug("[Geo]", ...a));
    window.LOG.wx   = window.LOG.wx   || ((...a)=>console.warn("[Weather]", ...a));
    window.LOG.app  = window.LOG.app  || ((...a)=>console.debug("[FishLog]", ...a));
    window.LOG.tide = window.LOG.tide || ((...a)=>console.debug("[Tide]", ...a));
    // â˜…è¿½åŠ : æ°´æ¸©å°‚ç”¨ãƒ­ã‚¬ãƒ¼
    window.LOG.wt   = window.LOG.wt   || ((...a)=>console.debug("[WaterTemp]", ...a));

    // ===== ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ =====
    const navHome = document.getElementById('navHome');
    const navRecord = document.getElementById('navRecord');
    const navTrips = document.getElementById('navTrips');            // â˜…è¿½åŠ 
    const navCatches = document.getElementById('navCatches');
    const homeView = document.getElementById('homeView');
    const recordView = document.getElementById('recordView');
    const tripsView = document.getElementById('tripsView');          // â˜…è¿½åŠ 
    const catchesView = document.getElementById('catchesView');
    const settingsView = document.getElementById('settingsView');    // â˜…è¿½åŠ 
    document.getElementById('homeGoRecord').onclick = () => { showView('record'); };
    document.getElementById('homeGoTrips').onclick = () => { showView('trips'); autoLoadTrips(); };   // â˜…è¿½åŠ 
    document.getElementById('homeGoCatches').onclick = () => { showView('catches'); autoLoadCatches(); };
    navHome.onclick = () => showView('home');
    navRecord.onclick = () => showView('record');
    navTrips.onclick = () => { showView('trips'); autoLoadTrips(); };                                  // â˜…è¿½åŠ 
    navCatches.onclick = () => { showView('catches'); autoLoadCatches(); };
    document.getElementById('navSettings').onclick = () => { showView('settings'); };

    // â˜…è¿½åŠ ï¼šãƒ›ãƒ¼ãƒ ã®ã€Œæ‰‹å‹•ã§é‡£æœè¿½åŠ ã€ãƒœã‚¿ãƒ³ï¼ˆid="homeAddManualCatch"ï¼‰ã«ç´ä»˜ã‘
    const btnAddManualFromHome = document.getElementById('homeAddManualCatch');
    btnAddManualFromHome && (btnAddManualFromHome.onclick = openManualCatch);
    function showView(name){
      homeView.classList.toggle('hidden', name !== 'home');
      recordView.classList.toggle('hidden', name !== 'record');
      tripsView.classList.toggle('hidden', name !== 'trips');    // â˜…è¿½åŠ 
      catchesView.classList.toggle('hidden', name !== 'catches');
      settingsView.classList.toggle('hidden', name !== 'settings'); // â˜…è¿½åŠ 
    }
    showView('home');


    // ===== JSTã®ã‚ªãƒ•ã‚»ãƒƒãƒˆä»˜ãISO =====
    function toOffsetIsoLocal(d){
      const pad = n => String(n).padStart(2,'0');
      const y = d.getFullYear();
      const m = pad(d.getMonth()+1);
      const da = pad(d.getDate());
      const hh = pad(d.getHours());
      const mi = pad(d.getMinutes());
      const ss = pad(d.getSeconds());
      const offMin = -d.getTimezoneOffset();
      const sign = offMin >= 0 ? '+' : '-';
      const abs = Math.abs(offMin);
      const oh = pad(Math.floor(abs/60));
      const om = pad(abs%60);
      return `${y}-${m}-${da}T${hh}:${mi}:${ss}${sign}${oh}:${om}`;
    }
    function nowIsoLocal(){ return toOffsetIsoLocal(new Date()); }
    function toLocalInputValue(d){
      const pad = n => String(n).padStart(2,'0');
      return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}`;
    }

    // ===== å¤©æ°—ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ =====
    function windDegToCardinal(deg){
      if (typeof deg !== 'number' || isNaN(deg)) return '';
      const d = ((deg % 360) + 360) % 360;
      const dirs = ['åŒ—','åŒ—åŒ—æ±','åŒ—æ±','æ±åŒ—æ±','æ±','æ±å—æ±','å—æ±','å—å—æ±','å—','å—å—è¥¿','å—è¥¿','è¥¿å—è¥¿','è¥¿','è¥¿åŒ—è¥¿','åŒ—è¥¿','åŒ—åŒ—è¥¿'];
      const idx = Math.round(d / 22.5) % 16;
      return dirs[idx];
    }
    function formatWeatherBrief(wx){
      if (!wx) return '';
      const parts = [];
      const desc = wx.weather_description || wx.weather_main || '';
      if (desc) parts.push(desc);
      if (typeof wx.temp === 'number') parts.push(`${Math.round(wx.temp * 10) / 10}â„ƒ`);
      const sp = (typeof wx.wind_speed === 'number') ? `${Math.round(wx.wind_speed * 10) / 10}m/s` : '';
      const dir = windDegToCardinal(wx.wind_deg);
      if (sp || dir) parts.push(` ${[sp, dir].filter(Boolean).join(' ')}`);
      return parts.join(' / ');
    }

    // ===== OWMï¼ˆé–‹å§‹/çµ‚äº†æ™‚ã®å¤©æ°—ï¼‰- Cloudflare Worker ãƒ—ãƒ­ã‚­ã‚·çµŒç”± =====
    
    // â˜…è¿½åŠ ï¼šJST ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’ Unix ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ï¼ˆç§’ï¼‰ã«å¤‰æ›
    function getJSTTimestampForOWM(date = null){
      if (!date) return Math.floor(Date.now() / 1000); // ç¾åœ¨æ™‚åˆ»
      
      // â˜…ä¿®æ­£ï¼šæ–‡å­—åˆ—ã‹ Date ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚’åˆ¤å®š
      let targetDate;
      if (typeof date === 'string') {
        targetDate = new Date(date);
      } else if (date instanceof Date) {
        targetDate = date;
      } else {
        targetDate = new Date(date);
      }
      
      // date ãŒ 'YYYY-MM-DDTHH:MM:SS+09:00' å½¢å¼ã®å ´åˆã€
      // new Date() ã¯è‡ªå‹•çš„ã« +09:00 ã‚’ UTC ã‚ªãƒ•ã‚»ãƒƒãƒˆã¨ã—ã¦å‡¦ç†ã—ã€
      // UTC ãƒŸãƒªç§’ã‚’è¿”ã™ã€‚ã¤ã¾ã‚Š getTime() ã¯æ—¢ã«æ­£ã—ã„ Unix ãƒŸãƒªç§’
      // ä¾‹ï¼š'2025-11-17T06:49:10+09:00' â†’ getTime() = 2025-11-16T21:49:10Z ã®ãƒŸãƒªç§’
      // ã“ã‚ŒãŒæ­£ã—ã„ Unixã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
      return Math.floor(targetDate.getTime() / 1000);
    }
    
    async function fetchWeather(lat, lng, targetDate = null, timeoutMs = 10000){
      // â˜…ä¿®æ­£ï¼šCONFIGåˆæœŸåŒ–å®Œäº†ã‚’å¾…æ©Ÿï¼ˆAPIå‘¼ã³å‡ºã—å‰ã®å¿…é ˆå‡¦ç†ï¼‰
      await configInitPromise;
      
      // â˜…è¿½åŠ ï¼šstorage ã‹ã‚‰æœ€æ–°ã® Worker URL ã‚’å–å¾—
      try {
        const stored = await configStorage.getItem('WORKER_URLS');
        if (stored) {
          const data = typeof stored === 'string' ? JSON.parse(stored) : stored;
          CONFIG.API.WEATHER_WORKER_URL = data.WEATHER_WORKER_URL || CONFIG.API.WEATHER_WORKER_URL;
        }
      } catch (err) {
        console.warn('[fetchWeather] Failed to load Worker URL from storage:', err);
      }
      
      if (typeof lat !== 'number' || typeof lng !== 'number') throw new Error("åº§æ¨™ãŒæœªè¨­å®šã§ã™");
      
      const jstTimestamp = getJSTTimestampForOWM(targetDate);
      const nowTimestamp = Math.floor(Date.now() / 1000);
      const isHistorical = targetDate !== null && jstTimestamp < nowTimestamp;
      
      // â˜…ãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒœãƒ‡ã‚£ã‚’æ§‹ç¯‰
      const requestBody = {
        lat: lat,
        lng: lng,
        isHistorical: isHistorical,
        dt: isHistorical ? jstTimestamp : undefined
      };
      
      LOG.wx("[fetchWeather] Request to Worker:", {
        lat: lat,
        lng: lng,
        isHistorical: isHistorical,
        dt: isHistorical ? jstTimestamp : "(current)",
        jst_datetime: targetDate ? (typeof targetDate.toISOString === 'function' ? targetDate.toISOString() : String(targetDate)) : new Date().toISOString(),
        workerUrl: CONFIG.API.WEATHER_WORKER_URL
      });
      
      const ctrl = new AbortController();
      const t = setTimeout(() => ctrl.abort("timeout"), timeoutMs);
      try {
        const res = await fetch(CONFIG.API.WEATHER_WORKER_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(requestBody),
          signal: ctrl.signal
        });
        
        if (!res.ok) {
          let msg = `HTTP ${res.status}`;
          try { 
            const err = await res.json(); 
            // â˜…è¿½åŠ ï¼šWorker ã‹ã‚‰ã®ã‚¨ãƒ©ãƒ¼è©³ç´°æƒ…å ±ã‚’è¡¨ç¤º
            if (err?.error) msg += ` - ${err.error}`;
            if (err?.detail) msg += `: ${err.detail}`;
            if (err?.message) msg += `: ${err.message}`;
            console.error("[fetchWeather] Worker error details:", err);
          } catch {}
          console.error("[fetchWeather] Worker returned error:", msg);
          throw new Error(msg);
        }
        
        const j = await res.json();
        
        // â˜…ãƒ­ã‚°ï¼šãƒ¬ã‚¹ãƒãƒ³ã‚¹å€¤
        const data = isHistorical ? (j.data?.[0] || {}) : (j.current || {});
        const rain1h = data.rain?.["1h"];
        const snow1h = data.snow?.["1h"];
        LOG.wx("[fetchWeather] Response:", {
          timestamp_utc: new Date(data.dt * 1000).toISOString(),
          timezone: j.timezone,
          timezone_offset_sec: j.timezone_offset,
          temp: data.temp,
          feels_like: data.feels_like,
          pressure: data.pressure,
          humidity: data.humidity,
          wind_speed: data.wind_speed,
          wind_deg: data.wind_deg,
          wind_gust: data.wind_gust,
          clouds: data.clouds,
          visibility: data.visibility,
          weather_main: data.weather?.[0]?.main,
          weather_description: data.weather?.[0]?.description,
          rain_1h: rain1h,
          snow_1h: snow1h
        });
        
        return mapWeather(j, lat, lng);
      } catch (err) {
        console.error("[fetchWeather] Error:", err);
        throw err;
      } finally { clearTimeout(t); }
    }
    function mapWeather(j, lat, lng){
      // One Call API 3.0 ã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹å½¢å¼
      // timemachine ã®å ´åˆã¯ data[0]ã€current & forecast ã®å ´åˆã¯ current ã‚’ä½¿ç”¨
      const data = j.data?.[0] || j.current || {};
      const w = (data.weather && data.weather[0]) || {};
      const rain1h = data.rain?.["1h"];
      const snow1h = data.snow?.["1h"];
      
      // â˜…ä¿®æ­£ï¼šOne Call API ã®ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³æƒ…å ±ã‚’ä½¿ç”¨
      const utcTimestamp = data.dt; // Unix ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ï¼ˆç§’ã€UTCï¼‰
      const timezoneOffset = j.timezone_offset || 0; // ç§’å˜ä½ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
      const jstTimestamp = utcTimestamp + timezoneOffset;
      
      return {
        timestamp: new Date(jstTimestamp * 1000).toISOString(), // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³æ™‚åˆ»ï¼ˆISOå½¢å¼ï¼‰
        timestamp_jst_unix: jstTimestamp, // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³ã® Unix ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
        timezone: j.timezone, // ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³æ–‡å­—åˆ—ï¼ˆä¾‹ï¼š"Asia/Tokyo"ï¼‰
        timezone_offset_sec: timezoneOffset, // UTC ã‹ã‚‰ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆç§’ï¼‰
        source: "owm:3.0/onecall",
        coord: { lat: lat ?? j.lat ?? null, lng: lng ?? j.lon ?? null },
        temp: data.temp ?? null,
        feels_like: data.feels_like ?? null,
        pressure: data.pressure ?? null,
        humidity: data.humidity ?? null,
        dew_point: data.dew_point ?? null,
        uvi: data.uvi ?? null,
        wind_speed: data.wind_speed ?? null,
        wind_deg: data.wind_deg ?? null,
        wind_gust: data.wind_gust ?? null,
        clouds: data.clouds ?? null,
        visibility: data.visibility ?? null,
        rain_1h: rain1h ?? null,
        snow_1h: snow1h ?? null,
        weather_id: w.id ?? null,
        weather_main: w.main ?? null,
        weather_description: w.description ?? null,
        raw: j
      };
    }

    // â˜…è¿½åŠ ï¼šç·¯åº¦çµŒåº¦ã‹ã‚‰æµ·åŸŸã‚³ãƒ¼ãƒ‰ã‚’å–å¾—ã™ã‚‹ï¼ˆç°¡æ˜“ç‰ˆï¼šç·¯åº¦çµŒåº¦ã®ç¯„å›²ã§åˆ¤å®šï¼‰
    function getSeaAreaCodeFromCoords(lat, lng) {
      // æ—¥æœ¬å‘¨è¾ºã®ä¸»è¦ãªæ¼å ´ã‚³ãƒ¼ãƒ‰ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆçµŒåº¦ãƒ»ç·¯åº¦ã®ç¯„å›²ã§åˆ¤å®šï¼‰
      // å®Ÿéš›ã®ã‚³ãƒ¼ãƒ‰ä½“ç³»ã«åˆã‚ã›ã¦èª¿æ•´ã—ã¦ãã ã•ã„
      const areas = [
        { code: 'hy3004', name: 'ç€¬æˆ¸å†…æµ·æ±éƒ¨', minLat: 33.5, maxLat: 35.5, minLng: 132, maxLng: 135 },
        { code: 'hy3003', name: 'ç€¬æˆ¸å†…æµ·è¥¿éƒ¨', minLat: 33, maxLat: 34.5, minLng: 130, maxLng: 132 },
        { code: 'hy3001', name: 'æ—¥æœ¬æµ·', minLat: 35, maxLat: 43, minLng: 128, maxLng: 141 },
        { code: 'hy3005', name: 'é–¢æ±æ²–', minLat: 33, maxLat: 37, minLng: 140, maxLng: 145 },
      ];
      
      for (const area of areas) {
        if (lat >= area.minLat && lat <= area.maxLat && lng >= area.minLng && lng <= area.maxLng) {
          return area.code;
        }
      }
      
      // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼šç€¬æˆ¸å†…æµ·æ±éƒ¨
      return 'hy3004';
    }

    // â˜…è¿½åŠ ï¼šéå»30æ—¥åˆ†ã®æµ·æ°´æ¸©ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ã€æŒ‡å®šæ—¥ä»˜ã®æ°´æ¸©ã‚’å–å¾—
    async function getWaterTempForDate(lat, lng, targetDate) {
      // â˜…ä¿®æ­£ï¼šCONFIGåˆæœŸåŒ–å®Œäº†ã‚’å¾…æ©Ÿï¼ˆAPIå‘¼ã³å‡ºã—å‰ã®å¿…é ˆå‡¦ç†ï¼‰
      await configInitPromise;
      
      try {
        // targetDate: "2025-11-05" å½¢å¼ã®æ–‡å­—åˆ—
        const code = getSeaAreaCodeFromCoords(lat, lng);
        
        // â˜…ä¿®æ­£ï¼šstorage ã‹ã‚‰æœ€æ–°ã® Worker URL ã‚’å–å¾—ï¼ˆå¿…é ˆï¼‰
        let waterWorkerUrl = CONFIG.API.WATER_WORKER_URL;
        try {
          const stored = await configStorage.getItem('WORKER_URLS');
          if (stored) {
            const data = typeof stored === 'string' ? JSON.parse(stored) : stored;
            if (data.WATER_WORKER_URL) {
              waterWorkerUrl = data.WATER_WORKER_URL;
              CONFIG.API.WATER_WORKER_URL = waterWorkerUrl;
            }
          }
        } catch (err) {
          console.warn('[getWaterTempForDate] Failed to load Worker URL from storage:', err);
        }
        
        if (!waterWorkerUrl || /your[_-]?worker/i.test(waterWorkerUrl)){
          LOG.app("[WaterTemp] past API proxy not configured", { WATER_WORKER_URL: waterWorkerUrl });
          return null;
        }
        
        const baseUrl = `https://leisure-api-prod.n-kishou.co.jp/get-sea-water-temperature?code=${encodeURIComponent(code)}&type=past`;
        const proxyUrl = `${waterWorkerUrl.replace(/\/$/, '')}/proxy?url=${encodeURIComponent(baseUrl)}`;
        
        LOG.app("[WaterTemp] fetching past data via proxy", { code, targetDate, baseUrl, proxyUrl });
        
        const res = await fetch(proxyUrl, { 
          method: 'GET',
          timeout: 10000 
        });
        
        LOG.app("[WaterTemp] past API response status", { status: res.status, ok: res.ok });
        
        if (!res.ok) {
          console.warn(`[WaterTemp] API returned ${res.status}`);
          LOG.app("[WaterTemp] past API returned error status", { status: res.status });
          return null;
        }
        
        const data = await res.json();
        
        // â˜…ä¿®æ­£ï¼šAPIãƒ¬ã‚¹ãƒãƒ³ã‚¹æ§‹é€ ã‚’æ­£ã—ããƒ‘ãƒ¼ã‚¹
        // æ§‹é€ : { result_list: { data: { graph_data_main: [...] } } }
        let dataArray = null;
        
        if (data?.result_list?.data?.graph_data_main && Array.isArray(data.result_list.data.graph_data_main)) {
          // æ­£å¸¸ç³»ï¼šgraph_data_mainé…åˆ—ã‚’å–å¾—
          dataArray = data.result_list.data.graph_data_main;
          LOG.app("[WaterTemp] â˜…extracted graph_data_main array", { 
            length: dataArray.length,
            sampleDate: dataArray[0]?.datetime?.substring(0, 10),
            sampleTemp: dataArray[0]?.temperature
          });
        } else {
          LOG.app("[WaterTemp] past API response structure not as expected", { 
            type: typeof data,
            hasResultList: !!data?.result_list,
            hasData: !!data?.result_list?.data,
            hasGraphDataMain: !!data?.result_list?.data?.graph_data_main,
            isArray: Array.isArray(data?.result_list?.data?.graph_data_main)
          });
          return null;
        }
        
        // â˜…ä¿®æ­£ï¼šdatetime ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‹ã‚‰æ—¥ä»˜ã‚’æŠ½å‡ºã—ã¦ãƒãƒƒãƒãƒ³ã‚°
        // datetime å½¢å¼: "2025-11-05T00:00:00+09:00"
        const matching = dataArray.find(item => {
          if (!item.datetime) return false;
          const itemDate = item.datetime.substring(0, 10);  // "2025-11-05"
          return itemDate === targetDate;
        });
        
        if (matching) {
          const temp = parseFloat(matching.temperature);
          LOG.app("[WaterTemp] â˜…found matching past data for date", {
            date: matching.datetime.substring(0, 10),
            temperature_c: temp
          });
          
          return {
            temperature_c: temp,
            date: matching.datetime.substring(0, 10)
          };
        } else {
          LOG.app("[WaterTemp] no matching date found in past data", { 
            targetDate, 
            dataLength: dataArray.length,
            firstDate: dataArray[0]?.datetime?.substring(0, 10),
            lastDate: dataArray[dataArray.length-1]?.datetime?.substring(0, 10)
          });
          return null;
        }
        
      } catch (ex) {
        console.warn('[WaterTemp] fetch failed:', ex?.message || ex);
        LOG.app("[WaterTemp] past API fetch exception", { error: ex?.message || String(ex) });
        return null;
      }
    }

    // â˜…è¿½åŠ ï¼šæ‰‹å‹•è¿½åŠ ã®å ´åˆã€é–‹å§‹æ—¥ãŒä»Šæ—¥ä»¥å¤–ãªã‚‰éå»ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æ°´æ¸©ã‚’å–å¾—
    async function getWaterTempForManualEntry(lat, lng, startedAtIso, isManual = false) {
      if (!isManual) return null;
      
      const startDate = new Date(startedAtIso);
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      startDate.setHours(0, 0, 0, 0);
      
      LOG.app("[WaterTemp] getWaterTempForManualEntry check", {
        startedAtIso,
        startDateStr: startDate.toISOString().substring(0, 10),
        todayStr: today.toISOString().substring(0, 10),
        isToday: startDate.getTime() === today.getTime()
      });
      
      // é–‹å§‹æ—¥ãŒä»Šæ—¥ä»¥å¤–ãªã‚‰ã€éå»ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å–å¾—
      if (startDate.getTime() !== today.getTime()) {
        const dateStr = startedAtIso.substring(0, 10); // "YYYY-MM-DD"
        LOG.app("[WaterTemp] requesting past data for date", { dateStr });
        const pastData = await getWaterTempForDate(lat, lng, dateStr);
        if (pastData) {
          LOG.app("[WaterTemp] got past data successfully", pastData);
          return pastData;
        } else {
          LOG.app("[WaterTemp] past data not found, will fallback to today");
        }
      } else {
        LOG.app("[WaterTemp] start date is today, will use current temp");
      }
      
      // é–‹å§‹æ—¥ãŒä»Šæ—¥ã€ã¾ãŸã¯éå»ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ null ã‚’è¿”ã™
      // ï¼ˆç¾åœ¨ã®æµ·æ°´æ¸©å–å¾—ãƒ­ã‚¸ãƒƒã‚¯ã«ä»»ã›ã‚‹ï¼‰
      return null;
    }
    const SHEET_NAME = "Catches";
    const TRIPS_SHEET_NAME = "Trips";            // â† è¿½åŠ : Trips ã‚’èª­ã‚€
    const HARBOR_SHEET_NAME = "æ¸¯ã‚³ãƒ¼ãƒ‰ä¸€è¦§";    // â† ã“ã“ã‹ã‚‰æ¸¯ãƒ‡ãƒ¼ã‚¿
    const POINTS_SHEET_NAME = "åœ°ç‚¹ãƒªã‚¹ãƒˆ";      // â˜…è¿½åŠ : æ°´æ¸©åœ°ç‚¹ã®ãƒã‚¹ã‚¿ï¼ˆBuildPointsListãŒä½œã‚‹ï¼‰

    // â˜…ä¿®æ­£ï¼šã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’å»ƒæ­¢ï¼ˆCONFIG ã‹ã‚‰ç›´æ¥èª­ã‚€ã‚ˆã†ã«å¤‰æ›´ï¼‰
    
    // CONFIGåˆæœŸåŒ–å®Œäº†ã‚¤ãƒ™ãƒ³ãƒˆã‚’ãƒªãƒƒã‚¹ãƒ³
    window.addEventListener('CONFIG_READY', () => {
    }); 

    // â˜…ä¿®æ­£ï¼šã‚·ãƒ¼ãƒˆID ã‚’ GAS ã‹ã‚‰å‹•çš„ã«å–å¾—ã™ã‚‹
    let SHEET_ID = ""; // GAS ã‹ã‚‰èµ·å‹•æ™‚ã«å–å¾—
    
    const sheetIdEl = document.getElementById('sheetId');
    const btnSaveSheetConfig = document.getElementById('btnSaveSheetConfig');
    const sheetConfigStatus = document.getElementById('sheetConfigStatus');
    const btnLoadSheet = document.getElementById('btnLoadSheet');
    const btnClearSheet = document.getElementById('btnClearSheet');
    const sheetStatus = document.getElementById('catchesStatus');
    const mappingPanel = document.getElementById('mappingPanel');
    const mapPhoto = document.getElementById('mapPhoto');
    const mapDate = document.getElementById('mapDate');
    const mapTime = document.getElementById('mapTime');
    const mapSpecies = document.getElementById('mapSpecies');
    const mapSize = document.getElementById('mapSize');
    const mapPlace = document.getElementById('mapPlace');
    const mapLat = document.getElementById('mapLat');
    const mapLng = document.getElementById('mapLng');
    const mapTideName = document.getElementById('mapTideName');
    const mapTideLevel = document.getElementById('mapTideLevel');
    const mapTideTrend = document.getElementById('mapTideTrend');
    const mapHighTide = document.getElementById('mapHighTide');
    const mapLowTide = document.getElementById('mapLowTide');
    const mapNotes = document.getElementById('mapNotes');
    // â–¼â–¼ ãƒãƒƒãƒ”ãƒ³ã‚°ä¿å­˜UIã®å‚ç…§ã¨æ°¸ç¶šåŒ–ãƒ˜ãƒ«ãƒ‘ â–¼â–¼
    const btnSaveMapping  = document.getElementById('btnSaveMapping');
    const btnResetMapping = document.getElementById('btnResetMapping');
    const mappingStatus   = document.getElementById('mappingStatus');

    const LS_MAP_KEY_PREFIX = 'fishlog_mapping_v1';
    const mappingKey = () => `${LS_MAP_KEY_PREFIX}:${SHEET_ID}:${SHEET_NAME}`;

    async function readSavedMapping(){
      try { 
        const data = await configStorage.getItem(mappingKey());
        return data ? JSON.parse(data) : null;
      } catch { 
        return null; 
      }
    }
    async function writeSavedMapping(){
      const obj = {
        photo: mapPhoto.value, date: mapDate.value, time: mapTime.value,
        species: mapSpecies.value, size: mapSize.value, place: mapPlace.value,
        lat: mapLat.value, lng: mapLng.value, tideName: mapTideName.value,
        tideLevel: mapTideLevel.value, tideTrend: mapTideTrend.value,
        highTide: mapHighTide.value, lowTide: mapLowTide.value, notes: mapNotes.value
      };
      try {
        await configStorage.setItem(mappingKey(), JSON.stringify(obj));
        if (mappingStatus){ mappingStatus.textContent = 'ä¿å­˜ã—ã¾ã—ãŸ'; setTimeout(()=> mappingStatus.textContent='', 1500); }
      } catch (err) {
        console.warn('[Mapping] Save failed:', err);
      }
    }
    async function applySavedMapping(){
      const s = await readSavedMapping();
      if (!s) return false;
      const set = (el, v) => { if (v != null) el.value = String(v); };
      set(mapPhoto, s.photo); set(mapDate, s.date); set(mapTime, s.time);
      set(mapSpecies, s.species); set(mapSize, s.size); set(mapPlace, s.place);
      set(mapLat, s.lat); set(mapLng, s.lng); set(mapTideName, s.tideName); set(mapTideLevel, s.tideLevel);
      set(mapTideTrend, s.tideTrend); set(mapHighTide, s.highTide); set(mapLowTide, s.lowTide); set(mapNotes, s.notes);
      return true;
    }
    btnSaveMapping  && (btnSaveMapping.onclick  = async () => { await writeSavedMapping(); });
    btnResetMapping && (btnResetMapping.onclick = async () => {
      try {
        await configStorage.removeItem(mappingKey());
        if (mappingStatus){ mappingStatus.textContent = 'ä¿å­˜ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ'; setTimeout(()=> mappingStatus.textContent='', 1500); }
      } catch (err) {
        console.warn('[Mapping] Clear failed:', err);
      }
    });
    
    // â˜…è¿½åŠ ï¼šã‚­ãƒ£ãƒƒã‚·ãƒ¥å¤‰æ•°ã®åˆæœŸåŒ–
    let tripsCache = null;   // Trips ã‚·ãƒ¼ãƒˆã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    let catchesCache = null; // Catches ã‚·ãƒ¼ãƒˆã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    
    const remoteCatchList = document.getElementById('remoteCatchList');
    const detailWrap = document.getElementById('remoteCatchDetail');
    const btnCloseDetail = document.getElementById('btnCloseDetail');

    function gvizPayloadToRows(payload){
      const cols = (payload?.table?.cols || []).map(c => c.label || c.id || '');
      const rows = (payload?.table?.rows || []).map(r => {
        const arr = (r.c || []).map(c => c ? (c.v ?? c.f ?? '') : '');
        while (arr.length < cols.length) arr.push('');
        return arr;
      });
      return [cols, ...rows];
    }
    async function loadSheetViaGAS(sheetName, sheetId = null) {
      try {
        // â˜…è¿½åŠ ï¼šAPIå‘¼ã³å‡ºã—æ™‚ã«æœ€æ–°ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å‹•çš„ã«èª­ã¿è¾¼ã‚€
        const latestToken = await configStorage.getItem('WORKERS_AUTH_TOKEN');
        if (latestToken) {
          CONFIG.API.WORKERS_AUTH_TOKEN = latestToken;
        }
        
        // sheetId ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ SHEET_ID ã‚’ä½¿ç”¨
        const id = (sheetId || SHEET_ID).trim();
        if (!id) throw new Error('Sheet ID ãŒæŒ‡å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
        
        // â˜…ä¿®æ­£ï¼šWorker çµŒç”±ã§ GAS ã«ã‚¢ã‚¯ã‚»ã‚¹ï¼ˆsecrets ä¿è­·ï¼‰
        const workerUrl = CONFIG.API.FISHING_TRIP_API_WORKER + '/api/getSheetData';
        
        const res = await fetch(workerUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Auth-Token': CONFIG.API.WORKERS_AUTH_TOKEN
          },
          body: JSON.stringify({
            sheetId: id,
            sheetName: sheetName
          })
        });
        
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const json = await res.json();
        if (!json.ok) throw new Error(json.error || 'Unknown error');
        return json.data; // [[header...], [row1...], [row2...], ...]
      } catch (err) {
        throw new Error(`Sheet load error (${sheetName}): ${err.message}`);
      }
    }

    function loadGVizViaJSONP(id, sheet, timeoutMs=12000){
      return new Promise((resolve, reject)=>{
        const url = `https://docs.google.com/spreadsheets/d/${id}/gviz/tq?tqx=out:json&sheet=${encodeURIComponent(sheet)}&_=${Date.now()}`;
        const g = (window.google = window.google || {});
        g.visualization = g.visualization || {};
        g.visualization.Query = g.visualization.Query || {};
        const prev = g.visualization.Query.setResponse;
        let settled=false;
        g.visualization.Query.setResponse = (payload)=>{
          if (settled) return; settled=true; cleanup();
          try { resolve(gvizPayloadToRows(payload)); } catch(e){ reject(e); }
        };
        const script=document.createElement('script');
        script.src=url; script.async=true;
        script.onerror=()=>{ if(settled) return; settled=true; cleanup(); reject(new Error('GVizã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸï¼ˆãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯/æ¨©é™ï¼‰')); };
        document.head.appendChild(script);
        const timer=setTimeout(()=>{ if(settled) return; settled=true; cleanup(); reject(new Error('GVizãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆ12ç§’ï¼‰')); }, timeoutMs);
        function cleanup(){ clearTimeout(timer); try{script.remove();}catch{} g.visualization.Query.setResponse = prev; }
      });
    }

    // ===== é‡£æœï¼ˆãƒªãƒ¢ãƒ¼ãƒˆé–²è¦§UIï¼‰ =====
    let lastRows = null;
    let lastHeaders = [];
    let hasLoadedOnce = false;

    // è¿½åŠ : Trips ã®æœˆæƒ…å ±ãƒãƒƒãƒ—
    let tripsById = {}; // { [tripId]: { moon_visual, moon_age, moon_brightness } }

    // â˜…è¿½åŠ ï¼šGAS ã‹ã‚‰ SHEET_ID ã‚’å–å¾—
    async function initializeSheetId() {
      try {
        // â˜…ä¿®æ­£ï¼šWorker çµŒç”±ã§ GAS ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’å‘¼ã³å‡ºã™
        const workerUrl = CONFIG.API.FISHING_TRIP_API_WORKER + '/api/getSheetConfig';
        
        if (!workerUrl || !CONFIG.API.FISHING_TRIP_API_WORKER) {
          console.warn('[Init] FISHING_TRIP_API_WORKER not set');
          return;
        }
        
        const res = await fetch(workerUrl + `?_=${Date.now()}`, {
          method: 'GET',
          headers: {
            'X-Auth-Token': CONFIG.API.WORKERS_AUTH_TOKEN
          }
        });
        
        const json = await res.json();
        
        if (json.ok && json.sheetId) {
          SHEET_ID = json.sheetId;
        } else {
          console.warn('[Init] GAS returned not ok or no sheetId:', json);
        }
      } catch (e) {
        console.warn('[Init] Failed to load SHEET_ID from GAS:', e?.message || e);
      }
    }

    function autoLoadCatches(){ if (!hasLoadedOnce && btnLoadSheet) btnLoadSheet.click(); }

    function parseGVizDate(str){
      if (typeof str !== 'string') return null;
      const m = str.match(/^Date\(([^)]+)\)/);
      if (!m) return null;
      const nums = m[1].split(',').map(n=>parseInt(n.trim(),10));
      if (!nums.length) return null;
      const [y, m0=0, d=1, hh=0, mi=0] = nums;
      const mm = Math.max(1, Math.min(12, m0 + 1));
      return { y, m:mm, d, hh, mi };
    }
    function z2(n){ return String(n).padStart(2,'0'); }
    function formatSheetDateTime(dateCell, timeCell){
      const d1 = parseGVizDate(String(dateCell||''));
      const t1 = parseGVizDate(String(timeCell||''));
      if (d1 || t1){
        const y = d1?.y ?? new Date().getFullYear();
        const m = d1?.m ?? (new Date().getMonth()+1);
        const d = d1?.d ?? new Date().getDate();
        const hh = t1?.hh ?? 0;
        const mi = t1?.mi ?? 0;
        return `${y}/${z2(m)}/${z2(d)} ${z2(hh)}:${z2(mi)}`;
      }
      const dateStr = (dateCell||'').toString().trim();
      const timeStr = (timeCell||'').toString().trim();
      if (dateStr || timeStr){
        const d = dateStr ? new Date(dateStr) : new Date();
        const ok = !isNaN(d.getTime());
        const y = ok ? d.getFullYear() : '';
        const m = ok ? z2(d.getMonth()+1) : '';
        const da = ok ? z2(d.getDate()) : '';
        let hh='00', mi='00';
        if (timeStr){
          const mm = timeStr.match(/(\d{1,2}):(\d{1,2})/);
          if (mm){ hh = z2(mm[1]); mi = z2(mm[2]); }
        }
        const ymd = (y && m && da) ? `${y}/${m}/${da}` : (dateStr||'');
        const hm = timeStr ? `${hh}:${mi}` : '';
        return [ymd, hm].filter(Boolean).join(' ');
      }
      return '';
    }

    document.getElementById('btnLoadSheet').onclick = async () => {
      try {
        const id = SHEET_ID.trim(), sheet = SHEET_NAME.trim();
        sheetStatus.textContent = 'èª­è¾¼ä¸­...';
        remoteCatchList.innerHTML=''; detailWrap.classList.add('hidden');
        if (!id || !sheet) throw new Error('ã‚·ãƒ¼ãƒˆID/ã‚·ãƒ¼ãƒˆåãŒç©ºã§ã™');

        // 1) Trips ã‚’å…ˆã«èª­ã¿ã€tripId â†’ æœˆæƒ…å ±ãƒãƒƒãƒ—ã‚’ä½œã‚‹
        tripsById = await loadTripsMoonMap();

        // 2) Catches ã‚’èª­ã¿è¾¼ã‚€ï¼ˆSHEET_ID ã‚’æ˜ç¤ºçš„ã«æ¸¡ã™ï¼‰
        const rows = await loadSheetViaGAS(sheet, id);
        if (!rows || rows.length < 2){ sheetStatus.textContent='ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆãƒ˜ãƒƒãƒ€+1è¡Œä»¥ä¸ŠãŒå¿…è¦ï¼‰'; hasLoadedOnce=true; return; }
        lastRows = rows; lastHeaders = rows[0];
        setupMapping(lastHeaders);
        renderRemoteList(applyCatchesFilter(mapRowsToItems(rows))); // tripId çµŒç”±ã§æœˆæƒ…å ±ã‚’ä»˜ä¸ã—ã¦æç”»
        sheetStatus.textContent = `èª­ã¿è¾¼ã¿å®Œäº†ï¼š${rows.length-1}ä»¶`;
        hasLoadedOnce = true;
                // â˜…è¿½è¨˜: Catches ãƒ•ã‚£ãƒ«ã‚¿ UIï¼ˆç°¡æ˜“ï¼‰
        (function injectCatchesFilterUI(){
          if (!sheetStatus) return;
          const host = sheetStatus.parentElement; if (!host) return;
          if (document.getElementById('catchesFilterBar')) return;
          const bar = document.createElement('div');
          bar.id = 'catchesFilterBar';
          bar.className = 'mt-2 flex flex-wrap gap-2 text-sm';
          bar.innerHTML = `
            <input id="cfSpecies" placeholder="é­šç¨®ã‚’å«ã‚€" class="px-2 py-1 rounded bg-slate-800 border border-slate-700" />
            <input id="cfMin" type="number" placeholder="ã‚µã‚¤ã‚ºæœ€å°" class="w-28 px-2 py-1 rounded bg-slate-800 border border-slate-700" />
            <input id="cfMax" type="number" placeholder="ã‚µã‚¤ã‚ºæœ€å¤§" class="w-28 px-2 py-1 rounded bg-slate-800 border border-slate-700" />
            <select id="cfSort" class="px-2 py-1 rounded bg-slate-800 border border-slate-700">
              <option value="time_desc">æ–°ã—ã„é †</option>
            </select>
            <button id="cfApply" class="px-2 py-1 rounded border border-slate-700 hover:bg-slate-800">é©ç”¨</button>
          `;
          host.appendChild(bar);
          const apply = ()=>{
            uiFilter.catches.species = document.getElementById('cfSpecies').value.trim();
            uiFilter.catches.sizeMin = document.getElementById('cfMin').value ? Number(document.getElementById('cfMin').value) : null;
            uiFilter.catches.sizeMax = document.getElementById('cfMax').value ? Number(document.getElementById('cfMax').value) : null;
            uiFilter.catches.sort    = document.getElementById('cfSort').value;
            const items = mapRowsToItems(lastRows);
            renderRemoteList(applyCatchesFilter(items));
          };
          document.getElementById('cfApply').onclick = apply;
        })();

      }catch(e){
        console.error('[btnLoadSheet] Error:', e);
        console.error('[btnLoadSheet] Stack:', e.stack);
        sheetStatus.innerHTML = `èª­è¾¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚<span class="text-slate-400">(${e.message||e})</span><br><span class="text-slate-400">å…±æœ‰è¨­å®šã‚’ã€Œãƒªãƒ³ã‚¯ã‚’çŸ¥ã£ã¦ã„ã‚‹å…¨å“¡ï¼ˆé–²è¦§è€…ï¼‰ã€ã«ã—ã€ã‚·ãƒ¼ãƒˆåã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚</span>`;
        hasLoadedOnce = true;
      }
    };
    btnClearSheet && (btnClearSheet.onclick = ()=>{ remoteCatchList.innerHTML=''; detailWrap.classList.add('hidden'); sheetStatus.textContent=''; lastRows=null; lastHeaders=[]; hasLoadedOnce=false; tripsById={}; });
    btnCloseDetail.onclick = ()=> detailWrap.classList.add('hidden');

    function populateSelect(sel, headers){ sel.innerHTML=''; headers.forEach((h,i)=>{ const o=document.createElement('option'); o.value=String(i); o.textContent=h||`åˆ—${i+1}`; sel.appendChild(o); }); }

    function setupMapping(headers){
      const H = headers.map(h => String(h || '').trim());

      // å®Œå…¨ä¸€è‡´ã§åˆ—ç•ªå·å–å¾—
      const idx = (name) => {
        const i = H.findIndex(h => h === name);
        return i >= 0 ? String(i) : null;
      };

      // ãƒ‰ãƒ­ãƒƒãƒ—ãƒ€ã‚¦ãƒ³ã®ä¸­èº«ã¯å¾“æ¥é€šã‚Šç”Ÿæˆ
      const selects=[mapPhoto,mapDate,mapTime,mapSpecies,mapSize,mapPlace,mapLat,mapLng,mapTideName,mapTideLevel,mapTideTrend,mapHighTide,mapLowTide,mapNotes];
      selects.forEach(s=>populateSelect(s, headers));

      // â‘  ã¾ãšãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯ï¼ˆæœ€ä¸‹ä½ã®åˆæœŸå€¤ï¼‰
      const g=guessMapping(headers);
      mapPhoto.value=g.photo; mapDate.value=g.date; mapTime.value=g.time;
      mapSpecies.value=g.species; mapSize.value=g.size; mapPlace.value=g.place;
      mapLat.value=g.lat; mapLng.value=g.lng; mapTideName.value=g.tideName; mapTideLevel.value=g.tideLevel;
      mapTideTrend.value=g.tideTrend; mapHighTide.value=g.highTide; mapLowTide.value=g.lowTide; mapNotes.value=g.notes;

      // â‘¡ å›ºå®šåï¼ˆãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯ã‚ˆã‚Šå„ªå…ˆï¼‰
      const iView = idx('photo_view_url');
      const iThumb= idx('photo_thumb_url');
      const iId   = idx('photo_file_id');
      if (iView)      mapPhoto.value = iView;
      else if (iThumb)mapPhoto.value = iThumb;
      else if (iId)   mapPhoto.value = iId;

      const iTs = idx('timestamp');
      if (iTs){ mapDate.value = iTs; mapTime.value = iTs; }

      const iSp = idx('species');         if (iSp) mapSpecies.value = iSp;
      const iSz = idx('size_cm');         if (iSz) mapSize.value    = iSz;
      const iTN = idx('tide_name');       if (iTN) mapTideName.value  = iTN;
      const iTL = idx('tide_level_cm');   if (iTL) mapTideLevel.value = iTL;
      const iTT = idx('tide_trend');      if (iTT) mapTideTrend.value = iTT;
      const iHH = idx('tide_high_times'); if (iHH) mapHighTide.value  = iHH;
      const iLL = idx('tide_low_times');  if (iLL) mapLowTide.value   = iLL;

      // â‘¢ ä¿å­˜æ¸ˆã¿ï¼ˆæœ€å„ªå…ˆï¼‰â€” ç„¡æ¡ä»¶ã§ä¸Šæ›¸ãé©ç”¨ï¼ˆéåŒæœŸï¼‰
      (async () => {
        await applySavedMapping();
      })();

      // æŠ˜ã‚ŠãŸãŸã¿ã‚’è¡¨ç¤ºçŠ¶æ…‹ã§å‡ºã™ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒä¿å­˜ã§ãã‚‹ã‚ˆã†ã«ï¼‰â€” mappingPanel ãŒå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿
      if (mappingPanel) {
        mappingPanel.classList.remove('hidden');
        mappingPanel.open = false; // æŠ˜ã‚ŠãŸãŸã¿é–‰ã˜
      }

      // å¤‰æ›´æ™‚ã¯å³ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ›´æ–°ï¼ˆä¿å­˜ã¯ãƒœã‚¿ãƒ³ï¼‰
      selects.forEach(s=> s.onchange = ()=> lastRows && renderRemoteList(mapRowsToItems(lastRows)));

      // åˆå›ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼
      lastRows && renderRemoteList(mapRowsToItems(lastRows));
    }

    function guessMapping(headers){
      const L=headers.map(h=>String(h||'')); const lower=L.map(x=>x.toLowerCase());
      const findExact = name => { const i=L.findIndex(x=>x===name); return i>=0?String(i):null; };
      const findAny = keys => { for(let i=0;i<lower.length;i++){ if(keys.some(k=>lower[i].includes(k))) return String(i);} return null; };
      return {
        photo: findExact('å†™çœŸURL')   ?? findAny(['photo','ç”»åƒ','img','url','link']) ?? '0',
        date:  findExact('æ—¥ä»˜')      ?? findAny(['date','æ—¥ä»˜']) ?? '0',
        time:  findExact('æ™‚åˆ»')      ?? findAny(['time','æ™‚åˆ»']) ?? '0',
        species: findExact('é­šç¨®')    ?? findAny(['species','é­šç¨®','fish']) ?? '0',
        size:  findExact('ã‚µã‚¤ã‚º(cm)')?? findAny(['size','cm','ã‚µã‚¤ã‚º']) ?? '0',
        place: findExact('åœ°ç‚¹å')    ?? findAny(['åœ°ç‚¹','å ´æ‰€','point','place','spot']) ?? '0',
        lat:   findExact('ç·¯åº¦')      ?? findAny(['lat','ç·¯åº¦']) ?? '0',
        lng:   findExact('çµŒåº¦')      ?? findAny(['lng','lon','çµŒåº¦']) ?? '0',
        tideName:  findExact('æ½®')    ?? findAny(['æ½®','tide']) ?? '0',
        tideLevel: findExact('æ½®ä½')  ?? findAny(['æ½®ä½','level']) ?? '0',
        tideTrend: findExact('æ½®ä½å‚¾å‘') ?? findAny(['å‚¾å‘','trend']) ?? '0',
        highTide:  findExact('æº€æ½®')  ?? findAny(['æº€æ½®','high']) ?? '0',
        lowTide:   findExact('å¹²æ½®')  ?? findAny(['å¹²æ½®','low']) ?? '0',
        notes: findExact('ãƒ¡ãƒ¢')      ?? findAny(['memo','note','å‚™è€ƒ','ã‚³ãƒ¡ãƒ³ãƒˆ','ãƒ¡ãƒ¢']) ?? '0',
      };
    }

    // è¿½åŠ : Trips ã‹ã‚‰æœˆæƒ…å ±ã‚’èª­ã¿è¾¼ã‚€
    async function loadTripsMoonMap(){
      try{
        // SHEET_ID ãŒæœªè¨­å®šã®å ´åˆã¯å¾…æ©Ÿ
        if (!SHEET_ID) {
          await new Promise(resolve => {
            const check = () => {
              if (SHEET_ID) resolve();
              else setTimeout(check, 100);
            };
            setTimeout(check, 100);
          });
        }
        
        const rows = await loadSheetViaGAS(TRIPS_SHEET_NAME, SHEET_ID);
        if (!rows || rows.length < 2) return {};
        const headers = rows[0].map(h=>String(h||'').trim());
        const idxOf = name => headers.findIndex(h => h === name);

        const iTrip = idxOf('tripId');
        const iMb   = idxOf('moon_brightness');
        const iMa   = idxOf('moon_age');
        const iMv   = idxOf('moon_visual');

        // â˜…è¿½åŠ : æ°´æ¸©ã‚«ãƒ©ãƒ ï¼ˆã‚ã‚Œã°ä½¿ã†ï¼‰
        const iWtC  = idxOf('water_temp_c');
        const iWtP  = idxOf('water_temp_point');
        const iWtT  = idxOf('water_temp_time');

        // â˜…è¿½åŠ : raw_json ã‹ã‚‰ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨
        const iRaw  = idxOf('raw_json');

        const map = {};
        for (let i=1;i<rows.length;i++){
          const r = rows[i];
          const id = r[iTrip] ?? '';
          if (!id) continue;

          // æ—¢å­˜ï¼ˆæœˆæƒ…å ±ï¼‰
          const rec = {
            moon_brightness: r[iMb] ?? '',
            moon_age:        r[iMa] ?? '',
            moon_visual:     r[iMv] ?? ''
          };

          // è¿½åŠ ï¼ˆæ°´æ¸©ï¼‰â€” ã‚«ãƒ©ãƒ ãŒã‚ã‚Œã°å„ªå…ˆ
          if (iWtC>=0 || iWtP>=0 || iWtT>=0){
            rec.water_temp_c    = (iWtC>=0 ? r[iWtC] : '');
            const rawPoint = (iWtP>=0 ? r[iWtP] : '');
            rec.water_temp_point= (iWtP>=0 ? String(r[iWtP]) : '');
            rec.water_temp_time = (iWtT>=0 ? r[iWtT] : '');
          } else if (iRaw>=0 && r[iRaw]) {
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šraw_json.start_water_temp ã‚’è¦‹ã‚‹
            try{
              const raw = JSON.parse(r[iRaw]);
              const wt = raw?.start_water_temp;
              if (wt){
                rec.water_temp_c     = (wt.temperature_c ?? '');
                rec.water_temp_point = (String(wt.point_name ?? ''));
                rec.water_temp_time  = (wt.date ?? '');
              }
            }catch{}
          }

          map[String(id)] = rec;
        }
        return map;
      }catch(e){
        console.warn('[Trips] èª­ã¿è¾¼ã¿ã«å¤±æ•—:', e?.message||e);
        return {};
      }
    }

    function mapRowsToItems(rows){
      // å›ºå®šåˆ—å tripId ã‚’è‡ªå‹•æ¤œå‡ºã—ã¦ç´ä»˜ã‘ï¼ˆUIã«è¿½åŠ ã—ãªã„ï¼‰
      const headers = rows[0].map(h=>String(h||'').trim());
      const tripIdx = headers.findIndex(h => h === 'tripId');

      const get=(r,sel)=>{ const idx=Number(sel.value); return Number.isFinite(idx)&&r[idx]!==undefined ? r[idx] : ''; };
      const out=[];
      for(let i=1;i<rows.length;i++){
        const r=rows[i];
        const tripId = (tripIdx>=0) ? (r[tripIdx] ?? '') : '';
        const tripMoon = tripsById && tripId ? (tripsById[String(tripId)] || null) : null;

        out.push({
        tripId,
        // æ—¢å­˜ãƒãƒƒãƒ”ãƒ³ã‚°
        photo:get(r,mapPhoto), date:get(r,mapDate), time:get(r,mapTime), species:get(r,mapSpecies), size:get(r,mapSize),
        place:get(r,mapPlace), lat:get(r,mapLat), lng:get(r,mapLng), tideName:get(r,mapTideName), tideLevel:get(r,mapTideLevel),
        tideTrend:get(r,mapTideTrend), tide_high_times:get(r,mapHighTide), tide_low_times:get(r,mapLowTide), notes:get(r,mapNotes),
        weight:'', method:'',
        // è¿½åŠ : æœˆæƒ…å ±ï¼ˆTrips ç”±æ¥ï¼‰
        moon_visual: tripMoon?.moon_visual || '',
        moon_age: tripMoon?.moon_age || '',
        moon_brightness: tripMoon?.moon_brightness || '',
        // â˜…è¿½åŠ : æ°´æ¸©ï¼ˆTrips ç”±æ¥ï¼‰
        water_temp_c:     (tripMoon && 'water_temp_c'     in tripMoon) ? tripMoon.water_temp_c : '',
        water_temp_point: (tripMoon && 'water_temp_point' in tripMoon) ? String(tripMoon.water_temp_point || '') : '',
        water_temp_time:  (tripMoon && 'water_temp_time'  in tripMoon) ? tripMoon.water_temp_time  : ''
      });

      }
      return out;
    }

    const DRIVE_THUMB_SZ = 'w1200';
    function resolvePhotoUrl(raw){
      if (!raw) return '';
      let s = String(raw).trim();
      const urlInText = s.match(/https?:\/\/[^\s")]+/i);
      if (urlInText) s = urlInText[0];
      if (/^https?:\/\/(?:lh\d+\.googleusercontent\.com|drive\.google\.com\/thumbnail)/i.test(s)) return s;
      let id = null, resourceKey = null;
      const mFile = s.match(/https?:\/\/drive\.google\.com\/file\/d\/([^/]+)/i);
      if (mFile) id = mFile[1];
      const mId = s.match(/[?&]id=([^&]+)/i);
      if (!id && mId) id = mId[1];
      const mKey = s.match(/[?&]resourcekey=([^&]+)/i);
      if (mKey) resourceKey = mKey[1];
      if (!id && /^[A-Za-z0-9_-]{10,}$/.test(s) && s.indexOf('http') !== 0) id = s;
      if (id){
        let url = `https://drive.google.com/thumbnail?id=${id}&sz=${DRIVE_THUMB_SZ}`;
        if (resourceKey) url += `&resourcekey=${resourceKey}`;
        return url;
      }
      if (s.startsWith('http') || s.startsWith('data:')) return s;
      return '';
    }

    // ãƒãƒƒã‚¸ï¼ˆä¸€è¦§ã¨åŒã˜ãƒˆãƒ¼ãƒ³ï¼‰
    function pill(text, tone){
      const toneMap = {
        sky:     'border-sky-700/60 bg-sky-900/30',
        emerald: 'border-emerald-700/60 bg-emerald-900/30',
        violet:  'border-violet-700/60 bg-violet-900/30',
        slate:   'border-slate-700/60 bg-slate-800/40'
      };
      const cls = toneMap[tone] || toneMap.slate;
      return `<span class="px-2 py-0.5 rounded-full text-[11px] ${cls}">${text}</span>`;
    }

    // ãƒ©ãƒ™ãƒ«:å€¤ ã®è¡Œ
    function kv(label, value){
      if (!value && value !== 0) return '';
      return `<div class="flex justify-between gap-3 text-sm">
        <div class="text-slate-400">${label}</div>
        <div class="text-slate-200 text-right break-all">${value}</div>
      </div>`;
    }

    // ç”»åƒURLæ­£è¦åŒ–ï¼ˆä¸€è¦§ã§ä½¿ã£ã¦ã„ã‚‹ã‚‚ã®ã‚’æµç”¨ï¼‰
    const resolvePhotoUrlDetail = resolvePhotoUrl;

    function renderRemoteList(items){
      // ä¸€è¦§ã‚’æŠ˜ã‚ŠãŸãŸã¿(details)ã«ã—ã€å±•é–‹ä¸­ã¯hoverç„¡åŠ¹ãƒ»æ ç·šã¯å¤–æ ã®ã¿ãƒ»é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ä»˜ã
      remoteCatchList.innerHTML = '';
      detailWrap.classList.add('hidden'); // æ—¢å­˜ã®ç‹¬ç«‹è©³ç´°ãƒ‘ãƒãƒ«ã¯ä½¿ã‚ãªã„

      items.forEach((it)=>{
        // ===== å¤–æ ï¼ˆæŠ˜ã‚ŠãŸãŸã¿ï¼‰ =====
        const wrap = document.createElement('details');
        wrap.className = 'rounded-2xl bg-slate-900 border border-slate-800 mb-2';

        // ===== ã‚µãƒãƒªï¼ˆä¸€è¦§éƒ¨ï¼‰ =====
        const summary = document.createElement('summary');
        summary.className = 'list-none p-3 flex gap-3 items-start cursor-pointer rounded-2xl hover:bg-slate-800/60';

        // ã‚µãƒ ãƒ
        const img = document.createElement('img');
        img.className = 'w-24 h-24 object-cover rounded-xl bg-slate-950';
        img.alt = 'photo';
        img.src = resolvePhotoUrl(it.photo) || '';
        summary.appendChild(img);

        // ãƒ†ã‚­ã‚¹ãƒˆç¾¤
        const info = document.createElement('div');
        info.className = 'flex-1 min-w-0';

        // 1è¡Œç›®ï¼šã‚¿ã‚¤ãƒˆãƒ«ï¼ˆé­šç¨® / ã‚µã‚¤ã‚ºï¼‰
        const rowTitle = document.createElement('div');
        rowTitle.className = 'flex items-center justify-between gap-2';
        const title = document.createElement('div');
        title.className = 'font-semibold truncate text-lg';
        title.textContent = it.species || '(é­šç¨®ä¸æ˜)';
        rowTitle.appendChild(title);
        const sz = document.createElement('span');
        sz.className='text-sm text-slate-300';
        if (it.size !== '' && it.size != null) sz.textContent = String(it.size)+' cm';
        rowTitle.appendChild(sz);
        info.appendChild(rowTitle);

        // 2è¡Œç›®ï¼šæ—¥æ™‚ / åœ°ç‚¹
        const rowMeta = document.createElement('div');
        rowMeta.className = 'mt-1 flex flex-wrap gap-x-4 gap-y-1 text-sm';
        const dtText = formatSheetDateTime(it.date, it.time);
        if (dtText) {
          const wrapMeta = document.createElement('span');
          const val = document.createElement('span');
          val.className = 'text-slate-200';
          val.textContent = dtText;
          wrapMeta.appendChild(val);
          rowMeta.appendChild(wrapMeta);
        }
        if (it.place) {
          const wrapMeta = document.createElement('span');
          const val = document.createElement('span');
          val.className = 'text-slate-200';
          val.textContent = it.place;
          wrapMeta.appendChild(val);
          rowMeta.appendChild(wrapMeta);
        }
        info.appendChild(rowMeta);

        // 3è¡Œç›®ï¼šæ½®ãƒãƒƒã‚¸
        const rowCond = document.createElement('div');
        rowCond.className = 'mt-1 flex flex-wrap items-center gap-2';
        if (it.tideName)  rowCond.insertAdjacentHTML('beforeend',  pill(it.tideName,  'sky'));
        if (it.tideTrend) rowCond.insertAdjacentHTML('beforeend',  pill(it.tideTrend, 'emerald'));
        if (it.tideLevel || it.tideLevel === 0) rowCond.insertAdjacentHTML('beforeend', pill(`${it.tideLevel} cm`, 'violet'));
        info.appendChild(rowCond);

        summary.appendChild(info);
        wrap.appendChild(summary);

        // ===== å±•é–‹éƒ¨ï¼ˆé–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ä»˜ããƒ»å†…å´ã¯æ ç·šãƒŠã‚·ã§ã‚·ãƒ³ãƒ—ãƒ«ï¼‰ =====
        const detail = document.createElement('div');
        detail.className = 'px-3 pb-3';
        detail.innerHTML = `
          <div class="flex items-center justify-between mt-1 mb-2">
            <div class="text-xs text-slate-400">è©³ç´°</div>
            <button type="button" data-role="catch-detail-close"
              class="text-xs px-2 py-1 rounded-lg border border-slate-700 hover:bg-slate-800">
              é–‰ã˜ã‚‹
            </button>
          </div>

          <div class="grid sm:grid-cols-2 gap-4 mt-1">
            <div>
              <img
                src="${resolvePhotoUrlDetail(it.photo) || ''}"
                alt="photo"
                class="w-full h-auto max-h-[70vh] object-contain rounded-xl bg-slate-900"
              />
            </div>
            <div class="space-y-3">
              <div class="rounded-xl bg-slate-800/30 p-3 space-y-1">
                <div class="text-xs text-slate-400">åŸºæœ¬æƒ…å ±</div>
                ${kv('é­šç¨®', it.species || '')}
                ${kv('ã‚µã‚¤ã‚º', (it.size || it.size===0) ? `${it.size} cm` : '')}
                ${kv('é‡é‡', (it.weight || it.weight===0) ? `${it.weight} g` : '')}
                ${kv('æ–¹æ³•', it.method || '')}
              </div>

              ${(it.place || it.lat || it.lng) ? `
                <div class="rounded-xl bg-slate-800/30 p-3 space-y-1">
                  <div class="text-xs text-slate-400">ä½ç½®</div>
                  ${kv('åœ°ç‚¹', it.place || '')}
                  ${kv('ç·¯åº¦', it.lat || '')}
                  ${kv('çµŒåº¦', it.lng || '')}
                </div>` : ''}

              ${(it.tideName || it.tideTrend || (it.tideLevel || it.tideLevel===0) || it.tide_high_times || it.tide_low_times) ? `
                <div class="rounded-xl bg-slate-800/30 p-3 space-y-1">
                  <div class="text-xs text-slate-400">æ½®</div>
                  <div class="flex flex-wrap items-center gap-2 mb-1">
                    ${it.tideName  ? pill(it.tideName, 'sky') : ''}
                    ${it.tideTrend ? pill(it.tideTrend, 'emerald') : ''}
                    ${(it.tideLevel || it.tideLevel===0) ? pill(`${it.tideLevel} cm`, 'violet') : ''}
                  </div>
                  ${kv('æº€æ½®', it.tide_high_times || '')}
                  ${kv('å¹²æ½®', it.tide_low_times  || '')}
                </div>` : ''}

              <!-- â˜…è¿½åŠ : æ°´æ¸©ï¼ˆTripsç”±æ¥ã‚’ it.* ã«å±•é–‹æ¸ˆã¿ï¼‰ -->
              ${(it.water_temp_c!=='' || it.water_temp_point || it.water_temp_time) ? `
                <div class="rounded-xl bg-slate-800/30 p-3 space-y-1">
                  <div class="text-xs text-slate-400">æ°´æ¸©</div>
                  ${kv('æ°´æ¸©', (it.water_temp_c!=='' ? `${it.water_temp_c} â„ƒ` : ''))}
                  ${kv('åœ°ç‚¹', it.water_temp_point || '')}
                </div>` : ''}

              ${it.notes ? `
                <div class="rounded-xl bg-slate-800/30 p-3">
                  <div class="text-xs text-slate-400 mb-1">ãƒ¡ãƒ¢</div>
                  <div class="text-sm text-slate-200 whitespace-pre-line">${it.notes}</div>
                </div>` : ''}

            </div>
          </div>
        `;
        wrap.appendChild(detail);

        // ã€Œé–‰ã˜ã‚‹ã€ãƒœã‚¿ãƒ³ã§ã“ã® details ã‚’é–‰ã˜ã‚‹
        detail.querySelector('[data-role="catch-detail-close"]').onclick = (e)=>{
          e.stopPropagation();
          wrap.open = false;
        };

        // é–‹é–‰ã§ hover ã‚’åˆ¶å¾¡ï¼ˆé–‹ã„ã¦ã„ã‚‹é–“ã¯ hover ç„¡åŠ¹ï¼‰
        wrap.addEventListener('toggle', () => {
          if (wrap.open) summary.classList.remove('hover:bg-slate-800/60');
          else summary.classList.add('hover:bg-slate-800/60');
        });

        remoteCatchList.appendChild(wrap);
      });
    }

    function showDetail(it){
      const wrap = document.getElementById('remoteCatchDetail');
      const body = document.getElementById('detailBody');

      const title = `
        <div class="flex items-start justify-between gap-3">
          <div class="font-semibold text-2xl tracking-tight">${it.species || '(é­šç¨®ä¸æ˜)'}</div>
          <div class="text-slate-200">${(it.size || it.size===0) ? `${it.size} cm` : ''}</div>
        </div>
      `;

      const timeText = formatSheetDateTime(it.date, it.time);
      const meta = `
        <div class="text-sm text-slate-300 flex flex-wrap gap-x-4 gap-y-1">
          ${timeText ? `<span>${timeText}</span>` : ''}
          ${it.place   ? `<span>${it.place}</span>` : ''}
        </div>
      `;

      const cond = `
        <div class="mt-1 flex flex-wrap items-center gap-2">
          ${it.tideName  ? pill(it.tideName, 'sky') : ''}
          ${it.tideTrend ? pill(it.tideTrend, 'emerald') : ''}
          ${(it.tideLevel || it.tideLevel===0) ? pill(`${it.tideLevel} cm`, 'violet') : ''}
        </div>
      `;

      const img = `
        <img
          src="${resolvePhotoUrlDetail(it.photo) || ''}"
          alt="photo"
          class="w-full h-auto max-h-[70vh] object-contain rounded-xl border border-slate-800 bg-slate-900"
        />
      `;

      const basicCard = `
        <div class="rounded-2xl bg-slate-900 border border-slate-800 p-3 space-y-2">
          <div class="text-xs text-slate-400">åŸºæœ¬æƒ…å ±</div>
          ${kv('é­šç¨®', it.species || '')}
          ${kv('ã‚µã‚¤ã‚º', (it.size || it.size===0) ? `${it.size} cm` : '')}
          ${kv('é‡é‡', (it.weight || it.weight===0) ? `${it.weight} g` : '')}
          ${kv('æ–¹æ³•', it.method || '')}
        </div>
      `;

      const posCard = (it.place || it.lat || it.lng) ? `
        <div class="rounded-2xl bg-slate-900 border border-slate-800 p-3 space-y-2">
          <div class="text-xs text-slate-400">ä½ç½®</div>
          ${kv('åœ°ç‚¹', it.place || '')}
          ${kv('ç·¯åº¦', it.lat || '')}
          ${kv('çµŒåº¦', it.lng || '')}
        </div>
      ` : '';

      const tideCard = (it.tideName || it.tideTrend || (it.tideLevel || it.tideLevel===0) || it.tide_high_times || it.tide_low_times) ? `
        <div class="rounded-2xl bg-slate-900 border border-slate-800 p-3 space-y-2">
          <div class="text-xs text-slate-400">æ½®</div>
          <div class="flex flex-wrap items-center gap-2">
            ${it.tideName  ? pill(it.tideName, 'sky') : ''}
            ${it.tideTrend ? pill(it.tideTrend, 'emerald') : ''}
            ${(it.tideLevel || it.tideLevel===0) ? pill(`${it.tideLevel} cm`, 'violet') : ''}
          </div>
          ${kv('æº€æ½®', slashAligned(it.tide_high_times))}
          ${kv('å¹²æ½®', slashAligned(it.tide_low_times))}
        </div>
      ` : '';

      // è¿½åŠ : æœˆæƒ…å ±ã‚«ãƒ¼ãƒ‰ï¼ˆTrips ã‹ã‚‰ï¼‰
      const moonCard = (it.moon_visual || it.moon_age || it.moon_brightness) ? `
        <div class="rounded-2xl bg-slate-900 border border-slate-800 p-3 space-y-2">
          <div class="text-xs text-slate-400">æœˆ</div>
          ${kv('è¦‹ãˆæ–¹', it.moon_visual || '')}
          ${kv('æœˆé½¢', it.moon_age || '')}
        </div>
      ` : '';

      const notesCard = it.notes ? `
        <div class="rounded-2xl bg-slate-900 border border-slate-800 p-3">
          <div class="text-xs text-slate-400 mb-1">ãƒ¡ãƒ¢</div>
          <div class="text-sm text-slate-200 whitespace-pre-line">${it.notes}</div>
        </div>` : '';

      body.innerHTML = `
        ${title}
        ${meta}
        ${cond}
        <div class="grid sm:grid-cols-2 gap-4 mt-2">
          <div>${img}</div>
          <div class="space-y-3">          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt-1 w-full bg-slate-950 border border-slate-700 rounded-xl px-3 py-2" maxlength="16" />          <input id="inpTripStart" type="datetime-local" class="mt
            ${basicCard}
            ${posCard}
            ${tideCard}
            ${moonCard}
          </div>
        </div>
        ${notesCard}
      `;

      wrap.classList.remove('hidden');
      wrap.scrollIntoView({behavior:'smooth', block:'start'});
    }

    // ã€ŒHH:MMï¼HH:MMã€ã‚’ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã§æƒãˆã¦è¡¨ç¤º
    function slashAligned(val){
      if (!val) return '';
      const [aRaw='', bRaw=''] = String(val).split('ï¼');
      const a = (aRaw || '').trim() || 'ï¼';
      const b = (bRaw || '').trim() || 'ï¼';
      // å·¦å³ã‚’åˆ¥ã‚«ãƒ©ãƒ ã€ä¸­å¤®ã«ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã€‚ç­‰å¹…æ•°å­—ã§æ¡æƒãˆ
      return `
        <span class="inline-grid grid-cols-[1fr_auto_1fr] items-baseline gap-1 tabular-nums">
          <span class="text-right">${a}</span>
          <span>ï¼</span>
          <span class="text-left">${b}</span>
        </span>
      `;
    }


    // ===== PWA: Service Worker ç™»éŒ² =====
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/dev_Fish_Log/sw.js', {
          scope: '/dev_Fish_Log/'
        })
          .then(registration => {
          })
          .catch(err => {
            console.warn('[PWA] Service Worker registration failed:', err);
          });
      });
    }

    // ===== PWA: IndexedDB åˆæœŸåŒ– =====
    const DB_NAME = 'FishLogDB';
    const STORE_NAME = 'draftTrips';
    const UPLOAD_QUEUE_STORE = 'uploadQueue';
    let db = null;

    function initIndexedDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, 2); // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ 2 ã«æ›´æ–°

        request.onerror = () => {
          console.warn('[IndexedDB] Open failed');
          reject(request.error);
        };

        request.onsuccess = () => {
          db = request.result;
          resolve(db);
        };

        request.onupgradeneeded = (event) => {
          db = event.target.result;
          // draftTrips ã‚¹ãƒˆã‚¢
          if (!db.objectStoreNames.contains(STORE_NAME)) {
            db.createObjectStore(STORE_NAME, { keyPath: 'tripId' });
          }
          // uploadQueue ã‚¹ãƒˆã‚¢
          if (!db.objectStoreNames.contains(UPLOAD_QUEUE_STORE)) {
            const uploadStore = db.createObjectStore(UPLOAD_QUEUE_STORE, { keyPath: 'id', autoIncrement: true });
            uploadStore.createIndex('tripId', 'tripId', { unique: false });
            uploadStore.createIndex('timestamp', 'timestamp', { unique: false });
          }
        };
      });
    }

    async function saveDraftToIndexedDB(draft) {
      if (!db) return;
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        const request = store.put(draft);

        request.onsuccess = () => {
          resolve();
        };

        request.onerror = () => {
          console.warn('[IndexedDB] Save failed:', request.error);
          reject(request.error);
        };
      });
    }

    async function loadDraftFromIndexedDB(tripId) {
      if (!db) return null;
      return new Promise((resolve) => {
        const tx = db.transaction(STORE_NAME, 'readonly');
        const store = tx.objectStore(STORE_NAME);
        const request = store.get(tripId);

        request.onsuccess = () => {
          if (request.result) {
            resolve(request.result);
          } else {
            resolve(null);
          }
        };

        request.onerror = () => {
          console.warn('[IndexedDB] Load failed:', request.error);
          resolve(null);
        };
      });
    }

    // ===== é‡£è¡Œãƒ‰ãƒ©ãƒ•ãƒˆ =====
    const LS_KEY='fishtrip_draft_v1';
    const uuid = ()=> (crypto?.randomUUID ? crypto.randomUUID() : (Date.now().toString(36)+Math.random().toString(36).slice(2,10)));
    
    // ãƒ‰ãƒ©ãƒ•ãƒˆèª­ã¿è¾¼ã¿ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè£…
    const loadDraft = () => {
      const defaultDraft = { 
        tripId: uuid(), 
        status: 'idle', 
        catches: [], 
        tide_daily_cache: {}, 
        manualStarted: false, 
        updatedAt: new Date().toISOString() 
      };
      
      try {
        // ã€1ã€‘localStorage ã‹ã‚‰å–å¾—ã‚’è©¦ã¿ã‚‹
        const raw = localStorage.getItem(LS_KEY);
        if (raw) {
          const p = JSON.parse(raw);
          return {
            tripId: p.tripId || uuid(),
            status: p.status || 'idle',
            catches: p.catches || [],
            startedAt: p.startedAt,
            endedAt: p.endedAt,
            lat: p.lat,
            lng: p.lng,
            start_weather: p.start_weather,
            end_weather: p.end_weather,
            start_tide: p.start_tide,
            tide_daily_cache: p.tide_daily_cache || {},
            start_water_temp: p.start_water_temp || null,
            manualStarted: !!p.manualStarted,
            updatedAt: p.updatedAt || new Date().toISOString()
          };
        }
      } catch (e) {
        console.warn('[Draft] localStorage load failed:', e.message);
      }
      
      return defaultDraft;
    };
    
    // ãƒ‰ãƒ©ãƒ•ãƒˆä¿å­˜ã®ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰å®Ÿè£…
    const saveDraft = async (d) => {
      d.updatedAt = new Date().toISOString();
      
      // ã€1ã€‘localStorage ã«ä¿å­˜
      try {
        localStorage.setItem(LS_KEY, JSON.stringify(d));
        console.log('[Draft] Saved to localStorage');
      } catch (e) {
        console.warn('[Draft] localStorage save failed (PWA mode?):', e.message);
      }
      
      // ã€2ã€‘IndexedDB ã«ä¿å­˜ï¼ˆéã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ï¼šéåŒæœŸå®Ÿè¡Œï¼‰
      // â˜…ä¿®æ­£ï¼šIndexedDB ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ç«¶åˆã‚’é¿ã‘ã‚‹ãŸã‚ã€éãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°å®Ÿè¡Œ
      saveDraftToIndexedDB(d).catch(err => 
        console.warn('[Draft] IndexedDB save failed (async):', err)
      );
    };
    const fmtLocal = iso => { try{return new Date(iso).toLocaleString();}catch{return 'â€”'}; };

    let draft = loadDraft();
    
    // â˜…è¿½åŠ ï¼šã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰çŠ¶æ…‹ç®¡ç†
    let isUploading = false;
    let uploadingMessage = 'å‡¦ç†ä¸­...';  // â˜…è¿½åŠ ï¼šå‡¦ç†å†…å®¹ã‚’è¡¨ç¤ºã™ã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
    
    // IndexedDB åˆæœŸåŒ–ã¨éåŒæœŸãƒ­ãƒ¼ãƒ‰
    (async () => {
      try {
        await initIndexedDB();
        const idbDraft = await loadDraftFromIndexedDB(draft.tripId);
        if (idbDraft && new Date(idbDraft.updatedAt) > new Date(draft.updatedAt || 0)) {
          console.log('[Init] Using newer IndexedDB version');
          draft = idbDraft;
        }
        if (typeof render === 'function') render();
      } catch (err) {
        console.warn('[Init] Failed to load from IndexedDB:', err);
        if (typeof render === 'function') render();
      }
    })();

    let catchForm = { id: uuid(), timestamp: nowIsoLocal(), species:'', size_cm:null, weight_g:null, method:'', photoPreviewUrl:undefined };
    let editMode=false, editingId=null;
    let manualCatchMode = false;

    // çµ‚äº†ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ«ç”¨
    let pendingEnd = null; // { endedAt: string(JST ISO), end_weather: object|null }

    // DOMå‚ç…§ï¼ˆè¨˜éŒ²ãƒ“ãƒ¥ãƒ¼ï¼‰
    const txtStatus=document.getElementById('txtStatus');
    const txtTripId=document.getElementById('txtTripId');
    const txtPosWrap=document.getElementById('txtPos');
    const txtLat=document.getElementById('txtLat');
    const txtLng=document.getElementById('txtLng');
    const txtStartedAt=document.getElementById('txtStartedAt');
    const txtCatchCount=document.getElementById('txtCatchCount');
    const tripWeatherRow=document.getElementById('tripWeatherRow');
    const buttonRow=document.getElementById('buttonRow');
    const bottomBar=document.getElementById('bottomBar');
    const btnAddCatchBottom=document.getElementById('btnAddCatchBottom');
    const btnEndBottom=document.getElementById('btnEndBottom');

    const catchListEmpty=document.getElementById('catchListEmpty');
    const hintAddWhenActive=document.getElementById('hintAddWhenActive');
    const catchList=document.getElementById('catchList');

    const catchModal=document.getElementById('catchModal');
    const btnCloseModal=document.getElementById('btnCloseModal');
    const btnCancelCatch=document.getElementById('btnCancelCatch');
    const btnSaveCatch=document.getElementById('btnSaveCatch');
    const inpCatchTime=document.getElementById('inpCatchTime');
    const inpSpecies=document.getElementById('inpSpecies');
    const inpSize=document.getElementById('inpSize');
    const inpWeight=document.getElementById('inpWeight');
    const inpMethod=document.getElementById('inpMethod');
    const inpPhoto=document.getElementById('inpPhoto');
    const imgPreview=document.getElementById('imgPreview');
    const modalTitle=document.getElementById('modalTitle');

    // ç”»åƒã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ï¼ˆCONFIG ã‹ã‚‰æ¯å›èª­ã¿è¾¼ã¿ï¼‰

    // â˜…ä¿®æ­£ï¼šSHEET_ID åˆæœŸåŒ–ã¯ loadConfigFromStorage() å®Œäº†å¾Œã«å®Ÿè¡Œã•ã‚Œã‚‹

    // ===== Settings UI æ©Ÿèƒ½ =====
    // åˆæœŸåŒ–ï¼šGAS ã‹ã‚‰èª­ã¿è¾¼ã‚€ãŸã‚ã€åˆæœŸå€¤ã¯ç©ºã«ã—ã¦ãŠã

    // Sheet ID ä¿å­˜é–¢æ•°ï¼ˆçµ±åˆï¼‰
    async function saveSheetConfigToGAS() {
      try {
        // â˜…è¿½åŠ ï¼šAPIå‘¼ã³å‡ºã—æ™‚ã«æœ€æ–°ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å‹•çš„ã«èª­ã¿è¾¼ã‚€
        const latestToken = await configStorage.getItem('WORKERS_AUTH_TOKEN');
        if (latestToken) {
          CONFIG.API.WORKERS_AUTH_TOKEN = latestToken;
        }
        
        const newId = (sheetIdEl?.value || '').trim();
        if (!newId) {
          if (sheetConfigStatus) sheetConfigStatus.textContent = 'ID ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
          return;
        }
        
        // â˜…ä¿®æ­£ï¼šWorker çµŒç”±ã§ GAS ã«é€ä¿¡ï¼ˆsecrets ä¿è­·ï¼‰
        const workerUrl = CONFIG.API.FISHING_TRIP_API_WORKER + '/api/setSpreadsheetId';
        const res = await fetch(workerUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Auth-Token': CONFIG.API.WORKERS_AUTH_TOKEN
          },
          body: JSON.stringify({ spreadsheetId: newId })
        });
        const json = await res.json();
        
        if (json.ok) {
          if (sheetConfigStatus) {
            sheetConfigStatus.textContent = 'âœ“ ä¿å­˜ã—ã¾ã—ãŸ';
            setTimeout(() => { if (sheetConfigStatus) sheetConfigStatus.textContent = ''; }, 2000);
          }
          // é€ä¿¡å¾Œã€å…¥åŠ›å€¤ã‚’ã‚¯ãƒªã‚¢ï¼ˆãƒ•ãƒ­ãƒ³ãƒˆå´ã«ã¯ä¿æŒã—ãªã„ï¼‰
          if (sheetIdEl) sheetIdEl.value = '';
        } else {
          if (sheetConfigStatus) sheetConfigStatus.textContent = 'ã‚¨ãƒ©ãƒ¼: ' + (json.message || 'ä¸æ˜');
        }
      } catch (err) {
        console.error('[Settings] saveSheetConfigToGAS error:', err);
        if (sheetConfigStatus) sheetConfigStatus.textContent = 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
      }
    }

    // ãƒœã‚¿ãƒ³ã®ã‚ªãƒ³ã‚¯ãƒªãƒƒã‚¯è¨­å®š
    if (btnSaveSheetConfig) btnSaveSheetConfig.onclick = saveSheetConfigToGAS;

    // â˜…ä¿®æ­£ï¼šç§˜å¯†æƒ…å ±ï¼ˆãƒˆãƒ¼ã‚¯ãƒ³ãƒ»ã‚­ãƒ¼ï¼‰ã®ä¿å­˜é–¢æ•°ï¼ˆãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸çµŒç”±ï¼‰
    async function saveAuthToken() {
      const token = (document.getElementById('workersAuthTokenEl')?.value || '').trim();
      const status = document.getElementById('secretsStatus');
      
      if (!token) {
        if (status) status.textContent = 'ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
        return;
      }
      
      try {
        // å¤ã„å€¤ã‚’ã‚¯ãƒªã‚¢
        try {
          localStorage.removeItem('WORKERS_AUTH_TOKEN');
        } catch (e) {
          console.warn('[Settings] Failed to clear old token:', e.message);
        }
        
        // æ–°ã—ã„å€¤ã‚’ä¿å­˜
        await configStorage.setItem('WORKERS_AUTH_TOKEN', token);
        
        // â˜…ä¿®æ­£ï¼šstorage ã«ä¿å­˜ã—ãŸã‚‰ã€ã™ãã« CONFIG ã«åæ˜ 
        CONFIG.API.WORKERS_AUTH_TOKEN = token;
        
        // â˜…è¿½åŠ ï¼šToken ä¿å­˜å¾Œã« Worker URL ã‚’å†å–å¾—
        await fetchAndSaveWorkerUrls();
        
        // â˜…è¿½åŠ ï¼šToken ä¿å­˜å¾Œã« SHEET_ID ã‚’å†å–å¾—
        if (status) {
          status.textContent = 'âœ“ ä¿å­˜ã—ã¾ã—ãŸï¼ˆWorker URL ã¨ SHEET_IDã‚’å–å¾—ä¸­...ï¼‰';
        }
        
        await initializeSheetId();
        
        // â˜…è¿½åŠ ï¼šToken ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ç¢ºèª
        if (status) {
          if (SHEET_ID) {
            status.textContent = 'âœ“ ä¿å­˜ã—ã¾ã—ãŸï¼ˆSHEET_IDå–å¾—å®Œäº†ï¼‰';
          } else {
            status.textContent = 'âœ“ ä¿å­˜ã—ã¾ã—ãŸï¼ˆSHEET_IDå–å¾—ã«å¤±æ•—ï¼‰';
          }
          setTimeout(() => { if (status) status.textContent = ''; }, 3000);
        }
        
        document.getElementById('workersAuthTokenEl').value = '';
      } catch (err) {
        console.error('[Settings] Failed to save auth token:', err);
        if (status) status.textContent = 'ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ';
      }
    }

    // â˜…ä¿®æ­£ï¼šç§˜å¯†æƒ…å ±ã®ä¸€æ‹¬ä¿å­˜ãƒœã‚¿ãƒ³ãƒãƒ³ãƒ‰ãƒ©
    async function saveSecretsHandler() {
      const authToken = (document.getElementById('workersAuthTokenEl')?.value || '').trim();
      const status = document.getElementById('secretsStatus');
      
      if (!authToken) {
        if (status) status.textContent = 'ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
        return;
      }
      
      await saveAuthToken();
    }

    if (document.getElementById('btnSaveSecrets')) {
      document.getElementById('btnSaveSecrets').onclick = saveSecretsHandler;
    }

    function fileToDataURL(file){
      return new Promise((res, rej)=>{
        const r = new FileReader();
        r.onload = () => res(r.result);
        r.onerror = rej;
        r.readAsDataURL(file);
      });
    }

// â˜…è¿½åŠ ï¼šãƒ›ãƒ¼ãƒ ã®ãƒœã‚¿ãƒ³ã‹ã‚‰â€œé‡£è¡Œä¸­ã§ãªãã¦ã‚‚â€é‡£æœè¿½åŠ ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
    function openManualCatch(){
      manualCatchMode = true;

      // é‡£è¡Œä¸­ã§ãªã„å ´åˆã¯ã€Œé‡£è¡Œä¸­ã€ã«ã™ã‚‹ãŒã€é–‹å§‹æ™‚åˆ»ã¯ç©ºã®ã¾ã¾ï¼ˆStartã¯æœªå…¥åŠ›è¡¨ç¤ºã«ã™ã‚‹ï¼‰
      if (draft.status === 'idle') {
        draft.status = 'active';          // ç”»é¢ã¯ã€Œé‡£è¡Œä¸­ã€è¡¨ç¤ºã«
        draft.startedAt = null;           // â† Startæ™‚é–“ã¯ç©ºã§ä¿æŒ
        draft.endedAt   = null;
        draft.catches   = draft.catches || [];
        draft.manualStarted = true;       // æ‰‹å‹•é–‹å§‹ãƒ•ãƒ©ã‚°ã¯ã“ã“ã§æ˜ç¤º
        saveDraft(draft);
      }

      // æ—¢å­˜ã®â€œè¿½åŠ ãƒ¢ãƒ¼ãƒ€ãƒ«â€ã‚’ãã®ã¾ã¾åˆ©ç”¨
      editMode=false; editingId=null; 
      catchForm={ id:uuid(), timestamp:nowIsoLocal(), species:'', size_cm:null, weight_g:null, method:'', photoPreviewUrl:undefined };
      try{ inpCatchTime.value = toLocalInputValue(new Date(catchForm.timestamp)); }catch{ inpCatchTime.value=''; }
      inpSpecies.value=''; inpSize.value=''; inpWeight.value=''; inpMethod.value=''; inpPhoto.value='';
      imgPreview.src=''; imgPreview.classList.add('hidden');
      catchModal.classList.remove('hidden');
    }

    // â˜…è¿½åŠ : CloudinaryçµŒç”±ã§EXIF(GPS)ã‚’ãƒ•ãƒ­ãƒ³ãƒˆå´ã§å–å¾—ã™ã‚‹é–¢æ•°
    async function fetchExifFromCloudinary(file) {
      const CLOUDINARY_UPLOAD_URL = `https://api.cloudinary.com/v1_1/${CONFIG.API.CLOUDINARY_CLOUD_NAME}/image/upload`;
      const CLOUDINARY_UPLOAD_PRESET = CONFIG.API.CLOUDINARY_UPLOAD_PRESET;

      // 1. Cloudinaryã¸ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
      const formData = new FormData();
      formData.append("file", file);
      formData.append("upload_preset", CLOUDINARY_UPLOAD_PRESET);
      formData.append("public_id", "exif_" + Date.now());

      const uploadRes = await fetch(CLOUDINARY_UPLOAD_URL, { method: "POST", body: formData });
      const uploadJson = await uploadRes.json();
      if (!uploadJson.secure_url) throw new Error("Cloudinary upload failed");

      const imageUrl = uploadJson.secure_url;

      // â˜…ä¿®æ­£ï¼šstorage ã‹ã‚‰æœ€æ–°ã® Worker URL ã‚’å–å¾—
      try {
        const stored = await configStorage.getItem('WORKER_URLS');
        if (stored) {
          const data = typeof stored === 'string' ? JSON.parse(stored) : stored;
          CONFIG.API.EXIF_WORKER_URL = data.EXIF_WORKER_URL || CONFIG.API.EXIF_WORKER_URL;
        }
      } catch (err) {
        console.warn('[fetchExifFromCloudinary] Failed to load Worker URL from storage:', err);
      }

      // â˜…ä¿®æ­£ï¼šç›´æ¥ EXIF Worker ã‚’å‘¼ã³å‡ºã—
      const exifRes = await fetch(CONFIG.API.EXIF_WORKER_URL, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ imageUrl: imageUrl })
      });
      const exifJson = await exifRes.json();

      // Worker ã‹ã‚‰ã®å¿œç­”ã‚’å‡¦ç†
      if (!exifJson.Composite) return null;
      
      const latStr = exifJson?.Composite?.GPSLatitude;
      const lonStr = exifJson?.Composite?.GPSLongitude;
      const dateTime = exifJson?.EXIF?.DateTimeOriginal || "ä¸æ˜";

      console.log("ğŸ“¸ æ’®å½±æ—¥æ™‚:", dateTime);
      console.log("ğŸ“ ç·¯åº¦:", latStr, "çµŒåº¦:", lonStr);

      if (!latStr || !lonStr) return null;

      // 3. åº¦å˜ä½ã¸å¤‰æ›ï¼ˆDMS â†’ decimalï¼‰
      function dmsToDecimal(dms) {
        const parts = dms.split(/[^\d\w.]+/).filter(Boolean).map(Number);
        if (parts.length < 3) return NaN;
        return parts[0] + parts[1]/60 + parts[2]/3600;
      }

      const lat = dmsToDecimal(latStr);
      const lng = dmsToDecimal(lonStr);

      return { lat, lng, dateTime, imageUrl };
    }
       
    async function uploadPhotoToDrive(file){
      // â˜…è¿½åŠ ï¼šAPIå‘¼ã³å‡ºã—æ™‚ã«æœ€æ–°ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å‹•çš„ã«èª­ã¿è¾¼ã‚€
      const latestToken = await configStorage.getItem('WORKERS_AUTH_TOKEN');
      if (latestToken) {
        CONFIG.API.WORKERS_AUTH_TOKEN = latestToken;
      }
      
      // â˜…é€²æ—ï¼ˆå­˜åœ¨ã™ã‚Œã°ä½¿ç”¨ï¼‰
      const setProgress = (msg)=>{ try{ const el=document.getElementById('uploadProgress'); if(el){ el.textContent = msg; } }catch{} };

      setProgress('ç”»åƒã‚’æœ€é©åŒ–ä¸­...');
      const { dataUrl, mime } = await compressImageFile(file, { maxSize:1600, quality:0.85 });

      const payload = {
        action: "uploadPhoto",
        fileName: file.name || (`photo_${Date.now()}.jpg`),
        mimeType: mime || file.type || "image/jpeg",
        dataUrl
      };

      setProgress('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸­...');
      // â˜…ä¿®æ­£ï¼šWorker çµŒç”±ã§ GAS ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ï¼ˆsecrets ä¿è­·ï¼‰
      const workerUrl = CONFIG.API.FISHING_TRIP_API_WORKER + '/api/upload';
      const res = await fetch(workerUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-Auth-Token": CONFIG.API.WORKERS_AUTH_TOKEN
        },
        body: JSON.stringify(payload)
      });
      let j={}; try{ j = await res.json(); }catch{}
      setProgress('');
      if (!res.ok || !j?.ok) throw new Error(j?.error || `HTTP ${res.status}`);
      return j; // { ok:true, fileId, viewUrl, thumbUrl }
    }

    // â˜…è¿½åŠ ï¼šGoogle Drive ã‹ã‚‰ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å‰Šé™¤ã™ã‚‹é–¢æ•°ï¼ˆGASçµŒç”±ï¼‰
    // â˜…ä¿®æ­£ï¼šç”»åƒå‰Šé™¤ã¯ GAS å‘¼ã³å‡ºã—ã‚’ã‚¹ã‚­ãƒƒãƒ—ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ã®ã¿ã§å‰Šé™¤ã‚’ãƒãƒ¼ã‚¯ï¼‰
    // â˜…ä¿®æ­£ï¼šç”»åƒå‰Šé™¤ã¯ GAS ã®å®šæœŸå®Ÿè¡Œã«å§”ã­ã‚‹
    // æ–¹é‡ï¼šcatch ã‚·ãƒ¼ãƒˆã«å­˜åœ¨ã—ãªã„ photoFileId ã‚’æŒã¤ç”»åƒã¯ã€GAS ã®å®šæœŸå®Ÿè¡Œã§è‡ªå‹•å‰Šé™¤ã•ã‚Œã‚‹
    // ãƒ¡ãƒªãƒƒãƒˆï¼š
    //   - UI ã®ãƒãƒ³ã‚°å•é¡ŒãŒå®Œå…¨ã«è§£æ±º
    //   - ç·¨é›†ã‚­ãƒ£ãƒ³ã‚»ãƒ«æ™‚ã«ç”»åƒãŒå‰Šé™¤ã•ã‚Œãªã„ï¼ˆå¿…è¦ãªç”»åƒãŒå®ˆã‚‰ã‚Œã‚‹ï¼‰
    //   - orphan ç”»åƒã¯å®šæœŸçš„ã«è‡ªå‹•ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    function deletePhotoFromDrive(fileId) {
      if (!fileId) {
        console.warn('[DeletePhoto] No fileId provided');
        return;
      }

      console.log('[DeletePhoto] Photo marked for orphan cleanup (will be deleted by GAS scheduled trigger):', fileId);
      // â˜…é‡è¦ï¼šãƒ•ãƒ­ãƒ³ãƒˆå´ã§ã¯ä½•ã‚‚ã—ãªã„
      // GAS ã® cleanupOrphanPhotos() ãŒã‚·ãƒ¼ãƒˆä¸Šã«å­˜åœ¨ã—ãªã„ fileId ã‚’å®šæœŸçš„ã«å‰Šé™¤
    }

    // â˜…è¿½åŠ ï¼šæ½®æ±ãƒãƒ£ãƒ¼ãƒˆç”»åƒå–å¾—ãƒ»ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰é–¢æ•°ï¼ˆGASãƒ—ãƒ­ã‚­ã‚·çµŒç”±ï¼‰
    async function fetchAndUploadTideImages(startedAt, endedAt) {
        console.log('[TideImageUpload] Starting tide image fetch', { startedAt, endedAt });
        
        // â˜…è¿½åŠ ï¼šAPIå‘¼ã³å‡ºã—æ™‚ã«æœ€æ–°ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’å‹•çš„ã«èª­ã¿è¾¼ã‚€
        const latestToken = await configStorage.getItem('WORKERS_AUTH_TOKEN');
        if (latestToken) {
          CONFIG.API.WORKERS_AUTH_TOKEN = latestToken;
        }
        
        if (!startedAt || !endedAt) {
          console.warn('[TideImageUpload] Missing startedAt or endedAt');
          return { ok: false, images: [] };
        }

        // â˜…ãƒ­ãƒ¼ã‚«ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆfile://ï¼‰ã§ã¯ç”»åƒå–å¾—ã‚’ã‚¹ã‚­ãƒƒãƒ—
        if (window.location.protocol === 'file:') {
          console.warn('[TideImageUpload] Running on file:// protocol - image fetch skipped (use local HTTP server)');
          return { ok: true, images: [], skipped: true, reason: 'file protocol' };
        }      try {
        const startDate = new Date(startedAt);
        const endDate = new Date(endedAt);
        
        // é‡£è¡Œé–‹å§‹ã®30åˆ†å‰ã‹ã‚‰çµ‚äº†ã®20åˆ†å¾Œã¾ã§ã®æ™‚é–“ç¯„å›²ã‚’è¨ˆç®—
        const rangeStart = new Date(startDate.getTime() - 30 * 60000); // 30åˆ†å‰
        const rangeEnd = new Date(endDate.getTime() + 20 * 60000);     // 20åˆ†å¾Œ
        
        console.log('[TideImageUpload] Time range:', {
          rangeStart: rangeStart.toISOString(),
          rangeEnd: rangeEnd.toISOString()
        });

        // ãƒ•ã‚¡ã‚¤ãƒ«åã¯10åˆ†å˜ä½ãªã®ã§ã€10åˆ†ã”ã¨ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å–å¾—
        const filenames = [];
        
        let current = new Date(rangeStart);
        current.setMinutes(Math.floor(current.getMinutes() / 10) * 10, 0, 0); // 10åˆ†å˜ä½ã«åˆ‡ã‚Šä¸‹ã’

        while (current <= rangeEnd) {
          const yyyy = current.getFullYear();
          const mm = String(current.getMonth() + 1).padStart(2, '0');
          const dd = String(current.getDate()).padStart(2, '0');
          const hh = String(current.getHours()).padStart(2, '0');
          const mi = String(current.getMinutes()).padStart(2, '0');
          const filename = `${yyyy}${mm}${dd}${hh}${mi}.png`;
          
          filenames.push(filename);
          console.log('[TideImageUpload] Added filename:', filename);
          
          // æ¬¡ã®10åˆ†ã¸
          current = new Date(current.getTime() + 10 * 60000);
        }

        console.log('[TideImageUpload] Total images to fetch:', filenames.length);

        // GASãƒ—ãƒ­ã‚­ã‚·çµŒç”±ã§ç”»åƒã‚’ãƒ•ã‚§ãƒƒãƒã—ã¦ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
        const uploadedImages = [];
        for (const filename of filenames) {
          try {
            console.log('[TideImageUpload] Fetching via proxy:', filename);
            
            // â˜…ä¿®æ­£ï¼šWorker çµŒç”±ã§ GAS ã«ãƒªã‚¯ã‚¨ã‚¹ãƒˆï¼ˆsecrets ä¿è­·ï¼‰
            const proxyPayload = {
              action: 'fetchTideImageViaProxy',
              filename: filename
            };

            const workerUrl = CONFIG.API.FISHING_TRIP_API_WORKER + '/api/upload';
            const proxyRes = await fetch(workerUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-Auth-Token': CONFIG.API.WORKERS_AUTH_TOKEN
              },
              body: JSON.stringify(proxyPayload)
            });

            const proxyJson = await proxyRes.json();
            
            if (proxyJson?.ok && proxyJson?.fileId) {
              console.log('[TideImageUpload] Upload successful:', filename, {
                fileId: proxyJson.fileId,
                viewUrl: proxyJson.viewUrl
              });
              uploadedImages.push({
                filename: filename,
                fileId: proxyJson.fileId,
                viewUrl: proxyJson.viewUrl,
                timestamp: filename.replace(/[^\d]/g, '').slice(0, 12) // yyyymmddhhmm
              });
            } else {
              console.warn('[TideImageUpload] Proxy fetch failed:', filename, proxyJson?.error);
            }
          } catch (err) {
            console.warn('[TideImageUpload] Error processing image:', filename, err);
          }
        }

        console.log('[TideImageUpload] Completed. Uploaded', uploadedImages.length, 'images');
        return { ok: true, images: uploadedImages };
      } catch (err) {
        console.error('[TideImageUpload] Fatal error:', err);
        return { ok: false, error: err.message, images: [] };
      }
    }

    // â˜…è¿½è¨˜: ç”»åƒåœ§ç¸®ãƒ˜ãƒ«ãƒ‘ãƒ¼ï¼ˆæœ€å¤§é•·è¾º 1600px / JPEG å“è³ª 0.85ï¼‰
    async function compressImageFile(file, {maxSize=1600, quality=0.85} = {}){
      const imgDataUrl = await fileToDataURL(file);
      const img = new Image();
      img.src = imgDataUrl;
      await img.decode();

      const w = img.naturalWidth, h = img.naturalHeight;
      const scale = Math.min(1, maxSize / Math.max(w, h));
      if (scale === 1 && (file.type && file.type !== 'image/heic')) {
        // ãã®ã¾ã¾è¿”ã™ï¼ˆéHEICã§ã‚µã‚¤ã‚ºå•é¡Œãªã—ï¼‰
        return { dataUrl: imgDataUrl, mime: (file.type || 'image/jpeg') };
      }

      const canvas = document.createElement('canvas');
      canvas.width = Math.round(w * scale);
      canvas.height = Math.round(h * scale);
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

      const mime = 'image/jpeg'; // Google Drive ã‚µãƒ ãƒäº’æ›å„ªå…ˆ
      const dataUrl = canvas.toDataURL(mime, quality);
      return { dataUrl, mime };
    }

        // â˜…è¿½è¨˜: ãƒ•ã‚£ãƒ«ã‚¿&ã‚½ãƒ¼ãƒˆçŠ¶æ…‹
    const uiFilter = {
      catches: { species:'', sizeMin:null, sizeMax:null, tideName:'', sort:'time_desc' },
      trips:   { tideName:'', dateFrom:'', dateTo:'', sort:'start_desc' }
    };
    function applyCatchesFilter(items){
      let out = items.slice();
      const f = uiFilter.catches;
      if (f.species) out = out.filter(x => String(x.species||'').includes(f.species));
      if (f.tideName) out = out.filter(x => String(x.tideName||'') === f.tideName);
      if (f.sizeMin!=null) out = out.filter(x => (x.size!=null && +x.size >= +f.sizeMin));
      if (f.sizeMax!=null) out = out.filter(x => (x.size!=null && +x.size <= +f.sizeMax));
      if (f.sort === 'time_desc') out.sort((a,b)=> (new Date(b.time||b.date||0)) - (new Date(a.time||a.date||0)));
      return out;
    }
    function applyTripsFilter(rows){
      const headers = rows[0].map(h=>String(h||'').trim());
      const col = {
        tideName: headers.indexOf('tideName'),
        startedAt: headers.indexOf('startedAt')
      };
      const f = uiFilter.trips;
      const body = rows.slice(1).filter(r=>{
        if (f.tideName && String(r[col.tideName]||'') !== f.tideName) return false;
        if (f.dateFrom && new Date(r[col.startedAt]||0) < new Date(f.dateFrom)) return false;
        if (f.dateTo   && new Date(r[col.startedAt]||0) > new Date(f.dateTo))   return false;
        return true;
      });
      if (f.sort === 'start_desc') body.sort((a,b)=> new Date(b[col.startedAt]||0) - new Date(a[col.startedAt]||0));
      return [headers, ...body];
    }

    // ===== æ½®æ±ï¼šWorker ãƒ—ãƒ­ã‚­ã‚· =====

    // æ¸¯ã‚³ãƒ¼ãƒ‰ä¸€è¦§ï¼ˆGVizï¼‰èª­ã¿è¾¼ã¿ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    let harborCache = null;

    async function loadHarborsFromSheet(){
      if (harborCache) return harborCache;
      
      // â˜…ä¿®æ­£ï¼šSHEET_ID ãŒå–å¾—ã•ã‚Œã‚‹ã¾ã§å¾…æ©Ÿï¼ˆã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãï¼‰
      if (!SHEET_ID) {
        const timeout = 5000; // 5ç§’
        const startTime = Date.now();
        await new Promise(resolve => {
          const check = () => {
            if (SHEET_ID) {
              resolve();
            } else if (Date.now() - startTime > timeout) {
              LOG.tide('[loadHarborsFromSheet] SHEET_ID timeout');
              resolve(); // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆæ™‚ã‚‚ç¶šè¡Œ
            } else {
              setTimeout(check, 100);
            }
          };
          setTimeout(check, 100);
        });
      }
      
      const rows = await loadSheetViaGAS(HARBOR_SHEET_NAME, SHEET_ID);
      if (!rows || rows.length < 2) throw new Error("æ¸¯ã‚³ãƒ¼ãƒ‰ä¸€è¦§ã®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");
      const headers = rows[0].map(h=>String(h||'').trim());
      const findCol = (cands) => {
        const idx = headers.findIndex(h => cands.some(c => h.toLowerCase().includes(c)));
        return idx >= 0 ? idx : null;
      };
      const idxPC = findCol(['pc','pref','éƒ½é“åºœçœŒã‚³ãƒ¼ãƒ‰','çœŒã‚³ãƒ¼ãƒ‰']) ?? 0;
      const idxHC = findCol(['hc','harbor','æ¸¯ã‚³ãƒ¼ãƒ‰','æ¸¯id']) ?? 1;
      const idxPN = findCol(['pn','pref','éƒ½é“åºœçœŒå']) ?? 2;
      const idxHN = findCol(['hn','æ¸¯å','harbor']) ?? 3;
      const idxLAT= findCol(['lat','ç·¯åº¦']) ?? 4;
      const idxLON= findCol(['lon','lng','çµŒåº¦']) ?? 5;

      const mapped = [];
      for (let i=1; i<rows.length; i++){
        const r = rows[i];
        const pc = r[idxPC]; const hc = r[idxHC];
        const pn = r[idxPN]; const hn = r[idxHN];
        const lat= parseFloat(r[idxLAT]); const lon=parseFloat(r[idxLON]);
        if (!isFinite(lat) || !isFinite(lon)) continue;
        mapped.push({ pc, hc, pn, hn, lat, lon });
      }
      harborCache = { headers, rows, mapped };
      LOG.tide("harbors loaded:", mapped.length);
      return harborCache;
    }

    function haversineDistance(lat1, lon1, lat2, lon2) {
      const R = 6371;
      const toRad = deg => (deg * Math.PI) / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a =
        Math.sin(dLat / 2) ** 2 +
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
      return R * 2 * Math.asin(Math.sqrt(a));
    }

    // â˜…è¿½åŠ ï¼šHarbor ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç¢ºä¿ï¼ˆåŒæœŸãƒ»ã‚­ãƒ£ãƒƒã‚·ãƒ¥å¾…æ©Ÿä¿è¨¼ï¼‰
    async function ensureHarborCache() {
      try {
        await loadHarborsFromSheet();
        if (!harborCache || !harborCache.mapped || harborCache.mapped.length === 0) {
          throw new Error('Harbor cache is empty');
        }
        return harborCache;
      } catch (e) {
        LOG.tide('[ensureHarborCache] Error:', e?.message || e);
        throw e;
      }
    }

    async function findNearestHarbor(lat, lon, radiusKm = 10){
      const hc = await loadHarborsFromSheet();

      // ã¾ãšã¯è¦æ±‚ã®åŠå¾„ï¼ˆæ—¢å®š10kmï¼‰ã§æ¢ç´¢
      const scan = (rkm) => hc.mapped
        .map(h => ({ ...h, dist: haversineDistance(lat, lon, h.lat, h.lon) }))
        .filter(h => h.dist <= rkm)
        .sort((a,b)=> a.dist - b.dist);

      let candidates = scan(radiusKm);
      if (candidates.length > 0) return candidates[0];

      // â˜…è¿½åŠ : è¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã° 30km ã«æ‹¡å¼µã—ã¦å†è©¦è¡Œ
      if (radiusKm < 30){
        candidates = scan(30);
        if (candidates.length > 0) return candidates[0];
      }
      return null;
    }

    function toSeconds_HHMM(timeStr) {
      if (timeStr === "24:00") timeStr = "23:59";
      const [h, m] = timeStr.split(":").map(Number);
      return h * 3600 + m * 60;
    }

    function analyzeTideTrendForTime(chart, localDate){
      try{
        const tideList = chart?.tide;
        if (!tideList || tideList.length < 2) return "ä¸æ˜";
        const heights = tideList.map(t => t.cm);
        const min = Math.min(...heights);
        const max = Math.max(...heights);
        const range = max - min;
        if (!isFinite(range) || range <= 0) return "ä¸æ˜";

        const hh = localDate.getHours();
        const mm = localDate.getMinutes();
        const shotSec = hh*3600 + mm*60;

        let closest = tideList[0];
        let closestDiff = Math.abs(toSeconds_HHMM(closest.time) - shotSec);
        for (let i=1; i<tideList.length; i++){
          const sec = toSeconds_HHMM(tideList[i].time);
          const diff = Math.abs(sec - shotSec);
          if (diff < closestDiff){ closest = tideList[i]; closestDiff = diff; }
        }
        const idx = tideList.indexOf(closest);
        const prev = tideList[idx-1];
        const next = tideList[idx+1];
        if (!prev || !next) return "ä¸æ˜";

        const trend = next.cm > prev.cm ? "ä¸Šã’æ½®" : "ä¸‹ã’æ½®";
        const level = Math.round(((closest.cm - min) / range) * 10);
        return `${trend}ï¼ˆ${level}åˆ†ï¼‰`;
      }catch{ return "ä¸æ˜"; }
    }

    // === ãã®æ—¥ã®æº€æ½®/å¹²æ½®ã®æ™‚åˆ»ã‚’æŠ½å‡ºï¼ˆæœ€å¤§2ã¤ãšã¤ï¼‰ ===
    function summarizeHighLowTimesFromChart(chart){
      const list = Array.isArray(chart?.tide) ? chart.tide : [];
      if (list.length < 3) return { high:null, low:null };

      const pts = list
        .map(p => ({ t: timeStrToMinutes(p.time), cm: Number(p.cm) }))
        .filter(p => isFinite(p.cm))
        .sort((a,b)=> a.t - b.t);

      const highs = [];
      const lows  = [];
      for (let i=1;i<pts.length-1;i++){
        const a = pts[i-1], b = pts[i], c = pts[i+1];
        if (a.cm < b.cm && b.cm > c.cm) highs.push(pts[i].t);
        if (a.cm > b.cm && b.cm < c.cm) lows.push(pts[i].t);
      }

      const toHHMM = (m)=> `${String(Math.floor(m/60)).padStart(2,'0')}:${String(m%60).padStart(2,'0')}`;
      const fmt = (arr) => {
        const xs = arr.slice(0, 2).map(toHHMM);
        if (xs.length === 0) return null;    // ãã®æ—¥ãªã—
        if (xs.length === 1) xs.push('ï¼');  // ç‰‡æ–¹ã—ã‹ç„¡ã„ â†’ ã€ŒHH:MMï¼ï¼ã€
        return xs.join('ï¼');
      };
      return { high: fmt(highs), low: fmt(lows) };
    }

    // === æŒ‡å®šæ—¥ã®ãƒãƒ£ãƒ¼ãƒˆå–å¾—ï¼ˆã‚­ãƒ£ãƒƒã‚·ãƒ¥ä»˜ï¼‰ ===
    const tideChartCache = {};
    async function getTideChartForDate(lat, lon, isoWithOffset){
      // â˜…ä¿®æ­£ï¼šCONFIGåˆæœŸåŒ–å®Œäº†ã‚’å¾…æ©Ÿï¼ˆAPIå‘¼ã³å‡ºã—å‰ã®å¿…é ˆå‡¦ç†ï¼‰
      await configInitPromise;
      
      // â˜…ä¿®æ­£ï¼šstorage ã‹ã‚‰æœ€æ–°ã® Worker URL ã‚’å–å¾—ï¼ˆå¿…é ˆï¼‰
      let tideWorkerUrl = CONFIG.API.TIDE_PROXY_URL;
      try {
        const stored = await configStorage.getItem('WORKER_URLS');
        if (stored) {
          const data = typeof stored === 'string' ? JSON.parse(stored) : stored;
          if (data.TIDE_WORKER_URL) {
            tideWorkerUrl = data.TIDE_WORKER_URL;
            CONFIG.API.TIDE_PROXY_URL = tideWorkerUrl;
          }
        }
      } catch (err) {
        console.warn('[getTideChartForDate] Failed to load Worker URL from storage:', err);
      }
      
      if (!tideWorkerUrl || tideWorkerUrl.includes("your-worker")) return null;
      const harbor = await findNearestHarbor(lat, lon, 10);
      if (!harbor) return null;

      const d = new Date(isoWithOffset);
      const y = d.getFullYear();
      const m = d.getMonth() + 1;
      const da = d.getDate();
      const keyDate = `${y}-${String(m).padStart(2,'0')}-${String(da).padStart(2,'0')}`;
      const cacheKey = `${harbor.pc}-${harbor.hc}-${keyDate}`;
      if (tideChartCache[cacheKey]) {
        return { harbor, chart: tideChartCache[cacheKey], chartDateKey: keyDate };
      }

      const url = `${tideWorkerUrl}?pc=${encodeURIComponent(harbor.pc)}&hc=${encodeURIComponent(harbor.hc)}&yr=${y}&mn=${m}&dy=${da}&rg=day`;
      let tideJson=null;
      try{
        const res = await fetch(url);
        if (!res.ok) return null;
        tideJson = await res.json();
      }catch{ return null; }

      const chartAll = tideJson?.tide?.chart;
      if (!chartAll) return null;
      const chart = chartAll[keyDate] || chartAll[`${y}-${m}-${da}`] || chartAll[Object.keys(chartAll).sort().reverse()[0]];
      if (!chart) return null;

      tideChartCache[cacheKey] = chart;
      return { harbor, chart, chartDateKey: keyDate };
    }

    // === é‡£æœæ™‚åˆ»ã®æ½®ä½(cm)ã¨å‚¾å‘ ===
    function nearestTideLevelCm(chart, localDate){
      const list = Array.isArray(chart?.tide) ? chart.tide : [];
      if (!list.length) return null;
      const target = localDate.getHours()*60 + localDate.getMinutes();
      let best = list[0], diff = Math.abs(timeStrToMinutes(best.time)-target);
      for (let i=1;i<list.length;i++){
        const d = Math.abs(timeStrToMinutes(list[i].time)-target);
        if (d < diff){ best = list[i]; diff = d; }
      }
      const cm = Number(best.cm);
      return isFinite(cm) ? Math.round(cm) : null;
    }

    function dateKeyFromIso(iso){
      const d = new Date(iso);
      const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), da=String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${da}`;
    }

    // â˜…è¿½åŠ ï¼šãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã®è¦ç´ ã‚’æœ‰åŠ¹/ç„¡åŠ¹åŒ–ã™ã‚‹æ±ç”¨é–¢æ•°ï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ï¼‰
    const setTripEditModalElementsEnabled = (enabled) => {
      const tripEditModalContent = tripEditModal.querySelector('div.w-full');
      if (tripEditModalContent) {
        const buttons = tripEditModalContent.querySelectorAll('button, input, textarea');
        buttons.forEach(btn => {
          btn.disabled = !enabled;
          btn.style.opacity = enabled ? '1' : '0.5';
          btn.style.pointerEvents = enabled ? 'auto' : 'none';
        });
      }
    };

    function tideInfoFromChart(chart, isoWithOffset){
      const localDate = new Date(isoWithOffset);
      const level_cm = nearestTideLevelCm(chart, localDate);
      const trend_text = analyzeTideTrendForTime(chart, localDate);
      return { level_cm, trend_text };
    }

    // ===== é–‹å§‹æ™‚ã®æ½® =====
    async function fetchTideForStart(lat, lon, startedAtIso){
      // â˜…ä¿®æ­£ï¼šCONFIGåˆæœŸåŒ–å®Œäº†ã‚’å¾…æ©Ÿï¼ˆAPIå‘¼ã³å‡ºã—å‰ã®å¿…é ˆå‡¦ç†ï¼‰
      await configInitPromise;
      
      // â˜…è¿½åŠ ï¼šstorage ã‹ã‚‰æœ€æ–°ã® Worker URL ã‚’å–å¾—
      try {
        const stored = await configStorage.getItem('WORKER_URLS');
        if (stored) {
          const data = typeof stored === 'string' ? JSON.parse(stored) : stored;
          CONFIG.API.TIDE_WORKER_URL = data.TIDE_WORKER_URL || CONFIG.API.TIDE_WORKER_URL;
        }
      } catch (err) {
        console.warn('[fetchTideForStart] Failed to load Worker URL from storage:', err);
      }
      
      if (!CONFIG.API.TIDE_WORKER_URL || CONFIG.API.TIDE_WORKER_URL.includes("your-worker")) {
        LOG.tide("TIDE_WORKER_URL ãŒæœªè¨­å®šã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—");
        return null;
      }
      const harbor = await findNearestHarbor(lat, lon, 10);
      if (!harbor) { LOG.tide("è¿‘å‚æ¸¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“"); return null; }

      const d = new Date(startedAtIso);
      const yr = d.getFullYear();
      const mn = d.getMonth() + 1;
      const dy = d.getDate();

      const url = `${CONFIG.API.TIDE_WORKER_URL}?pc=${encodeURIComponent(harbor.pc)}&hc=${encodeURIComponent(harbor.hc)}&yr=${yr}&mn=${mn}&dy=${dy}&rg=day`;
      LOG.tide("fetch:", url);

      let tideJson = null;
      try{
        const res = await fetch(url);
        if (!res.ok){ LOG.tide("tide http error", res.status); return null; }
        tideJson = await res.json();
      }catch(e){
        LOG.tide("tide fetch failed", e?.message);
        return null;
      }

      const chartAll = tideJson?.tide?.chart && typeof tideJson.tide.chart === 'object' ? tideJson.tide.chart : null;
      if (!chartAll) { LOG.tide("no chart in response"); return null; }

      const key1 = `${yr}-${mn}-${dy}`;
      const key2 = `${yr}-${String(mn).padStart(2,'0')}-${String(dy).padStart(2,'0')}`;
      let chartDateKey = null;
      let chart = null;
      if (chartAll[key1]) { chartDateKey = key1; chart = chartAll[key1]; }
      else if (chartAll[key2]) { chartDateKey = key2; chart = chartAll[key2]; }
      else {
        const keys = Object.keys(chartAll).sort().reverse();
        chartDateKey = keys[0] || null;
        chart = chartDateKey ? chartAll[chartDateKey] : null;
      }
      if (!chart) { LOG.tide("chart not found even after fallback"); return null; }

      const tideName = chart?.moon?.title || "ä¸æ˜";
      const sunrise  = chart?.sun?.rise || "ä¸æ˜";
      const sunset   = chart?.sun?.set  || "ä¸æ˜";
      const trendText= analyzeTideTrendForTime(chart, d);
      const rawAge = chart?.moon?.age;
      const rawBrightness =
        (chart?.moon?.brightness ?? chart?.moon?.illumination ?? chart?.moon?.percent ?? null);

      const age = Number.isFinite(Number(rawAge)) ? Number(rawAge) : null;
      const brightness = Number.isFinite(Number(rawBrightness)) ? Number(rawBrightness) : null;

      return {
        harbor: { pc: harbor.pc, hc: harbor.hc, pn: harbor.pn, hn: harbor.hn, lat: harbor.lat, lon: harbor.lon, dist_km: harbor.dist },
        tideName, sunrise, sunset, trendText,
        chartDateKey,
        chart,
        moon: (age != null || brightness != null) ? { age, brightness } : null
      };
    }

    function timeStrToMinutes(t){
      if (!t) return 0;
      if (t === "24:00") return 24*60;
      const [h,m] = t.split(":").map(n=>parseInt(n,10));
      return (isFinite(h)?h:0)*60 + (isFinite(m)?m:0);
    }

    function drawTideChartOnCanvas(canvas, chart){
      const ctx = canvas.getContext('2d');
      const W = 720, H = 260;
      canvas.width = W; canvas.height = H;

      const padding = { left: 48, right: 16, top: 16, bottom: 28 };
      const innerW = W - padding.left - padding.right;
      const innerH = H - padding.top - padding.bottom;

      const tideList = Array.isArray(chart?.tide) ? chart.tide : [];
      if (!tideList.length){
        ctx.clearRect(0,0,W,H);
        ctx.fillStyle = "#94a3b8";
        ctx.font = "12px sans-serif";
        ctx.fillText("ã“ã®æ—¥ã®æ½®æ±ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“", 16, 24);
        return;
      }

      const points = tideList.map(p => ({
        xMin: Math.max(0, Math.min(1440, timeStrToMinutes(p.time))),
        cm: Number(p.cm)
      })).filter(p => isFinite(p.cm));

      const ys = points.map(p=>p.cm);
      let minY = Math.min(0, Math.min(...ys));
      let maxY = Math.max(0, Math.max(...ys));
      if (minY === maxY){ minY -= 10; maxY += 10; }

      const mapX = (min) => padding.left + (min/1440) * innerW;
      const mapY = (cm)  => padding.top + (maxY - cm) / (maxY - minY) * innerH;

      ctx.clearRect(0,0,W,H);
      ctx.fillStyle = "#0f172a";
      ctx.fillRect(0,0,W,H);

      ctx.strokeStyle = "#1e293b";
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let h=0; h<=24; h+=3){
        const x = mapX(h*60);
        ctx.moveTo(x, padding.top);
        ctx.lineTo(x, H - padding.bottom);
      }
      ctx.stroke();

      const yZero = mapY(0);
      ctx.strokeStyle = "#64748b";
      ctx.lineWidth = 1.5;
      ctx.setLineDash([4,4]);
      ctx.beginPath();
      ctx.moveTo(padding.left, yZero);
      ctx.lineTo(W - padding.right, yZero);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.strokeStyle = "#334155";
      ctx.lineWidth = 1;
      ctx.strokeRect(padding.left, padding.top, innerW, innerH);

      ctx.strokeStyle = "#38bdf8";
      ctx.lineWidth = 2;
      ctx.beginPath();
      points.forEach((p,i)=>{
        const x = mapX(p.xMin);
        const y = mapY(p.cm);
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.stroke();

      ctx.fillStyle = "#7dd3fc";
      points.forEach(p=>{
        const x = mapX(p.xMin);
        const y = mapY(p.cm);
        ctx.beginPath(); ctx.arc(x,y,2.2,0,Math.PI*2); ctx.fill();
      });

      ctx.fillStyle = "#cbd5e1";
      ctx.font = "11px sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      [0,6,12,18,24].forEach(h=>{
        const x = mapX(h*60);
        ctx.fillText(`${String(h).padStart(2,"0")}:00`, x, H - padding.bottom + 6);
      });

      ctx.textAlign = "right";
      ctx.textBaseline = "middle";
      ctx.fillText(`${Math.round(maxY)} cm`, padding.left - 6, mapY(maxY));
      ctx.fillText(`0 cm`,              padding.left - 6, yZero);
      ctx.fillText(`${Math.round(minY)} cm`, padding.left - 6, mapY(minY));
    }

    // ======== â˜…è¿½åŠ ï¼šæ°´æ¸©åœ°ç‚¹ãƒãƒƒãƒãƒ³ã‚° & å½“æ—¥æ°´æ¸©å–å¾—ï¼ˆæ—¢å­˜ Workers ã‚’ä½¿ç”¨ï¼‰ ========
    // åœ°ç‚¹ãƒªã‚¹ãƒˆï¼ˆGVizï¼‰
    let pointsCache = null;

    async function loadWaterTempPointsFromSheet(){
      if (pointsCache){
        if (DEBUG_WATER) LOG.wt("use cached points:", { count: pointsCache.mapped?.length ?? 0 });
        return pointsCache;
      }
      
      // â˜…è¿½åŠ ï¼šSHEET_ID ãŒå–å¾—ã•ã‚Œã‚‹ã¾ã§å¾…æ©Ÿ
      if (!SHEET_ID) {
        if (DEBUG_WATER) LOG.wt("loadWaterTempPointsFromSheet: Waiting for SHEET_ID...");
        await new Promise(resolve => {
          const check = () => {
            if (SHEET_ID) resolve();
            else setTimeout(check, 100);
          };
          setTimeout(check, 100);
        });
      }
      
      if (DEBUG_WATER) LOG.wt("loadWaterTempPointsFromSheet: start", { SHEET_ID, POINTS_SHEET_NAME });

      const rows = await loadSheetViaGAS(POINTS_SHEET_NAME, SHEET_ID);
      if (!rows || rows.length < 2) throw new Error("åœ°ç‚¹ãƒªã‚¹ãƒˆã®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“");

      const headers = rows[0].map(h=>String(h||'').trim());
      const idxOf = (name) => headers.findIndex(h => h === name);
      const iName = idxOf("ãƒã‚¤ãƒ³ãƒˆå");
      const iLat  = idxOf("ç·¯åº¦");
      const iLon  = idxOf("çµŒåº¦");
      const iCode = idxOf("ãƒã‚¤ãƒ³ãƒˆã‚³ãƒ¼ãƒ‰");

      if (DEBUG_WATER) LOG.wt("sheet headers", headers);

      const mapped = [];
      for (let i=1; i<rows.length; i++){
        const r = rows[i];
        const name = r[iName] ?? '';
        const lat  = parseFloat(r[iLat]);
        const lon  = parseFloat(r[iLon]);
        const code = r[iCode] ?? '';
        if (!isFinite(lat) || !isFinite(lon) || !code) continue;
        mapped.push({ name, lat, lon, code });
      }

      pointsCache = { headers, rows, mapped };
      if (DEBUG_WATER){
        LOG.wt("points mapped:", { count: mapped.length });
        LOG.wt("points sample(3):", mapped.slice(0,3));
      }
      return pointsCache;
    }

    async function findNearestWaterTempPoint(lat, lon, radiusKm = 30){
      const pc = await loadWaterTempPointsFromSheet();
      if (DEBUG_WATER) LOG.wt("findNearestWaterTempPoint: args", { lat, lon, radiusKm });

      const candidates = pc.mapped
        .map(p => ({ ...p, dist: haversineDistance(lat, lon, p.lat, p.lon) }))
        .filter(p => p.dist <= radiusKm)
        .sort((a,b)=> a.dist - b.dist);

      if (DEBUG_WATER){
        LOG.wt("candidates within radius", { count: candidates.length });
        LOG.wt("top5 candidates", candidates.slice(0,5).map(c=>({ name:c.name, code:c.code, dist_km:+c.dist.toFixed(3) })));
      }
      const chosen = candidates[0] || null;
      if (DEBUG_WATER) LOG.wt("chosen point", chosen ? { name: chosen.name, code: chosen.code, dist_km:+chosen.dist.toFixed(3) } : null);
      return chosen;
    }

    function getTodayDateKeyJST(){
      const now = new Date();
      const y = now.getFullYear();
      const m = String(now.getMonth()+1).padStart(2,'0');
      const d = String(now.getDate()).padStart(2,'0');
      const key = `${y}-${m}-${d}`;
      if (DEBUG_WATER) LOG.wt("today key (JST)", key);
      return key;
    }

    async function fetchTodayWaterTempByNearest(lat, lon, targetDate = null){
      const tag = `[lat=${lat?.toFixed?.(5)}, lon=${lon?.toFixed?.(5)}]`;
      try{
        // â˜…ä¿®æ­£ï¼šCONFIGåˆæœŸåŒ–å®Œäº†ã‚’å¾…æ©Ÿï¼ˆAPIå‘¼ã³å‡ºã—å‰ã®å¿…é ˆå‡¦ç†ï¼‰
        await configInitPromise;
        
        // â˜…ä¿®æ­£ï¼šstorage ã‹ã‚‰æœ€æ–°ã® Worker URL ã‚’å–å¾—ï¼ˆå¿…é ˆï¼‰
        let waterWorkerUrl = CONFIG.API.WATER_WORKER_URL;
        try {
          const stored = await configStorage.getItem('WORKER_URLS');
          if (stored) {
            const data = typeof stored === 'string' ? JSON.parse(stored) : stored;
            if (data.WATER_WORKER_URL) {
              waterWorkerUrl = data.WATER_WORKER_URL;
              CONFIG.API.WATER_WORKER_URL = waterWorkerUrl;
            }
          }
        } catch (err) {
          // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸èª­ã¿è¾¼ã¿å¤±æ•—æ™‚ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã‚’ä½¿ç”¨
        }
        
        if (!waterWorkerUrl || /your[_-]?worker/i.test(waterWorkerUrl)){
          if (DEBUG_WATER) LOG.wt("skip: WATER_WORKER_URL is not set/placeholder");
          return null;
        }

        const point = await findNearestWaterTempPoint(lat, lon, 30);
        if (!point){
          if (DEBUG_WATER) LOG.wt("no nearest point found", { radiusKm: 30 });
          return null;
        }

        const base = `https://leisure-api-prod.n-kishou.co.jp/get-sea-water-temperature?code=${encodeURIComponent(point.code)}&type=forecast`;
        const url  = `${waterWorkerUrl.replace(/\/$/, '')}/proxy?url=${encodeURIComponent(base)}`;


        if (DEBUG_WATER) LOG.wt("request", { tag, worker: waterWorkerUrl, base, proxy: url, point });

        const res = await fetch(url, { method:'GET' });

        if (DEBUG_WATER){
          LOG.wt("response status", { status: res.status, ok: res.ok });
          // ãƒ˜ãƒƒãƒ€ã¯é‡ãŒå¤šã„ã®ã§ä¸»è¦ãªã‚‚ã®ã ã‘
          const ct = res.headers.get('content-type');
          LOG.wt("response content-type", ct);
        }

        if (!res.ok){
          const text = await res.text().catch(()=>"(body read error)");
          if (DEBUG_WATER) LOG.wt("response NG body snippet", text.slice(0,400));
          return null;
        }

        let j=null;
        try{
          j = await res.json();
        }catch(parseErr){
          if (DEBUG_WATER) LOG.wt("JSON parse error", String(parseErr));
          return null;
        }

        if (DEBUG_WATER){
          const keys = Object.keys(j || {});
          LOG.wt("json keys", keys);
          LOG.wt("result_list keys", Object.keys(j?.result_list || {}));
        }

        const data = j?.result_list?.data;
        const list = Array.isArray(data?.graph_data_main) ? data.graph_data_main : [];
        if (DEBUG_WATER){
          LOG.wt("graph_data_main length", list.length);
          LOG.wt("graph range", {
            min: data?.temperature_min_of_graph ?? null,
            max: data?.temperature_max_of_graph ?? null
          });
          if (list.length) LOG.wt("first 2 entries", list.slice(0,2));
        }

        // â˜…ä¿®æ­£ï¼štargetDate ãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ãã‚Œã‚’ä½¿ç”¨ã€ç„¡ã‘ã‚Œã°ä»Šæ—¥ã®æ—¥ä»˜ã‚’ä½¿ç”¨
        let targetDateKey;
        if (targetDate && typeof targetDate === 'object' && typeof targetDate.toISOString === 'function') {
          // ISOå½¢å¼ã®æ—¥ä»˜æ–‡å­—åˆ—ã‹ã‚‰ YYYY-MM-DD ã‚’æŠ½å‡º
          targetDateKey = targetDate.toISOString().split('T')[0];
          if (DEBUG_WATER) LOG.wt("target date (from param)", targetDateKey);
        } else {
          targetDateKey = getTodayDateKeyJST();
          if (DEBUG_WATER) LOG.wt("target date (today)", targetDateKey);
        }
        
        const today = list.find(x => typeof x?.datetime === 'string' && x.datetime.startsWith(targetDateKey));
        const temp = today ? parseFloat(today.temperature) : null;

        if (DEBUG_WATER) LOG.wt("match date", { targetDateKey, matched: today ?? null, temp });

        return {
          point_code: point.code,
          point_name: point.name,
          dist_km: point.dist,
          date: today?.datetime ?? null,
          temperature_c: isFinite(temp) ? Math.round(temp*10)/10 : null,
          graph_min: data?.temperature_min_of_graph ?? null,
          graph_max: data?.temperature_max_of_graph ?? null,
          _debug: DEBUG_WATER ? { proxy_url: url, base_url: base } : undefined
        };
      }catch(e){
        if (DEBUG_WATER) LOG.wt("failed", { tag, error: e?.message || String(e) });
        return null;
      }
    }


    // ===== UIãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚° =====
    function render(){
      console.log('[render] full draft:', JSON.stringify(draft, null, 2));
      console.log('[render] draft.start_water_temp:', draft.start_water_temp);
      if (draft.start_water_temp) {
        console.log('[render] draft.start_water_temp.point_name:', draft.start_water_temp.point_name);
        console.log('[render] draft.start_water_temp.date:', draft.start_water_temp.date);
      }
      txtTripId.textContent = draft.tripId.slice(0,8);
      txtStatus.textContent = draft.status==='idle' ? 'æœªé–‹å§‹' : (draft.status==='active' ? 'é‡£è¡Œä¸­' : 'çµ‚äº†');
      txtStartedAt.textContent = draft.startedAt ? fmtLocal(draft.startedAt) : 'â€”';
      txtCatchCount.textContent = (draft.catches?.length||0)+' ä»¶';

      if(typeof draft.lat==='number' && typeof draft.lng==='number'){
        txtPosWrap.classList.remove('hidden'); txtLat.textContent=draft.lat.toFixed(5); txtLng.textContent=draft.lng.toFixed(5);
      }else{
        txtPosWrap.classList.add('hidden');
      }

      // â˜…ä¿®æ­£ï¼šé–‹å§‹æ™‚ã®å¤©æ°—ã‚’ä¸Šéƒ¨ã«è¡¨ç¤º
      const wxBrief = draft.start_weather ? formatWeatherBrief(draft.start_weather) : null;
      document.getElementById('tripWeatherTop').textContent = wxBrief || 'â€”';

      tripWeatherRow.innerHTML = '';
      const box = (label, val) => {
        const d=document.createElement('div');
        d.className='rounded-xl bg-slate-800/40 p-3';
        d.innerHTML = `<div class="text-xs text-slate-400">${label}</div>
                       <div class="text-sm text-slate-200 mt-0.5">${val || 'â€”'}</div>`;
        return d;
      };

      // â˜…ä¿®æ­£ï¼šæ½®æ±æƒ…å ±ã¨æ°´æ¸©ã‚’1ã¤ã®ãƒ–ãƒ­ãƒƒã‚¯ã«ã¾ã¨ã‚ã‚‹
      const tideName = draft.start_tide?.tideName || 'â€”';
      const tideTrend = draft.start_tide?.trendText || 'â€”';
      const wt = draft.start_water_temp;
      console.log('[render] water_temp raw:', { temperature_c: wt?.temperature_c, point_name: wt?.point_name, date: wt?.date });
      // æ°´æ¸©åœ°ç‚¹åã‹ã‚‰ @HH:mm ä»¥é™ã‚’å‰Šé™¤
      const cleanPointName = wt?.point_name ? (() => {
        const val = wt.point_name;
        const idx = val.indexOf(' @');
        const result = idx > -1 ? val.substring(0, idx) : val;
        console.log('[render] cleanPointName:', { raw: val, idx, result });
        return result;
      })() : '';
      const wtBrief = wt && wt.temperature_c!=null
        ? `${wt.temperature_c}â„ƒ${cleanPointName ? `ï¼ˆ${cleanPointName}ï¼‰` : ''}`
        : null;
      console.log('[render] wtBrief:', wtBrief);

      // æ½®æ±ã¨æ°´æ¸©ãŒä¸¡æ–¹ã‚ã‚Œã°1ã¤ã®ãƒ–ãƒ­ãƒƒã‚¯ã«ã€ãªã‘ã‚Œã°å€‹åˆ¥ã«
      if ((tideName !== 'â€”' || tideTrend !== 'â€”') || wtBrief) {
        const combineBox = document.createElement('div');
        combineBox.className = 'rounded-xl bg-slate-800/40 p-3 space-y-2';
        combineBox.innerHTML = `
          <div>
            <div class="text-xs text-slate-400">æ½®</div>
            <div class="text-sm text-slate-200">${tideName} / ${tideTrend}</div>
          </div>
          ${wtBrief ? `
          <div>
            <div class="text-xs text-slate-400">æ°´æ¸©</div>
            <div class="text-sm text-slate-200">${wtBrief}</div>
          </div>` : ''}
        `;
        tripWeatherRow.appendChild(combineBox);
      }

      // â˜…ä¿®æ­£ï¼šçŠ¶æ…‹ã«å¿œã˜ã¦ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
      buttonRow.innerHTML='';
      if (draft.status==='idle'){
        // æœªé–‹å§‹æ™‚ï¼šé‡£è¡Œé–‹å§‹ãƒœã‚¿ãƒ³
        const b=document.createElement('button'); 
        b.textContent='é‡£è¡Œé–‹å§‹';
        b.className='w-full py-2 rounded-xl bg-emerald-600 hover:bg-emerald-500 font-semibold';
        b.onclick=startTrip; 
        buttonRow.appendChild(b);
      } else if (draft.status==='ended'){
        // â˜…è¿½åŠ ï¼šçµ‚äº†æ™‚ï¼šæ–°è¦é‡£è¡Œãƒœã‚¿ãƒ³
        const btnReset=document.createElement('button');
        btnReset.textContent='æ–°è¦é‡£è¡Œ';
        btnReset.className='w-full py-2 rounded-xl bg-slate-700 hover:bg-slate-600 font-semibold';
        btnReset.onclick=async ()=>{
          if(confirm('æ–°ã—ã„é‡£è¡Œã‚’é–‹å§‹ã—ã¾ã™ã‹ï¼Ÿ')){
            draft = { tripId: uuid(), status: 'idle', catches: [], tide_daily_cache: {}, start_water_temp: null, memo: null };
            await saveDraft(draft);
            render();
          }
        };
        buttonRow.appendChild(btnReset);
      }
      
      // é‡£è¡Œä¸­/çµ‚äº†æ™‚ã¯å›ºå®šåº•éƒ¨ãƒãƒ¼ã‚’è¡¨ç¤º
      if (draft.status==='active'){ 
        bottomBar.classList.remove('hidden'); 
        hintAddWhenActive.classList.remove('hidden'); 
      }
      else { 
        bottomBar.classList.add('hidden'); 
        hintAddWhenActive.classList.add('hidden'); 
      }

      // é‡£æœãƒªã‚¹ãƒˆ
      catchList.innerHTML='';
      const has = draft.catches && draft.catches.length>0;
      catchListEmpty.classList.toggle('hidden', has);
      if (has){
        draft.catches.forEach(c=>{
          const li=document.createElement('li'); li.className='rounded-xl bg-slate-900 border border-slate-800 p-3 flex gap-3';
          const thumbSrc = c.photoDriveThumbUrl || c.photoDriveUrl || c.photoPreviewUrl || "";
          let thumb;
          if (thumbSrc){
            thumb=document.createElement('img'); thumb.src=thumbSrc; thumb.alt='catch'; thumb.className='w-20 h-20 object-cover rounded-lg border border-slate-800';
          } else {
            thumb=document.createElement('div'); thumb.className='w-20 h-20 rounded-lg border border-dashed border-slate-700 grid place-items-center text-xs text-slate-500'; thumb.textContent='No Photo';
          }
          li.appendChild(thumb);

          const info=document.createElement('div'); info.className='flex-1 min-w-0';
          const row1=document.createElement('div'); row1.className='flex items-center justify-between';
          const title=document.createElement('div'); title.className='font-semibold truncate'; title.textContent=c.species||'(é­šç¨®æœªè¨­å®š)';
          const tm=document.createElement('div'); tm.className='text-xs text-slate-400 ml-2'; try{ tm.textContent=new Date(c.timestamp).toLocaleTimeString(); }catch{ tm.textContent=''; }
          row1.appendChild(title); row1.appendChild(tm);

          const row2=document.createElement('div'); row2.className='text-sm text-slate-300 mt-1 flex flex-wrap gap-x-3 gap-y-1';
          if (c.size_cm!=null){ const sp=document.createElement('span'); sp.textContent='ã‚µã‚¤ã‚º: '+c.size_cm+' cm'; row2.appendChild(sp); }
          if (c.weight_g!=null){ const sp=document.createElement('span'); sp.textContent='é‡é‡: '+c.weight_g+' g'; row2.appendChild(sp); }
          if (c.method){ const sp=document.createElement('span'); sp.textContent='æ–¹æ³•: '+c.method; row2.appendChild(sp); }

          if (c.weather) {
            const rowWx = document.createElement('div');
            rowWx.className = 'text-xs text-slate-400 mt-1';
            rowWx.textContent = formatWeatherBrief(c.weather);
            info.appendChild(rowWx);
          }

          info.appendChild(row1); info.appendChild(row2);

          const ops=document.createElement('div'); ops.className='flex flex-col gap-1 shrink-0';
          const btnEdit=document.createElement('button'); btnEdit.className='px-2 py-1 text-xs rounded-lg border border-slate-700 hover:bg-slate-800'; btnEdit.textContent='ç·¨é›†';
          btnEdit.onclick=()=>openEditCatch(c.id);
          const btnDel=document.createElement('button'); btnDel.className='px-2 py-1 text-xs rounded-lg border border-slate-700 hover:bg-slate-800'; btnDel.textContent='å‰Šé™¤';
          btnDel.onclick = async () =>{ 
            console.log('[DEBUG-Delete] 1. Delete button clicked');
            if (confirm('ã“ã®é‡£æœã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
              console.log('[DEBUG-Delete] 2. Confirmed delete');
              // â˜…ä¿®æ­£ï¼šå‰Šé™¤å¯¾è±¡ã®é‡£æœã‹ã‚‰ photoFileId ã‚’å–å¾—
              const photoFileIdStatus = c?.photoFileId;
              console.log('[DEBUG-Delete] 3. photoFileId:', photoFileIdStatus);
              
              console.log('[DEBUG-Delete] 4. Before splice, catches count:', draft.catches.length);
              draft.catches = draft.catches.filter(x=>x.id!==c.id); 
              console.log('[DEBUG-Delete] 5. After splice, catches count:', draft.catches.length);
              
              console.log('[DEBUG-Delete] 6. Starting saveDraft...');
              await saveDraft(draft);
              console.log('[DEBUG-Delete] 7. saveDraft completed');
              
              // â˜…ä¿®æ­£â‘¡: å‰Šé™¤å¾Œã«è£œå®Œãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè¡Œï¼ˆæ‰‹å‹•é‡£è¡Œæ™‚ã®ã¿ï¼‰
              if (draft.manualStarted) {
                console.log('[DEBUG-Delete] 8. Manual started, recalculating times...');
                // æ‰‹å‹•é‡£è¡Œæ™‚ã¯å‰Šé™¤å¾Œã«æ™‚åˆ»ã‚’å†è¨ˆç®—ã—ã¦ã‹ã‚‰ç”»é¢æ›´æ–°
                const validTimes = draft.catches
                  .map(c => c.timestamp)
                  .filter(ts => !!ts);
                
                console.log('[DEBUG-Delete] 9. Valid times count:', validTimes.length);
                if (validTimes.length > 0) {
                  const earliestTime = validTimes.reduce((a, b) => a < b ? a : b);
                  const latestTime = validTimes.reduce((a, b) => a > b ? a : b);
                  draft.startedAt = earliestTime;
                  draft.endedAt = latestTime;
                  console.log('[DEBUG-Delete] 10. Updated times, saving...');
                  await saveDraft(draft);
                  console.log('[DEBUG-Delete] 11. Time save completed');
                } else {
                  // é‡£æœãŒå…¨ã¦å‰Šé™¤ã•ã‚ŒãŸå ´åˆ
                  draft.startedAt = null;
                  draft.endedAt = null;
                  console.log('[DEBUG-Delete] 12. All catches deleted, saving empty times...');
                  await saveDraft(draft);
                  console.log('[DEBUG-Delete] 13. Empty save completed');
                }
              }
              
              // â˜…ä¿®æ­£â‘¢ï¼šå³åº§ã«ç”»é¢æ›´æ–°ï¼ˆé•·æ™‚é–“å‡¦ç†ã® _complementTripDataOnly ã¯å‘¼ã°ãªã„ï¼‰
              console.log('[DEBUG-Delete] 14. Starting render...');
              render();
              console.log('[DEBUG-Delete] 15. Render completed');
              
              // â˜…æ³¨è¨˜ï¼šç”»åƒå‰Šé™¤ã¯ GAS ã®å®šæœŸå®Ÿè¡Œã§è‡ªå‹•å‰Šé™¤ï¼ˆãƒ•ãƒ­ãƒ³ãƒˆå´ã§ã¯ä½•ã‚‚ã—ãªã„ï¼‰
              console.log('[DEBUG-Delete] 16. Photo will be cleaned up by GAS scheduled trigger');
              console.log('[DEBUG-Delete] 17. Delete process fully completed');
            }
          };
          ops.appendChild(btnEdit); ops.appendChild(btnDel);

          li.appendChild(info); li.appendChild(ops);
          catchList.appendChild(li);
        });
      }
    }
        // ===== é‡£è¡Œã®ç¢ºèªï¼ˆTripsï¼‰ =====
    const tripListEl = document.getElementById('tripList');
    const tripStatus = document.getElementById('tripStatus');
    const tripDetailWrap = document.getElementById('tripDetail');
    const tripDetailBody = document.getElementById('tripDetailBody');
    const btnCloseTripDetail = document.getElementById('btnCloseTripDetail');

    btnCloseTripDetail.onclick = () => tripDetailWrap.classList.add('hidden');

    function autoLoadTrips(){ 
      if (!tripsCache) {
        // SHEET_ID ãŒæœªè¨­å®šã®å ´åˆã€åˆæœŸåŒ–å®Œäº†ã‚’å¾…ã¤
        if (!SHEET_ID) {
          setTimeout(() => autoLoadTrips(), 100);
          return;
        }
        loadTrips();
      }
    }

    // èª­è¾¼ãƒœã‚¿ãƒ³ã®ãƒãƒ³ãƒ‰ãƒ©
    document.getElementById('btnLoadTrips').onclick = () => { autoLoadTrips(); };
    
    // ã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³ã®ãƒãƒ³ãƒ‰ãƒ©
    document.getElementById('btnClearTrips').onclick = () => { 
      tripsCache = null; 
      tripListEl.innerHTML = ''; 
      tripDetailWrap.classList.add('hidden'); 
      tripStatus.textContent = '';
    };

    async function loadTrips(){
      try{
        tripStatus.textContent = 'èª­è¾¼ä¸­...';
        tripListEl.innerHTML = '';
        tripDetailWrap.classList.add('hidden');
        
        tripsCache = await loadSheetViaGAS(TRIPS_SHEET_NAME, SHEET_ID);
        
        // â˜…è¿½åŠ ï¼šé‡£æœã‚·ãƒ¼ãƒˆã‚‚èª­ã¿è¾¼ã‚€
        catchesCache = await loadSheetViaGAS(SHEET_NAME, SHEET_ID);
        
        if (!tripsCache || tripsCache.length < 2){
          tripStatus.textContent = 'Trips ã«ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“';
          return;
        }
        renderTripsList(tripsCache);
        // â˜…è¿½è¨˜: Trips ãƒ•ã‚£ãƒ«ã‚¿ UI
        (function injectTripsFilterUI(){
          if (!tripStatus) return;
          const host = tripStatus.parentElement; if (!host) return;
          if (document.getElementById('tripsFilterBar')) return;
          const bar = document.createElement('div');
          bar.id = 'tripsFilterBar';
          bar.className = 'mt-2 flex flex-wrap gap-2 text-sm';
          bar.innerHTML = `
            <input id="tfFrom" type="date" class="px-2 py-1 rounded bg-slate-800 border border-slate-700" />
            <input id="tfTo"   type="date" class="px-2 py-1 rounded bg-slate-800 border border-slate-700" />
            <select id="tfSort" class="px-2 py-1 rounded bg-slate-800 border border-slate-700">
              <option value="start_desc">é–‹å§‹ãŒæ–°ã—ã„é †</option>
            </select>
            <button id="tfApply" class="px-2 py-1 rounded border border-slate-700 hover:bg-slate-800">é©ç”¨</button>
          `;
          host.appendChild(bar);
          document.getElementById('tfApply').onclick = ()=>{
            uiFilter.trips.dateFrom = document.getElementById('tfFrom').value || '';
            uiFilter.trips.dateTo   = document.getElementById('tfTo').value   || '';
            uiFilter.trips.sort     = document.getElementById('tfSort').value;
            const filtered = applyTripsFilter(tripsCache);
            renderTripsList(filtered);
          };
        })();
        tripStatus.textContent = `èª­ã¿è¾¼ã¿å®Œäº†ï¼š${tripsCache.length-1}ä»¶`;
      }catch(e){
        console.error('[loadTrips] Error:', e);
        console.error('[loadTrips] Stack:', e.stack);
        tripStatus.textContent = `èª­è¾¼å¤±æ•—: ${e.message||e}`;
      }
    }

    function hIdx(headers, name){
      const i = headers.findIndex(h => String(h||'').trim() === name);
      return i >= 0 ? i : -1;
    }

   function renderTripsList(rows){
      // --- helpersï¼ˆã“ã®é–¢æ•°å†…ã ã‘ï¼‰ ---
      const pad2 = n => String(n).padStart(2,'0');
      const fmtYMD = iso => {
        const d = new Date(iso); if (isNaN(d)) return 'â€”';
        return `${d.getFullYear()}å¹´${pad2(d.getMonth()+1)}æœˆ${pad2(d.getDate())}æ—¥`;
      };
            // "6:24:00" / "06:24" / GVizã®Date(...) / æ•°å€¤ã‚·ãƒªã‚¢ãƒ«ã«å¯¾å¿œã—ã¦ HH:MM ã‚’è¿”ã™
      const hm = (v) => {
        if (v == null) return '';

        // 1) GVizã® Date(YYYY,MM,DD,HH,MM,SS) å½¢å¼
        const ds = String(v);
        const mDate = ds.match(/^Date\(([^)]+)\)/);
        if (mDate) {
          const parts = mDate[1].split(',').map(n => parseInt(n.trim(), 10));
          const hh = parts[3] ?? 0;
          const mi = parts[4] ?? 0;
          return `${pad2(hh)}:${pad2(mi)}`;
        }

        // 2) æ•°å€¤ã‚·ãƒªã‚¢ãƒ«ï¼ˆ1æ—¥=1.0 ã¨ã—ã¦ã®å°æ•°ã€‚GVizçµŒç”±ã§æ•°å€¤ã«ãªã‚‹ã‚±ãƒ¼ã‚¹ï¼‰
        if (typeof v === 'number' && isFinite(v)) {
          // å°æ•°éƒ¨ã ã‘ã‹ã‚‰æ™‚åˆ»ã‚’å¾©å…ƒï¼ˆä¸¸ã‚èª¤å·®å¯¾ç­–ã§å››æ¨äº”å…¥ï¼‰
          const seconds = Math.round((v - Math.floor(v)) * 24 * 3600);
          const hh = Math.floor(seconds / 3600);
          const mi = Math.floor((seconds % 3600) / 60);
          return `${pad2(hh)}:${pad2(mi)}`;
        }

        // 3) æ–‡å­—åˆ— "6:24:00" / "06:24" ãªã©ï¼ˆå…ˆé ­ã® HH:MM ã‚’æŠ½å‡ºï¼‰
        const m = ds.match(/(\d{1,2}):(\d{2})/);
        return m ? `${pad2(m[1])}:${m[2]}` : '';
      };
      const hIdx = (hs, key) => hs.findIndex(h => String(h||'').trim() === key);

      const headers = rows[0];
      const col = {
        tripId:     hIdx(headers,'tripId'),
        startedAt:  hIdx(headers,'startedAt'),
        endedAt:    hIdx(headers,'endedAt'),
        catches:    hIdx(headers,'catches_count'),
        moon_v:     hIdx(headers,'moon_visual'),
        moon_a:     hIdx(headers,'moon_age'),
        sunrise:    hIdx(headers,'sunrise'),
        sunset:     hIdx(headers,'sunset'),
        raw_json:   hIdx(headers,'raw_json'),
        memo:       hIdx(headers,'memo')  // â˜…è¿½åŠ ï¼šãƒ¡ãƒ¢ã‚«ãƒ©ãƒ ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
      };

      tripListEl.innerHTML = '';

      for (let i=1;i<rows.length;i++){
        const r = rows[i];

        const thisTripId = col.tripId>=0 ? (r[col.tripId] || '') : '';
        const started = col.startedAt>=0 ? (r[col.startedAt] || '') : '';
        const ended   = col.endedAt>=0   ? (r[col.endedAt]   || '') : '';
        const count   = Number(col.catches>=0 ? (r[col.catches] || 0) : 0);

        const moonV = col.moon_v>=0 ? (r[col.moon_v] || '') : '';
        const moonA = col.moon_a>=0 ? (r[col.moon_a] || '') : '';

        // è¿½åŠ æƒ…å ±ï¼ˆæ½®å / æ—¥ã®å‡ºãƒ»æ—¥ã®å…¥ã‚Š / é–‹å§‹æ™‚ã®å¤©æ°—ï¼‰
        let tideName = '';
        let sunrise  = (col.sunrise>=0 ? (r[col.sunrise] || '') : '');
        let sunset   = (col.sunset>=0  ? (r[col.sunset]  || '') : '');
        let startWeatherBrief = '';

        // â˜…è¿½åŠ : æ°´æ¸©ã®æ¦‚è¦
        let waterTempBrief = '';
        
        // â˜…è¿½åŠ ï¼šãƒ¡ãƒ¢ã‚’å–å¾—ï¼ˆ1è¡Œè¡¨ç¤ºç”¨ï¼‰
        const memo = col.memo >= 0 ? (r[col.memo] || '') : '';
        const memoDisplay = memo ? memo.split('\n')[0].substring(0, 100) : '';  // æœ€åˆã®1è¡Œã€100æ–‡å­—ã¾ã§

        try{
          const raw = (col.raw_json>=0 && r[col.raw_json]) ? JSON.parse(r[col.raw_json]) : null;

          if (!sunrise || !sunset){
            sunrise = sunrise || raw?.start_tide?.sunrise || raw?.start_tide?.chart?.sun?.rise || '';
            sunset  = sunset  || raw?.start_tide?.sunset  || raw?.start_tide?.chart?.sun?.set  || '';
          }
          tideName = raw?.start_tide?.tideName || raw?.start_tide?.chart?.moon?.title || '';
          if (raw?.start_weather) startWeatherBrief = formatWeatherBrief(raw.start_weather);

          // â˜…è¿½åŠ : raw_json ã« start_water_temp ãŒã‚ã‚Œã°å„ªå…ˆ
          const wt = raw?.start_water_temp;
          if (wt){
            const c = (wt.temperature_c!=null && wt.temperature_c!=='') ? `${wt.temperature_c}â„ƒ` : '';
            const p = wt.point_name ? `ï¼ˆ${wt.point_name}ï¼‰` : '';
            waterTempBrief = [c && (c+p)].filter(Boolean).join('');
          } else {
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: åˆ— water_temp_* ãŒã‚ã‚Œã°ä½¿ç”¨
            const iWtC = hIdx(headers,'water_temp_c');
            const iWtP = hIdx(headers,'water_temp_point');
            const iWtT = hIdx(headers,'water_temp_time');
            const c = (iWtC>=0 ? r[iWtC] : '');
            const p = (iWtP>=0 ? r[iWtP] : '');
            const t = (iWtT>=0 ? r[iWtT] : '');
            if (c!=='' || p || t){
              const cText = (c!=='' ? `${c}â„ƒ` : '');
              const pText = p ? `ï¼ˆ${p}ï¼‰` : '';
              waterTempBrief = [cText && (cText+pText)].filter(Boolean).join('');
            }
          }
        }catch{}

        // === æŠ˜ã‚ŠãŸãŸã¿å‹ã‚«ãƒ¼ãƒ‰ ===
        const wrap = document.createElement('details');
        wrap.className = 'rounded-2xl bg-slate-900 border border-slate-800 mb-2';

        // summaryï¼ˆä¸€è¦§ãƒ˜ãƒƒãƒ€éƒ¨ï¼‰
        const summary = document.createElement('summary');
        summary.className = 'list-none p-3 flex items-center justify-between hover:bg-slate-800/60 cursor-pointer rounded-2xl';

        const left = document.createElement('div');
        left.className = 'min-w-0';
        left.innerHTML = `
          <div class="text-slate-200 font-medium flex flex-wrap gap-x-4 gap-y-1 items-center">
            <span>${started ? fmtYMD(started) : (ended ? fmtYMD(ended) : 'â€”')}</span>
            ${tideName ? `${pill(tideName,'sky')}` : ''}
            ${moonV ? `<span class="text-xl leading-none">${moonV}</span>` : ''}
            ${(moonA||moonA===0) ? `<span class="text-slate-300 text-sm">æœˆé½¢ <span class="text-slate-100">${moonA}</span></span>` : ''}
          </div>
          <div class="text-sm text-slate-300 mt-1 flex items-center gap-2">
            ${sunrise  ? `<span class="text-slate-400">æ—¥ã®å‡º</span><span class="text-slate-200">${hm(sunrise)}</span>` : ''}
            ${sunset   ? `<span class="text-slate-400">æ—¥ã®å…¥ã‚Š</span><span class="text-slate-200">${hm(sunset)}</span>` : ''}
          </div>
          ${startWeatherBrief ? `<div class="text-sm text-slate-300 mt-2">${startWeatherBrief}</div>` : ''}
          <!-- â˜…è¿½åŠ : æ°´æ¸©ã®æ¦‚è¦ -->
          ${waterTempBrief ? `<div class="text-sm text-slate-300 mt-1">æ°´æ¸©: <span class="text-slate-100">${waterTempBrief}</span></div>` : ''}
          <!-- â˜…è¿½åŠ : ãƒ¡ãƒ¢ã‚’1è¡Œè¡¨ç¤º -->
          ${memoDisplay ? `<div data-role="memo-summary" class="text-sm text-slate-300 mt-2 p-2 rounded bg-slate-800/50 border-l-2 border-slate-600 cursor-pointer hover:bg-slate-800/70 transition w-full flex items-center justify-between gap-2"><span class="text-slate-100 truncate flex-1">${memoDisplay.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</span>${memo && memo.length > memoDisplay.length ? ` <button type="button" data-role="memo-expand-inline" class="shrink-0 text-xs text-sky-400 hover:text-sky-300 hover:underline bg-transparent border-none p-0 font-normal">Read more</button>` : ''}</div>` : ''}
        `;

        const right = document.createElement('div');
        right.className = 'text-sm text-slate-200 shrink-0';
        right.textContent = `é‡£æœï¼š${isFinite(count)?count:0}åŒ¹`;

        summary.appendChild(left);
        summary.appendChild(right);
        wrap.appendChild(summary);

        // â˜…è¿½åŠ ï¼šä¸€è¦§è¡¨ç¤ºã®ãƒ¡ãƒ¢ã€ŒRead moreã€ãƒœã‚¿ãƒ³ã®ãƒãƒ³ãƒ‰ãƒ©
        if (memo) {
          const memoExpandBtn = left.querySelector('[data-role="memo-expand-inline"]');
          if (memoExpandBtn) {
            memoExpandBtn.onclick = (e) => {
              e.stopPropagation();
              // summary ã‚’éè¡¨ç¤ºã«ã—ã¦è©³ç´°éƒ¨åˆ†ã«ãƒ¡ãƒ¢ã‚’æ‹¡å¼µè¡¨ç¤º
              const memoSummaryDiv = left.querySelector('[data-role="memo-summary"]');
              if (memoSummaryDiv) {
                // ãƒ¡ãƒ¢è¡¨ç¤ºéƒ¨åˆ†ã‚’æ‹¡å¼µ
                const expandedMemo = document.createElement('div');
                expandedMemo.className = 'text-sm text-slate-300 mt-2 p-2 rounded bg-slate-800/50 border-l-2 border-slate-600 w-full flex flex-col gap-2';
                expandedMemo.innerHTML = `
                  <div class="text-slate-100 whitespace-pre-wrap break-words">${memo.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>
                  <button type="button" data-role="memo-collapse-inline" class="self-end text-xs text-sky-400 hover:text-sky-300 hover:underline bg-transparent border-none p-0 font-normal cursor-pointer">â–² é–‰ã˜ã‚‹</button>
                `;
                
                // å…ƒã®ãƒ¡ãƒ¢ã‚’ç½®ãæ›ãˆ
                memoSummaryDiv.replaceWith(expandedMemo);
                
                // é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ãƒãƒ³ãƒ‰ãƒ©
                const collapseBtn = expandedMemo.querySelector('[data-role="memo-collapse-inline"]');
                if (collapseBtn) {
                  collapseBtn.onclick = (e) => {
                    e.stopPropagation();
                    // å…ƒã®çŠ¶æ…‹ã«æˆ»ã™
                    const contractedMemo = document.createElement('div');
                    contractedMemo.setAttribute('data-role', 'memo-summary');
                    contractedMemo.className = 'text-sm text-slate-300 mt-2 p-2 rounded bg-slate-800/50 border-l-2 border-slate-600 cursor-pointer hover:bg-slate-800/70 transition w-full flex items-center justify-between gap-2';
                    contractedMemo.innerHTML = `<span class="text-slate-100 truncate flex-1">${memoDisplay.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</span>${memo && memo.length > memoDisplay.length ? ` <button type="button" data-role="memo-expand-inline" class="shrink-0 text-xs text-sky-400 hover:text-sky-300 hover:underline bg-transparent border-none p-0 font-normal">Read more</button>` : ''}`;
                    expandedMemo.replaceWith(contractedMemo);
                    
                    // å†åº¦ãƒœã‚¿ãƒ³ãƒãƒ³ãƒ‰ãƒ©ã‚’è¨­å®š
                    const newBtn = contractedMemo.querySelector('[data-role="memo-expand-inline"]');
                    if (newBtn) {
                      newBtn.onclick = arguments.callee;  // å†å¸°çš„ã«å‘¼ã³å‡ºã—
                    }
                  };
                }
              }
            };
          }
        }

        // å±•é–‹ãƒœãƒ‡ã‚£ï¼ˆé–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ä»˜ãï¼‰
        const detail = document.createElement('div');
        detail.className = 'px-3 pb-3';
        detail.innerHTML = `
          <div class="flex items-center justify-between mt-1 mb-2">
            <div class="text-xs text-slate-400">ã“ã®é‡£è¡Œã®é‡£æœ</div>
            <button type="button" data-role="trip-detail-close"
              class="text-xs px-2 py-1 rounded-lg border border-slate-700 hover:bg-slate-800">
              é–‰ã˜ã‚‹
            </button>
          </div>
          <div class="text-sm text-slate-400" data-role="trip-catches-loading">èª­ã¿è¾¼ã¿ä¸­...</div>
          <div class="grid md:grid-cols-2 gap-3 mt-2" data-role="trip-catches-list"></div>
          <div class="flex justify-end mt-3">
            <button type="button" data-role="trip-edit" class="px-3 py-1.5 bg-blue-600 hover:bg-blue-700 rounded text-white text-xs font-medium">âœ ç·¨é›†</button>
          </div>
        `;
        wrap.appendChild(detail);

        // ã€Œé–‰ã˜ã‚‹ã€ãƒœã‚¿ãƒ³ã§ã“ã® details ã‚’é–‰ã˜ã‚‹
        detail.querySelector('[data-role="trip-detail-close"]').onclick = (e)=>{
          e.stopPropagation();
          wrap.open = false;
        };

        // ã€Œç·¨é›†ã€ãƒœã‚¿ãƒ³ã®å‡¦ç†
        detail.querySelector('[data-role="trip-edit"]').onclick = async (e)=>{
          e.stopPropagation();
          console.log('[TripCard] edit button clicked, attempting to open modal');
          try {
            if (!tripsCache || tripsCache.length < 2) {
              alert('é‡£è¡Œãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
              return;
            }
            
            const headers = tripsCache[0];
            const col = {};
            for (let i = 0; i < headers.length; i++) {
              col[String(headers[i]).trim()] = i;
            }
            
            console.log('[TripCard] col keys available:', Object.keys(col).sort());
            console.log('[TripCard] tide_trend index:', col.tide_trend, 'tide_level_cm index:', col.tide_level_cm);

            // tripIdã‹ã‚‰è©²å½“è¡Œã‚’æ¤œç´¢
            const tripRow = tripsCache.find((t, idx) => idx > 0 && String(t[col.tripId]) === String(thisTripId));
            if (!tripRow) {
              alert('è©²å½“ã™ã‚‹é‡£è¡ŒãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
              return;
            }

            // draftã‚’è©²å½“ãƒ‡ãƒ¼ã‚¿ã§åˆæœŸåŒ–
            // â˜…ä¿®æ­£ï¼šé‡£æœã‚·ãƒ¼ãƒˆã®ã‚«ãƒ©ãƒ ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ä½œæˆ
            let catchHeadersForEdit = (catchesCache || [])[0] || [];
            let colCatchForEdit = {};
            for (let i = 0; i < catchHeadersForEdit.length; i++) {
              colCatchForEdit[String(catchHeadersForEdit[i]).trim()] = i;
            }

            const tripCatches = (catchesCache || []).slice(1).filter(c => String(c[colCatchForEdit.tripId]) === String(thisTripId)) || [];
            console.log('[TripCard] tripCatches debug', {
              catchesCacheLength: catchesCache?.length || 0,
              catchHeaders: catchHeadersForEdit,
              colCatch: colCatchForEdit,
              thisTripId,
              col_catch_tripId: colCatchForEdit.tripId,
              tripCatchesLength: tripCatches.length,
              tripCatches: tripCatches,  // å…¨ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¤º
              firstRow: tripCatches[0]   // æœ€åˆã®è¡Œã®è©³ç´°
            });
            
            // â˜…è¿½åŠ ï¼šraw_json ã‹ã‚‰ start_tide ã‚’å–å¾—
            let start_tide = null;
            if (col.raw_json >= 0) {
              const rawJson = tripRow[col.raw_json];
              try {
                if (rawJson) {
                  const raw = typeof rawJson === 'string' ? JSON.parse(rawJson) : rawJson;
                  start_tide = raw?.start_tide || null;
                }
              } catch (e) {
                // ãƒ‘ãƒ¼ã‚¹å¤±æ•—æ™‚ã¯ start_tide = null
              }
            }
            
            draft = {
              tripId: tripRow[col.tripId] || '',
              status: tripRow[col.status] || 'ended',
              startedAt: tripRow[col.startedAt] || null,
              endedAt: tripRow[col.endedAt] || null,
              lat: parseFloat(tripRow[col.pos_lat]) || null,
              lng: parseFloat(tripRow[col.pos_lng]) || null,
              start_weather: tripRow[col.start_weather_main] ? {
                temp: parseFloat(tripRow[col.start_temp]) || null,
                wind_speed: parseFloat(tripRow[col.start_wind_speed]) || null,
                wind_deg: parseFloat(tripRow[col.start_wind_deg]) || null,
                weather_main: tripRow[col.start_weather_main] || '',
                weather_description: tripRow[col.start_weather_desc] || ''
              } : null,
              start_water_temp: tripRow[col.water_temp_c] ? {
                temperature_c: parseFloat(tripRow[col.water_temp_c]) || null,
                point_name: String(tripRow[col.water_temp_point] || '') || null,
                date: tripRow[col.water_temp_time] || null
              } : null,
              weather: tripRow[col.start_weather_main] || null,  // â˜…è£œå®Œç”¨ï¼šå¤©æ°—
              tide_trend: tripRow[col.tide_trend] || null,  // â˜…è£œå®Œç”¨ï¼šæ½®æ±å‚¾å‘
              tide_level_cm: tripRow[col.tide_level_cm] ? parseFloat(tripRow[col.tide_level_cm]) : null,  // â˜…è£œå®Œç”¨ï¼šæ½®ä½
              // â˜…ä¿®æ­£ï¼šæ—¢å­˜é‡£æœã‚’é…åˆ—å½¢å¼ã‹ã‚‰ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå½¢å¼ã«æ­£è¦åŒ–
              catches: tripCatches.map(c => normalizeCatch(c, colCatchForEdit)),
              start_tide: start_tide,  // â˜…è¿½åŠ ï¼šraw_json ã‹ã‚‰å–å¾—ã—ãŸæ½®æ±ãƒ‡ãƒ¼ã‚¿
              tide_daily_cache: {},
              manualStarted: true,  // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ç·¨é›†ãªã®ã§æ‰‹å‹•æ‰±ã„
              memo: tripRow[col.memo] || null  // â˜…è¿½åŠ ï¼šãƒ¡ãƒ¢ã‚’ä¿å­˜
            };
            
            console.log('[TripCard] draft set:', {
              col_water_temp_c: col.water_temp_c,
              col_water_temp_point: col.water_temp_point,
              col_water_temp_time: col.water_temp_time,
              tripRow_water_temp_c: tripRow[col.water_temp_c],
              tripRow_water_temp_point: tripRow[col.water_temp_point],
              tripRow_water_temp_time: tripRow[col.water_temp_time],
              draft_start_water_temp: draft.start_water_temp
            });

            LOG.app('[TripCard] edit initiated', { tripId: thisTripId, draftCatches: draft.catches.length });
            
            // ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
            wrap.open = false;
            
            // â˜…é‡£è¡Œç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«ã«ãƒ‡ãƒ¼ã‚¿ã‚’åæ˜ 
            const editTripStarted = document.getElementById('editTripStarted');
            const editTripEnded = document.getElementById('editTripEnded');
            const editTripLat = document.getElementById('editTripLat');
            const editTripLng = document.getElementById('editTripLng');
            const editTripWeather = document.getElementById('editTripWeather');
            const editTripTide = document.getElementById('editTripTide');
            const editTripWaterTemp = document.getElementById('editTripWaterTemp');
            const editCatchList = document.getElementById('editCatchList');
            const editCatchCount = document.getElementById('editCatchCount');
            const uploadReviewModal = document.getElementById('uploadReviewModal');
            const tripEditModal = document.getElementById('tripEditModal');

            // é‡£è¡ŒåŸºæœ¬æƒ…å ±ã‚’å…¥åŠ›æ¬„ã«åæ˜ 
            if (draft.startedAt) {
              const d = new Date(draft.startedAt);
              editTripStarted.value = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
            } else {
              editTripStarted.value = '';
            }

            if (draft.endedAt) {
              const d = new Date(draft.endedAt);
              editTripEnded.value = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
            } else {
              editTripEnded.value = '';
            }

            editTripLat.value = typeof draft.lat === 'number' ? draft.lat : '';
            editTripLng.value = typeof draft.lng === 'number' ? draft.lng : '';

            // â˜…è¿½åŠ ï¼šãƒ¡ãƒ¢ã‚’åæ˜ 
            const editTripMemo = document.getElementById('editTripMemo');
            if (editTripMemo) {
              editTripMemo.value = draft.memo || '';
            }

            // è£œå®Œãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¤º
            editTripWeather.textContent = draft.start_weather ? formatWeatherBrief(draft.start_weather) : 'æœªè¨­å®š';
            editTripTide.textContent = draft.start_tide 
              ? `${draft.start_tide.tideName || ''} / ${draft.start_tide.trendText || ''}`
              : 'æœªè¨­å®š';
            editTripWaterTemp.textContent = draft.start_water_temp && draft.start_water_temp.temperature_c != null
              ? `${draft.start_water_temp.temperature_c}â„ƒ${draft.start_water_temp.point_name ? `ï¼ˆ${draft.start_water_temp.point_name}ï¼‰` : ''}`
              : 'æœªè¨­å®š';

            // â˜…ä¿®æ­£ï¼šé‡£æœãƒªã‚¹ãƒˆã‚’è¡¨ç¤ºï¼ˆé…åˆ—ãƒ‡ãƒ¼ã‚¿ã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ï¼‰
            const cts = draft.catches || [];
            editCatchList.innerHTML = '';
            editCatchCount.textContent = cts.length;

            // â˜…ä¿®æ­£ï¼šdraft.catches ã¯æ—¢ã« normalizeCatch() ã§æ­£è¦åŒ–ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€
            // ãã®ã¾ã¾ä½¿ç”¨ã™ã‚‹ï¼ˆå†åº¦normalizeCatch()ã¯å‘¼ã³å‡ºã•ãªã„ï¼‰
            console.log('[TripCard] Edit modal - draft.catches:', cts);

            cts.forEach((c, idx) => {
              // draft.catches ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãã®ã¾ã¾ä½¿ç”¨
              const catchObj = c;
              console.log(`[TripCard] catch[${idx}]:`, catchObj);

              const item = document.createElement('div');
              item.className = 'bg-slate-800 rounded-lg p-3 flex items-start justify-between';

              const content = document.createElement('div');
              content.className = 'flex-1 cursor-pointer hover:bg-slate-700/30 rounded p-1 transition';
              
              // æ™‚é–“ã®ã¿ã‚’è¡¨ç¤ºï¼ˆHH:MM:SSå½¢å¼ï¼‰
              let timeStr = '';
              if (catchObj.timestamp) {
                const d = new Date(catchObj.timestamp);
                timeStr = `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}:${String(d.getSeconds()).padStart(2,'0')}`;
              }
              
              // æ½®æ±æƒ…å ±ï¼ˆä¸‹ã’æ½®ï¼ˆ7åˆ†ï¼‰109 cm ã®ã‚ˆã†ãªå½¢å¼ï¼‰
              const tideInfo = [];
              if (catchObj.tide_trend) tideInfo.push(catchObj.tide_trend);
              if (catchObj.tide_level_cm != null) tideInfo.push(catchObj.tide_level_cm + ' cm');
              const tideStr = tideInfo.length > 0 ? tideInfo.join(' ') : '';
              
              content.innerHTML = `
                <div class="font-semibold text-slate-100 text-sm">${catchObj.species || '(é­šç¨®æœªè¨­å®š)'} ${catchObj.size_cm ? catchObj.size_cm + ' cm' : ''}</div>
                <div class="text-slate-400 text-xs mt-1">${timeStr}</div>
                ${tideStr ? `<div class="text-slate-300 text-xs mt-1">${tideStr}</div>` : ''}
              `;

              // â˜…è¿½åŠ ï¼šç·¨é›†ãƒœã‚¿ãƒ³
              const btnEdit = document.createElement('button');
              btnEdit.className = 'text-xs py-1 px-2 rounded bg-blue-900 hover:bg-blue-800 text-blue-200 ml-2';
              btnEdit.textContent = 'ç·¨é›†';
              btnEdit.onclick = (e) => {
                e.stopPropagation();
                // ç·¨é›†ãƒ•ã‚©ãƒ¼ãƒ ã«ãƒ‡ãƒ¼ã‚¿ã‚’å±•é–‹
                const editFormSection = document.getElementById('editCatchFormSection');
                const editFormTime = document.getElementById('editFormCatchTime');
                const editFormSpecies = document.getElementById('editFormCatchSpecies');
                const editFormSize = document.getElementById('editFormCatchSize');
                const editFormWeight = document.getElementById('editFormCatchWeight');
                const editFormMethod = document.getElementById('editFormCatchMethod');
                
                // â˜…è¿½åŠ ï¼šç·¨é›†ä¸­ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä¿å­˜ï¼ˆæ›´æ–°æ™‚ã«ä½¿ç”¨ï¼‰
                editFormSection.dataset.editingIndex = idx;
                editFormSection.dataset.isEditing = 'true';
                
                // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’å±•é–‹
                if (catchObj.timestamp) {
                  // â˜…ä¿®æ­£ï¼štoLocalInputValue é–¢æ•°ã‚’ä½¿ç”¨ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³å¯¾å¿œï¼‰
                  try {
                    const dt = new Date(catchObj.timestamp);
                    editFormTime.value = toLocalInputValue(dt);
                    console.log('[TripEdit] timestamp converted:', {
                      original: catchObj.timestamp,
                      formatted: editFormTime.value
                    });
                  } catch (e) {
                    console.warn('[TripEdit] timestamp parse failed:', e);
                    editFormTime.value = '';
                  }
                } else {
                  editFormTime.value = '';
                }
                editFormSpecies.value = catchObj.species || '';
                editFormSize.value = catchObj.size_cm ? String(catchObj.size_cm) : '';
                editFormWeight.value = catchObj.weight_g ? String(catchObj.weight_g) : '';
                editFormMethod.value = catchObj.method || '';
                
                // å†™çœŸãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã¯ã‚¯ãƒªã‚¢ï¼ˆæ—¢å­˜ã®å†™çœŸã¯è¡¨ç¤ºã—ãªã„ã€æ–°è¦é¸æŠã®ã¿å¯¾å¿œï¼‰
                document.getElementById('editFormCatchPhoto').value = '';
                document.getElementById('editFormCatchPhotoPreview').classList.add('hidden');
                
                // ãƒ•ã‚©ãƒ¼ãƒ ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¡¨ç¤º
                editFormSection.classList.remove('hidden');
                
                // ä¿å­˜ãƒœã‚¿ãƒ³ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’å¤‰æ›´
                document.getElementById('btnSaveCatchFormInEdit').textContent = 'æ›´æ–°';
                
                // ãƒ•ã‚©ãƒ¼ãƒ ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
                editFormSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
                
                console.log('[TripEdit] Editing catch at index:', idx, 'data:', catchObj);
              };

              const btnDelete = document.createElement('button');
              btnDelete.className = 'text-xs py-1 px-2 rounded bg-red-900 hover:bg-red-800 text-red-200 ml-2';
              btnDelete.textContent = 'å‰Šé™¤';
              btnDelete.onclick = async (e) => {
                e.stopPropagation();
                console.log('[DEBUG-EditDelete] 1. Delete button clicked in edit modal, idx:', idx);
                if (confirm('ã“ã®é‡£æœã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
                  console.log('[DEBUG-EditDelete] 2. Confirmed delete at idx:', idx);
                  
                  // â˜…ä¿®æ­£ï¼šå‰Šé™¤å¯¾è±¡ã®é‡£æœã‹ã‚‰ photoFileId ã‚’å–å¾—
                  const catchToDelete = draft.catches[idx];
                  const photoFileId = catchToDelete?.photoFileId;
                  console.log('[DEBUG-EditDelete] 3. photoFileId:', photoFileId);
                  
                  console.log('[DEBUG-EditDelete] 4. Before splice, catches count:', draft.catches.length);
                  draft.catches.splice(idx, 1);
                  console.log('[DEBUG-EditDelete] 5. After splice, catches count:', draft.catches.length);
                  
                  console.log('[DEBUG-EditDelete] 6. Starting saveDraft...');
                  await saveDraft(draft);
                  console.log('[DEBUG-EditDelete] 7. saveDraft completed');
                  
                  // â˜…æ³¨è¨˜ï¼šç”»åƒå‰Šé™¤ã¯ GAS ã®å®šæœŸå®Ÿè¡Œã§è‡ªå‹•å‰Šé™¤ï¼ˆãƒ•ãƒ­ãƒ³ãƒˆå´ã§ã¯ä½•ã‚‚ã—ãªã„ï¼‰
                  console.log('[DEBUG-EditDelete] 8. Photo will be cleaned up by GAS scheduled trigger');
                  
                  // æ‰‹å‹•é‡£è¡Œæ™‚ã¯è£œå®Œãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè¡Œã€é€šå¸¸é‡£è¡Œæ™‚ã¯ãƒ­ãƒ¼ã‚«ãƒ«å†æç”»
                  console.log('[DEBUG-EditDelete] 9. draft.manualStarted:', draft.manualStarted);
                  if (draft.manualStarted) {
                    console.log('[DEBUG-EditDelete] 10. Manual mode, recalculating times...');
                    // æ‰‹å‹•é‡£è¡Œæ™‚ã¯å‰Šé™¤å¾Œã«æ™‚åˆ»ã‚’å†è¨ˆç®—ã—ã¦ã‹ã‚‰ç”»é¢æ›´æ–°
                    const validTimes = draft.catches
                      .map(c => c.timestamp)
                      .filter(ts => !!ts);
                    
                    console.log('[DEBUG-EditDelete] 11. Valid times count:', validTimes.length);
                    if (validTimes.length > 0) {
                      const earliestTime = validTimes.reduce((a, b) => a < b ? a : b);
                      const latestTime = validTimes.reduce((a, b) => a > b ? a : b);
                      draft.startedAt = earliestTime;
                      draft.endedAt = latestTime;
                      console.log('[DEBUG-EditDelete] 12. Updated times, saving...');
                      await saveDraft(draft);
                      console.log('[DEBUG-EditDelete] 13. Time save completed');
                    } else {
                      // é‡£æœãŒå…¨ã¦å‰Šé™¤ã•ã‚ŒãŸå ´åˆ
                      draft.startedAt = null;
                      draft.endedAt = null;
                      console.log('[DEBUG-EditDelete] 14. All catches deleted, saving empty times...');
                      await saveDraft(draft);
                      console.log('[DEBUG-EditDelete] 15. Empty save completed');
                    }
                  }
                  
                  console.log('[DEBUG-EditDelete] 16. Starting render catch list...');
                  // é‡£æœãƒªã‚¹ãƒˆã‚’å†æç”»ï¼ˆã‚¹ã‚³ãƒ¼ãƒ—å†…ã§å†åº¦ãƒ«ãƒ¼ãƒ—ï¼‰
                  const renderEditCatchListAfterDelete = () => {
                    console.log('[DEBUG-EditDelete] 17. Inside renderEditCatchListAfterDelete');
                    const ctsList = draft.catches || [];
                    console.log('[DEBUG-EditDelete] 18. ctsList length:', ctsList.length);
                    editCatchList.innerHTML = '';
                    editCatchCount.textContent = ctsList.length;

                    // â˜…ä¿®æ­£ï¼šctsList ã¯æ—¢ã« normalizeCatch() ã§æ­£è¦åŒ–ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆé…åˆ—ãªã®ã§ã€
                    // ãã®ã¾ã¾ä½¿ç”¨ã™ã‚‹ï¼ˆå†åº¦normalizeCatch()ã¯å‘¼ã³å‡ºã•ãªã„ï¼‰
                    ctsList.forEach((c, i) => {
                      // ctsList ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ãã®ã¾ã¾ä½¿ç”¨
                      const catchObjTemp = c;

                      const itemTemp = document.createElement('div');
                      itemTemp.className = 'bg-slate-800 rounded-lg p-3 flex items-start justify-between';

                      const contentTemp = document.createElement('div');
                      contentTemp.className = 'flex-1 cursor-pointer hover:bg-slate-700/30 rounded p-1 transition';
                      
                      let timeStrTemp = '';
                      if (catchObjTemp.timestamp) {
                        const d = new Date(catchObjTemp.timestamp);
                        timeStrTemp = `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}:${String(d.getSeconds()).padStart(2,'0')}`;
                      }
                      
                      const tideInfoTemp = [];
                      if (catchObjTemp.tide_trend) tideInfoTemp.push(catchObjTemp.tide_trend);
                      if (catchObjTemp.tide_level_cm != null) tideInfoTemp.push(catchObjTemp.tide_level_cm + ' cm');
                      const tideStrTemp = tideInfoTemp.length > 0 ? tideInfoTemp.join(' ') : '';
                      
                      contentTemp.innerHTML = `
                        <div class="font-semibold text-slate-100 text-sm">${catchObjTemp.species || '(é­šç¨®æœªè¨­å®š)'} ${catchObjTemp.size_cm ? catchObjTemp.size_cm + ' cm' : ''}</div>
                        <div class="text-slate-400 text-xs mt-1">${timeStrTemp}</div>
                        ${tideStrTemp ? `<div class="text-slate-300 text-xs mt-1">${tideStrTemp}</div>` : ''}
                      `;

                      const btnDeleteTemp = document.createElement('button');
                      btnDeleteTemp.className = 'text-xs py-1 px-2 rounded bg-red-900 hover:bg-red-800 text-red-200 ml-2';
                      btnDeleteTemp.textContent = 'å‰Šé™¤';
                      btnDeleteTemp.onclick = async (e) => {
                        e.stopPropagation();
                        console.log('[DEBUG-EditDeleteNested] 1. Nested delete button clicked, i:', i);
                        if (confirm('ã“ã®é‡£æœã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
                          console.log('[DEBUG-EditDeleteNested] 2. Confirmed nested delete at i:', i);
                          // â˜…ä¿®æ­£ï¼šå‰Šé™¤å¯¾è±¡ã®é‡£æœã‹ã‚‰ photoFileId ã‚’å–å¾—
                          const catchToDeleteTemp = draft.catches[i];
                          const photoFileIdTemp = catchToDeleteTemp?.photoFileId;
                          console.log('[DEBUG-EditDeleteNested] 3. photoFileId:', photoFileIdTemp);
                          
                          console.log('[DEBUG-EditDeleteNested] 4. Before splice, catches count:', draft.catches.length);
                          draft.catches.splice(i, 1);
                          console.log('[DEBUG-EditDeleteNested] 5. After splice, catches count:', draft.catches.length);
                          
                          console.log('[DEBUG-EditDeleteNested] 6. Starting saveDraft...');
                          await saveDraft(draft);
                          console.log('[DEBUG-EditDeleteNested] 7. saveDraft completed');
                          
                          // â˜…æ³¨è¨˜ï¼šç”»åƒå‰Šé™¤ã¯ GAS ã®å®šæœŸå®Ÿè¡Œã§è‡ªå‹•å‰Šé™¤ï¼ˆãƒ•ãƒ­ãƒ³ãƒˆå´ã§ã¯ä½•ã‚‚ã—ãªã„ï¼‰
                          console.log('[DEBUG-EditDeleteNested] 8. Photo will be cleaned up by GAS scheduled trigger');
                          // æ‰‹å‹•é‡£è¡Œæ™‚ã¯æ™‚åˆ»ã‚’å†è¨ˆç®—
                          console.log('[DEBUG-EditDeleteNested] 9. draft.manualStarted:', draft.manualStarted);
                          if (draft.manualStarted) {
                            console.log('[DEBUG-EditDeleteNested] 10. Recalculating times...');
                            const validTimes = draft.catches
                              .map(c => c.timestamp)
                              .filter(ts => !!ts);
                            
                            console.log('[DEBUG-EditDeleteNested] 11. Valid times count:', validTimes.length);
                            if (validTimes.length > 0) {
                              const earliestTime = validTimes.reduce((a, b) => a < b ? a : b);
                              const latestTime = validTimes.reduce((a, b) => a > b ? a : b);
                              draft.startedAt = earliestTime;
                              draft.endedAt = latestTime;
                              console.log('[DEBUG-EditDeleteNested] 12. Updated times, saving...');
                            } else {
                              draft.startedAt = null;
                              draft.endedAt = null;
                              console.log('[DEBUG-EditDeleteNested] 13. All catches deleted, saving empty times...');
                            }
                            console.log('[DEBUG-EditDeleteNested] 14. Saving times...');
                            await saveDraft(draft);
                            console.log('[DEBUG-EditDeleteNested] 15. Time save completed');
                          }
                          
                          console.log('[DEBUG-EditDeleteNested] 16. Calling renderEditCatchListAfterDelete...');
                          renderEditCatchListAfterDelete();
                          console.log('[DEBUG-EditDeleteNested] 17. Nested delete process completed');
                        }
                      };

                      itemTemp.appendChild(contentTemp);
                      itemTemp.appendChild(btnDeleteTemp);
                      editCatchList.appendChild(itemTemp);
                    });
                    console.log('[DEBUG-EditDelete] 19. forEach completed, renderEditCatchListAfterDelete done');
                  };
                  console.log('[DEBUG-EditDelete] 20. Calling renderEditCatchListAfterDelete...');
                  renderEditCatchListAfterDelete();
                  console.log('[DEBUG-EditDelete] 21. Edit delete process completed');
                }
              };

              item.appendChild(content);
              item.appendChild(btnEdit);
              item.appendChild(btnDelete);
              editCatchList.appendChild(item);
            });

            // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º
            uploadReviewModal.classList.add('hidden');
            tripEditModal.classList.remove('hidden');
            
            // â˜…å¼·åˆ¶çš„ã« display ã‚’è¨­å®šï¼ˆinline style ã§ä¸Šæ›¸ãï¼‰
            tripEditModal.style.display = 'grid';
            
            // â˜…ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä½ç½®ã‚’ãƒ¢ãƒ¼ãƒ€ãƒ«ã«åˆã‚ã›ã‚‹
            tripEditModal.scrollIntoView({ behavior: 'smooth', block: 'center' });

            LOG.app('[TripEdit] opened', { catchCount: draft.catches?.length || 0 });
            
            // â˜…ãƒ‡ãƒãƒƒã‚°: ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒå®Ÿéš›ã«è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
            console.log('[TripCard] tripEditModal classes:', tripEditModal.className);
            console.log('[TripCard] tripEditModal display:', window.getComputedStyle(tripEditModal).display);
            console.log('[TripCard] tripEditModal visibility:', window.getComputedStyle(tripEditModal).visibility);
            console.log('[TripCard] tripEditModal style.display:', tripEditModal.style.display);

          } catch (err) {
            console.error('[TripCard] edit failed:', err);
            console.error('[TripCard] error stack:', err.stack);
            alert('ç·¨é›†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ' + err.message);
          }
        };

        // é–‹é–‰ã«åˆã‚ã›ã¦ hover ã‚’ç„¡åŠ¹/æœ‰åŠ¹åŒ–
        wrap.addEventListener('toggle', () => {
          if (wrap.open) summary.classList.remove('hover:bg-slate-800/60');
          else summary.classList.add('hover:bg-slate-800/60');
        });

        // é–‹ã„ãŸæ™‚ã« Catches ã‚·ãƒ¼ãƒˆã‹ã‚‰ tripId ã§è©²å½“é‡£æœã‚’èª­ã¿è¾¼ã¿
        wrap.addEventListener('toggle', async () => {
          if (!wrap.open) return;

          const listEl = detail.querySelector('[data-role="trip-catches-list"]');
          const loadingEl = detail.querySelector('[data-role="trip-catches-loading"]');
          if (listEl.dataset.loaded === '1') return; // äºŒé‡ãƒ­ãƒ¼ãƒ‰é˜²æ­¢

          try{
            const rowsC = await loadSheetViaGAS('Catches', SHEET_ID);
            const hs = rowsC[0].map(h=>String(h||'').trim());
            const cTrip   = hs.indexOf('tripId');
            const cSpec   = hs.indexOf('species');
            const cTime   = hs.indexOf('timestamp');
            const cSize   = hs.indexOf('size_cm');
            const cUrl    = hs.indexOf('photo_view_url');
            const cThumb  = hs.indexOf('photo_thumb_url');
            const cTrend  = hs.indexOf('tide_trend');
            const cTideLv = hs.indexOf('tide_level_cm');

            const items = [];
            for (let j=1;j<rowsC.length;j++){
              const rr = rowsC[j];
              if (String(rr[cTrip]||'') !== String(thisTripId)) continue;
              items.push({
                species: rr[cSpec] || '',
                ts: rr[cTime] || '',
                size: rr[cSize] || '',
                photo: rr[cThumb] || rr[cUrl] || '',
                tideTrend: rr[cTrend] || '',
                tideLevel: rr[cTideLv]
              });
            }

            loadingEl.remove();
            if (!items.length){
              const empty = document.createElement('div');
              empty.className = 'text-sm text-slate-500';
              empty.textContent = 'è©²å½“ã™ã‚‹é‡£æœã¯ã‚ã‚Šã¾ã›ã‚“ã€‚';
              listEl.appendChild(empty);
            }else{
              items.forEach(c=>{
                const card = document.createElement('div');
                // æ ç·šã‚’ç„¡ãã—ã¦æ§ãˆã‚ãªèƒŒæ™¯ã®ã¿
                card.className = 'rounded-lg bg-slate-900/60 p-3 flex gap-3 items-start';
                const img = document.createElement('img');
                img.className = 'w-20 h-20 object-cover rounded-lg bg-slate-950';
                img.src = resolvePhotoUrl(c.photo) || '';
                img.alt = 'photo';
                card.appendChild(img);

                const info = document.createElement('div');
                info.className = 'flex-1 min-w-0';
                info.innerHTML = `
                  <div class="font-semibold truncate">
                    ${c.species||'(é­šç¨®ä¸æ˜)'} ${c.size?`<span class="text-sm text-slate-300 ml-1">${c.size} cm</span>`:''}
                  </div>
                  <div class="text-xs text-slate-400 mt-0.5">${c.ts ? new Date(c.ts).toLocaleString() : ''}</div>
                  <div class="mt-1 flex flex-wrap items-center gap-2">
                    ${c.tideTrend ? pill(c.tideTrend,'emerald') : ''}
                    ${(c.tideLevel || c.tideLevel===0) ? pill(`${c.tideLevel} cm`, 'violet') : ''}
                  </div>
                `;
                card.appendChild(info);
                listEl.appendChild(card);
              });
              listEl.dataset.loaded = '1';
            }
          }catch(e){
            loadingEl.textContent = 'èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚';
          }
        });

        tripListEl.appendChild(wrap);
      }
    }

    // æ—¢å­˜ã®ä¸€è¦§ã‚«ãƒ¼ãƒ‰è¦‹ãŸç›®ã«å¯„ã›ã¦å°ã•ã‚ã‚«ãƒ¼ãƒ‰ã‚’ç”Ÿæˆ
    function renderCatchMiniCardsForTrip(tripId, catchesRows){
      const headers = catchesRows[0];
      const cidx = {
        tripId: hIdx(headers,'tripId'),
        ts:     hIdx(headers,'timestamp'),
        sp:     hIdx(headers,'species'),
        size:   hIdx(headers,'size_cm'),
        photo:  hIdx(headers,'photo_thumb_url') >=0 ? hIdx(headers,'photo_thumb_url')
              : (hIdx(headers,'photo_view_url') >=0 ? hIdx(headers,'photo_view_url') : hIdx(headers,'photo_file_id')),
        tideName:  hIdx(headers,'tide_name'),
        tideTrend: hIdx(headers,'tide_trend'),
        tideLevel: hIdx(headers,'tide_level_cm'),
      };

      const wrap = document.createElement('div');
      wrap.className = 'grid sm:grid-cols-2 gap-3';

      for (let i=1;i<catchesRows.length;i++){
        const r = catchesRows[i];
        if (String(r[cidx.tripId]||'') !== String(tripId)) continue;

        const card = document.createElement('div');
        card.className = 'rounded-xl bg-slate-900 border border-slate-800 p-3 flex gap-3 items-start';

        const img = document.createElement('img');
        img.className = 'w-20 h-20 object-cover rounded-lg border border-slate-800 bg-slate-950';
        img.alt = 'photo';
        img.src = resolvePhotoUrl(r[cidx.photo] || '') || '';
        card.appendChild(img);

        const info = document.createElement('div');
        info.className = 'min-w-0 flex-1';
        const titleRow = document.createElement('div');
        titleRow.className = 'flex items-center justify-between gap-2';

        const t = document.createElement('div');
        t.className = 'font-semibold truncate';
        t.textContent = r[cidx.sp] || '(é­šç¨®ä¸æ˜)';
        const sz = document.createElement('span');
        sz.className = 'text-sm text-slate-300';
        if (r[cidx.size] || r[cidx.size]===0) sz.textContent = `${r[cidx.size]} cm`;
        titleRow.appendChild(t); titleRow.appendChild(sz);
        info.appendChild(titleRow);

        const meta = document.createElement('div');
        meta.className = 'mt-1 text-sm text-slate-300';
        const ts = r[cidx.ts] ? new Date(r[cidx.ts]).toLocaleString() : '';
        meta.textContent = ts;
        info.appendChild(meta);

        const cond = document.createElement('div');
        cond.className = 'mt-1 flex flex-wrap items-center gap-2';
        const tn = r[cidx.tideName]; const tt = r[cidx.tideTrend]; const tl = r[cidx.tideLevel];
        if (tn){ const b=document.createElement('span'); b.className='px-2 py-0.5 rounded-full text-[11px] border border-sky-700/60 bg-sky-900/30'; b.textContent=tn; cond.appendChild(b); }
        if (tt){ const b=document.createElement('span'); b.className='px-2 py-0.5 rounded-full text-[11px] border border-emerald-700/60 bg-emerald-900/30'; b.textContent=tt; cond.appendChild(b); }
        if (tl||tl===0){ const b=document.createElement('span'); b.className='px-2 py-0.5 rounded-full text-[11px] border border-violet-700/60 bg-violet-900/30'; b.textContent=`${tl} cm`; cond.appendChild(b); }
        info.appendChild(cond);

        card.appendChild(info);
        wrap.appendChild(card);
      }
      return wrap;
    }


    // ===== ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ =====
    async function startTrip(){
      // â˜…ä¿®æ­£ï¼šCONFIGåˆæœŸåŒ–å®Œäº†ã‚’å¾…æ©Ÿï¼ˆAPIå‘¼ã³å‡ºã—å‰ã®å¿…é ˆå‡¦ç†ï¼‰
      await configInitPromise;
      
      if (draft.status==='active') return;
      draft.status='active'; draft.startedAt=nowIsoLocal();

      try{
        if (navigator.geolocation){
          await new Promise(res=>{
            navigator.geolocation.getCurrentPosition(
              p => { draft.lat=p.coords.latitude; draft.lng=p.coords.longitude; res(); },
              () => res(),
              { enableHighAccuracy:true, timeout:8000 }
            );
          });
        }
        // å¤©æ°—
        if (typeof draft.lat === 'number' && typeof draft.lng === 'number'){
          try { draft.start_weather = await fetchWeather(draft.lat, draft.lng); } catch(e){ console.error('[3543] fetchWeather error:', e); }
        }
        // æ½®æ±ï¼ˆé–‹å§‹æ™‚ã®æ¦‚æ³ï¼‰
        try{
          if (typeof draft.lat === 'number' && typeof draft.lng === 'number'){
            const tide = await fetchTideForStart(draft.lat, draft.lng, draft.startedAt);
            draft.start_tide = tide || null;
            if (tide?.chart && tide?.chartDateKey){
              draft.tide_daily_cache = draft.tide_daily_cache || {};
              draft.tide_daily_cache[tide.chartDateKey] = {
                harbor: tide.harbor || null,
                chart: tide.chart
              };
            }
          }
        }catch(e){ console.warn("[Tide] startTrip fetch failed:", e?.message||e); }

        // â˜…è¿½åŠ ï¼šå½“æ—¥ã®æ°´æ¸©ï¼ˆé–‹å§‹ä½ç½®ã«æœ€ã‚‚è¿‘ã„åœ°ç‚¹ã‚³ãƒ¼ãƒ‰ã‚’ãƒãƒƒãƒãƒ³ã‚°ã—ã¦å–å¾—ï¼‰
        try{
          if (typeof draft.lat === 'number' && typeof draft.lng === 'number'){
            if (DEBUG_WATER) LOG.wt("startTrip: fetch water temp", { lat: draft.lat, lng: draft.lng });
            draft.start_water_temp = await fetchTodayWaterTempByNearest(draft.lat, draft.lng);
            if (DEBUG_WATER) LOG.wt("startTrip: water temp result", draft.start_water_temp);
          }
        }catch(e){
          console.warn("[WaterTemp] startTrip failed:", e?.message||e);
        }

      }catch(e){
        console.warn("[startTrip] unexpected error:", e?.message || e);
      } 
      saveDraft(draft);
      render();
    }

    // â˜…è¿½åŠ ï¼šæ—¢å­˜é‡£æœï¼ˆé…åˆ—å½¢å¼ï¼‰ã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå½¢å¼ã«æ­£è¦åŒ–ã™ã‚‹é–¢æ•°
    function normalizeCatch(catchRow, colMap) {
      // æ—¢å­˜é‡£æœã¯é…åˆ—å½¢å¼ [value1, value2, ...] ã§ã€colMap ã¯ã‚«ãƒ©ãƒ ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ—
      // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå½¢å¼ã«å¤‰æ›ã—ã¦è¿”ã™
      // colMap ã«å­˜åœ¨ã—ãªã„ã‚­ãƒ¼ã¯ undefined ã‚’è¿”ã™ã®ã§ã€ãã‚Œã‚’ null ã«ç½®ãæ›ãˆã‚‹
      const getValue = (key) => {
        const idx = colMap[key];
        return (idx !== undefined && idx !== -1) ? catchRow[idx] : null;
      };
      
      return {
        id: getValue('catchId') || uuid(),
        tripId: getValue('tripId') || '',
        timestamp: getValue('timestamp') || null,
        species: getValue('species') || '',
        size_cm: getValue('size_cm') ? parseFloat(getValue('size_cm')) : null,
        weight_g: getValue('weight_g') ? parseFloat(getValue('weight_g')) : null,
        method: getValue('method') || '',
        weather: null,  // æ—¢å­˜é‡£æœã«ã¯ weather ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãªã„ï¼ˆãƒ•ãƒ©ãƒƒãƒˆã‚­ãƒ¼ã®ã¿ï¼‰
        photoFileId: getValue('photo_file_id') || null,
        photoDriveUrl: getValue('photo_view_url') || null,
        photoDriveThumbUrl: getValue('photo_thumb_url') || null,
        tide_level_cm: getValue('tide_level_cm') ? parseFloat(getValue('tide_level_cm')) : null,
        tide_trend: getValue('tide_trend') || null,
        tide_name: getValue('tide_name') || null,
        tide_harbor_name: getValue('tide_harbor_name') || null,
        tide_high_times: getValue('tide_high_times') || null,
        tide_low_times: getValue('tide_low_times') || null,
        water_temp: null,  // æ—¢å­˜é‡£æœã«ã¯ water_temp ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ãªã„
        water_temp_c: getValue('water_temp_c') ? parseFloat(getValue('water_temp_c')) : null,
        water_temp_point: getValue('water_temp_point') || null,
        water_temp_time: getValue('water_temp_time') || null,
        wx_temp: getValue('wx_temp') ? parseFloat(getValue('wx_temp')) : null,
        wx_wind_speed: getValue('wx_wind_speed') ? parseFloat(getValue('wx_wind_speed')) : null,
        wx_wind_deg: getValue('wx_wind_deg') ? parseFloat(getValue('wx_wind_deg')) : null,
        wx_main: getValue('wx_main') || null,
        wx_desc: getValue('wx_desc') || null
      };
    }

    function openAddCatch(){
      if (draft.status!=='active' && !manualCatchMode){ alert('ã¾ãšé‡£è¡Œã‚’é–‹å§‹ã—ã¦ãã ã•ã„ã€‚'); return; }
      editMode=false; editingId=null; modalTitle.textContent='é‡£æœã‚’è¿½åŠ ';

      // â˜…å¤‰æ›´ï¼šæ‰‹å‹•é‡£è¡Œä¸­ï¼ˆmanualStarted ã¾ãŸã¯ manualCatchModeï¼‰ãªã‚‰æ™‚åˆ»åˆæœŸå€¤ã¯ç©ºæ¬„
      if (draft.manualStarted || manualCatchMode) {
        catchForm={ id:uuid(), timestamp:null, species:'', size_cm:null, weight_g:null, method:'', photoPreviewUrl:undefined };
        try{ inpCatchTime.value=''; }catch{ inpCatchTime.value=''; }
      } else {
        catchForm={ id:uuid(), timestamp:nowIsoLocal(), species:'', size_cm:null, weight_g:null, method:'', photoPreviewUrl:undefined };
        try{ inpCatchTime.value = toLocalInputValue(new Date(catchForm.timestamp)); }catch{ inpCatchTime.value=''; }
      }

      inpSpecies.value=''; inpSize.value=''; inpWeight.value=''; inpMethod.value=''; inpPhoto.value='';
      imgPreview.src=''; imgPreview.classList.add('hidden');

      // â˜…è¿½åŠ ï¼šå¹´ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åˆ¶é™ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆæ‰‹å‹•é‡£è¡Œç™»éŒ²ã¨åŒã˜ï¼‰
      if (inpCatchTime) {
        if (inpCatchTime._inputHandler) {
          inpCatchTime.removeEventListener('input', inpCatchTime._inputHandler);
        }
        if (inpCatchTime._keydownHandler) {
          inpCatchTime.removeEventListener('keydown', inpCatchTime._keydownHandler);
        }
        
        inpCatchTime._keydownHandler = (evt) => {
          if (evt.key.match(/[0-9]/)) {
            const digits = inpCatchTime.value.replace(/\D/g, '');
            if (digits.length >= 4) {
              setTimeout(() => {
                const newDigits = inpCatchTime.value.replace(/\D/g, '');
                if (newDigits.length > 4) {
                  const y  = newDigits.slice(0, 4);
                  const mo = newDigits.slice(4, 6);
                  const d  = newDigits.slice(6, 8);
                  const hh = newDigits.slice(8, 10);
                  const mm = newDigits.slice(10, 12);

                  let formatted = y;
                  if (mo) formatted += '-' + mo;
                  if (d)  formatted += '-' + d;
                  if (hh) formatted += 'T' + hh;
                  if (mm) formatted += ':' + mm;

                  inpCatchTime.value = formatted;
                }
              }, 0);
            }
          }
        };

        inpCatchTime._inputHandler = () => {
          const digits = inpCatchTime.value.replace(/\D/g, '');
          
          if (!digits) {
            inpCatchTime.value = '';
            return;
          }

          const y  = digits.slice(0, 4);
          const mo = digits.slice(4, 6);
          const d  = digits.slice(6, 8);
          const hh = digits.slice(8, 10);
          const mm = digits.slice(10, 12);

          let formatted = y;
          if (mo) formatted += '-' + mo;
          if (d)  formatted += '-' + d;
          if (hh) formatted += 'T' + hh;
          if (mm) formatted += ':' + mm;

          if (formatted !== inpCatchTime.value) {
            inpCatchTime.value = formatted;
          }
        };

        inpCatchTime.addEventListener('keydown', inpCatchTime._keydownHandler);
        inpCatchTime.addEventListener('input', inpCatchTime._inputHandler);
      }

      catchModal.classList.remove('hidden');
      console.log('[openAddCatch] catchModal display state:', {
        classList: catchModal.className,
        display: window.getComputedStyle(catchModal).display,
        visibility: window.getComputedStyle(catchModal).visibility
      });
    }
    function openEditCatch(id){
      const c = draft.catches.find(x=>x.id===id); if(!c) return;
      editMode=true; editingId=id; modalTitle.textContent='é‡£æœã‚’ç·¨é›†'; catchForm={...c};
      try{ inpCatchTime.value = toLocalInputValue(new Date(catchForm.timestamp)); }catch{ inpCatchTime.value=''; }
      inpSpecies.value=catchForm.species||''; inpSize.value=(catchForm.size_cm??''); inpWeight.value=(catchForm.weight_g??''); inpMethod.value=catchForm.method||'';
      inpPhoto.value=''; if (catchForm.photoPreviewUrl){ imgPreview.src=catchForm.photoPreviewUrl; imgPreview.classList.remove('hidden'); } else { imgPreview.src=''; imgPreview.classList.add('hidden'); }

      // â˜…è¿½åŠ ï¼šå¹´ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åˆ¶é™ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆç·¨é›†æ™‚ã‚‚é©ç”¨ï¼‰
      if (inpCatchTime) {
        if (inpCatchTime._inputHandler) {
          inpCatchTime.removeEventListener('input', inpCatchTime._inputHandler);
        }
        if (inpCatchTime._keydownHandler) {
          inpCatchTime.removeEventListener('keydown', inpCatchTime._keydownHandler);
        }
        
        inpCatchTime._keydownHandler = (evt) => {
          if (evt.key.match(/[0-9]/)) {
            const digits = inpCatchTime.value.replace(/\D/g, '');
            if (digits.length >= 4) {
              setTimeout(() => {
                const newDigits = inpCatchTime.value.replace(/\D/g, '');
                if (newDigits.length > 4) {
                  const y  = newDigits.slice(0, 4);
                  const mo = newDigits.slice(4, 6);
                  const d  = newDigits.slice(6, 8);
                  const hh = newDigits.slice(8, 10);
                  const mm = newDigits.slice(10, 12);

                  let formatted = y;
                  if (mo) formatted += '-' + mo;
                  if (d)  formatted += '-' + d;
                  if (hh) formatted += 'T' + hh;
                  if (mm) formatted += ':' + mm;

                  inpCatchTime.value = formatted;
                }
              }, 0);
            }
          }
        };

        inpCatchTime._inputHandler = () => {
          const digits = inpCatchTime.value.replace(/\D/g, '');
          
          if (!digits) {
            inpCatchTime.value = '';
            return;
          }

          const y  = digits.slice(0, 4);
          const mo = digits.slice(4, 6);
          const d  = digits.slice(6, 8);
          const hh = digits.slice(8, 10);
          const mm = digits.slice(10, 12);

          let formatted = y;
          if (mo) formatted += '-' + mo;
          if (d)  formatted += '-' + d;
          if (hh) formatted += 'T' + hh;
          if (mm) formatted += ':' + mm;

          if (formatted !== inpCatchTime.value) {
            inpCatchTime.value = formatted;
          }
        };

        inpCatchTime.addEventListener('keydown', inpCatchTime._keydownHandler);
        inpCatchTime.addEventListener('input', inpCatchTime._inputHandler);
      }

      catchModal.classList.remove('hidden');
    }
    function closeCatchModal(){
      console.log('[CloseCatchModal] closeCatchModal called, flag:', window._returnToTripEditAfterCatch);
      catchModal.classList.add('hidden');
      
      // â˜…è¿½åŠ ï¼šç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«ã‹ã‚‰é‡£æœã‚’è¿½åŠ ã—ãŸå ´åˆã€ç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«ã«æˆ»ã™
      if (window._returnToTripEditAfterCatch) {
        console.log('[CloseCatchModal] Flag is true, returning to trip edit modal');
        window._returnToTripEditAfterCatch = false;
        
        // è¦ç´ å‚ç…§ã‚’å–å¾—
        const tripEditModal = document.getElementById('tripEditModal');
        const editCatchList = document.getElementById('editCatchList');
        const editCatchCount = document.getElementById('editCatchCount');
        
        console.log('[CloseCatchModal] Elements found:', {
          tripEditModal: !!tripEditModal,
          editCatchList: !!editCatchList,
          editCatchCount: !!editCatchCount
        });
        
        if (!tripEditModal || !editCatchList || !editCatchCount) {
          console.error('[CloseCatchModal] Modal elements not found');
          return;
        }

        // é‡£æœãƒªã‚¹ãƒˆã‚’å†æç”»
        const ctsList = draft.catches || [];
        console.log('[CloseCatchModal] Redrawing catch list, count:', ctsList.length);
        editCatchList.innerHTML = '';
        editCatchCount.textContent = ctsList.length;

        // ã‚«ãƒ©ãƒ ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ä½œæˆ
        let catchHeadersTemp = (catchesCache || [])[0] || [];
        let colCatchTemp = {};
        for (let i = 0; i < catchHeadersTemp.length; i++) {
          colCatchTemp[String(catchHeadersTemp[i]).trim()] = i;
        }
        console.log('[CloseCatchModal] Column mapping:', colCatchTemp);

        ctsList.forEach((c, i) => {
          const catchObjTemp = {
            species: c[colCatchTemp.species] || '',
            size_cm: parseFloat(c[colCatchTemp.size_cm]) || null,
            timestamp: c[colCatchTemp.timestamp] || '',
            tide_trend: c[colCatchTemp.tide_trend] || null,
            tide_level_cm: parseFloat(c[colCatchTemp.tide_level_cm]) || null
          };

          const itemTemp = document.createElement('div');
          itemTemp.className = 'bg-slate-800 rounded-lg p-3 flex items-start justify-between';

          const contentTemp = document.createElement('div');
          contentTemp.className = 'flex-1 cursor-pointer hover:bg-slate-700/30 rounded p-1 transition';
          
          let timeStrTemp = '';
          if (catchObjTemp.timestamp) {
            const d = new Date(catchObjTemp.timestamp);
            timeStrTemp = `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}:${String(d.getSeconds()).padStart(2,'0')}`;
          }
          
          const tideInfoTemp = [];
          if (catchObjTemp.tide_trend) tideInfoTemp.push(catchObjTemp.tide_trend);
          if (catchObjTemp.tide_level_cm != null) tideInfoTemp.push(catchObjTemp.tide_level_cm + ' cm');
          const tideStrTemp = tideInfoTemp.length > 0 ? tideInfoTemp.join(' ') : '';
          
          contentTemp.innerHTML = `
            <div class="font-semibold text-slate-100 text-sm">${catchObjTemp.species || '(é­šç¨®æœªè¨­å®š)'} ${catchObjTemp.size_cm ? catchObjTemp.size_cm + ' cm' : ''}</div>
            <div class="text-slate-400 text-xs mt-1">${timeStrTemp}</div>
            ${tideStrTemp ? `<div class="text-slate-300 text-xs mt-1">${tideStrTemp}</div>` : ''}
          `;

          const btnDeleteTemp = document.createElement('button');
          btnDeleteTemp.className = 'text-xs py-1 px-2 rounded bg-red-900 hover:bg-red-800 text-red-200 ml-2';
          btnDeleteTemp.textContent = 'å‰Šé™¤';
          btnDeleteTemp.onclick = async (e) => {
            e.stopPropagation();
            if (confirm('ã“ã®é‡£æœã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
              draft.catches.splice(i, 1);
              await saveDraft(draft);
              closeCatchModal(); // å†åº¦é‡£æœãƒªã‚¹ãƒˆã‚’æç”»
            }
          };

          itemTemp.appendChild(contentTemp);
          itemTemp.appendChild(btnDeleteTemp);
          editCatchList.appendChild(itemTemp);
        });

        // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º
        console.log('[CloseCatchModal] Before showing modal - current display:', window.getComputedStyle(tripEditModal).display);
        tripEditModal.style.display = 'grid';
        tripEditModal.classList.remove('hidden');
        console.log('[CloseCatchModal] After showing modal - display:', tripEditModal.style.display, 'classes:', tripEditModal.className);
      }
    }
    
    // â˜…è¿½åŠ ï¼šã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¦ãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‹éš›ã€ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹é–¢æ•°
    function cancelAndReturnHome(){
      // é‡£æœãƒ•ã‚©ãƒ¼ãƒ ã‚’ã‚¯ãƒªã‚¢
      catchForm = { id:uuid(), timestamp:null, species:'', size_cm:null, weight_g:null, method:'', photoPreviewUrl:undefined };
      editMode = false;
      editingId = null;
      
      // å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’ã‚¯ãƒªã‚¢
      inpCatchTime.value = '';
      inpSpecies.value = '';
      inpSize.value = '';
      inpWeight.value = '';
      inpMethod.value = '';
      inpPhoto.value = '';
      imgPreview.src = '';
      imgPreview.classList.add('hidden');
      
      // â˜…ä¿®æ­£: é‡£è¡Œã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã§åˆ†å²
      if (draft.status === 'active') {
        // é‡£è¡Œä¸­: ãƒ•ã‚©ãƒ¼ãƒ ã®ã¿ã‚¯ãƒªã‚¢ã€draftä¿æŒ â†’ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç”»é¢ã«é·ç§»
        closeCatchModal();
        render();
      } else {
        // é‡£è¡Œæœªé–‹å§‹ï¼ˆidleï¼‰: å…¨ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢ â†’ ãƒ›ãƒ¼ãƒ 
        draft = { tripId: uuid(), status: 'idle', catches: [], tide_daily_cache: {}, start_water_temp: null, memo: null };
        manualCatchMode = false;
        saveDraft(draft);
        closeCatchModal();
        showView('home');
      }
    }

    // â˜…è¿½åŠ ï¼šé‡£è¡Œä¸­ã«ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¦ãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‹é–¢æ•°
    function cancelTripAndReturnHome(){
      if (!confirm('é‡£è¡Œã‚’ä¸­æ­¢ã—ã¦ãƒ›ãƒ¼ãƒ ã«æˆ»ã‚Šã¾ã™ã‹ï¼Ÿ\nâ€»ç™»éŒ²ã—ãŸãƒ‡ãƒ¼ã‚¿ã¯ã‚¯ãƒªã‚¢ã•ã‚Œã¾ã™ã€‚')) {
        return;
      }
      
      // ãƒ‰ãƒ©ãƒ•ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆåˆæœŸçŠ¶æ…‹ã«æˆ»ã™ï¼‰
      draft = { tripId: uuid(), status: 'idle', catches: [], tide_daily_cache: {}, start_water_temp: null, memo: null };
      manualCatchMode = false;
      
      saveDraft(draft);
      
      // ãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‹
      showView('home');
      render();
    }

    async function submitCatch(){
      // â˜…ä¿®æ­£ï¼šCONFIGåˆæœŸåŒ–å®Œäº†ã‚’å¾…æ©Ÿï¼ˆAPIå‘¼ã³å‡ºã—å‰ã®å¿…é ˆå‡¦ç†ï¼‰
      await configInitPromise;
      
      try {
        const species = inpSpecies.value.trim();
        if (!species){ 
          hideUploadingOverlay();
          alert('é­šç¨®ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚'); 
          return; 
        }

     // æ‰‹å‹•é‡£è¡Œä¸­ã‚‚ã€Œæœªå…¥åŠ›ãªã‚‰ç¾åœ¨æ™‚åˆ»ã§è£œå®Œã—ãªã„ã€
      const treatAsManual = manualCatchMode || !!draft.manualStarted; // â˜…è¿½åŠ 
      let whenLocal = null;
      if (inpCatchTime.value) {
        whenLocal = toOffsetIsoLocal(new Date(inpCatchTime.value));
      } else if (!treatAsManual) {
        // è‡ªå‹•è¨˜éŒ²ãªã©â€œæ‰‹å‹•ã§ã¯ãªã„â€ã¨ãã®ã¿ç¾åœ¨æ™‚åˆ»ã§è£œå®Œ
        whenLocal = nowIsoLocal();
      }
      catchForm.timestamp = whenLocal;



      catchForm.species   = species;
      catchForm.size_cm   = inpSize.value ? Number(inpSize.value) : null;
      catchForm.weight_g  = inpWeight.value ? Number(inpWeight.value) : null;
      catchForm.method    = inpMethod.value || '';

      // å¤©æ°—
      let wx = null;
      if (typeof draft.lat === 'number' && typeof draft.lng === 'number'){
        try { wx = await fetchWeather(draft.lat, draft.lng); } catch(e){ console.error('[3940] fetchWeather error:', e); }
      }
      catchForm.weather = wx;

      // â˜…ä¿®æ­£ï¼šæ½®æ±ãƒ­ã‚¸ãƒƒã‚¯ã¯å†™çœŸå‡¦ç†(EXIF)å¾Œã«ç§»å‹•

      // å†™çœŸã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
      if (inpPhoto.files && inpPhoto.files[0]) {
        try {
          const file = inpPhoto.files[0];

          // --- EXIF è§£æï¼ˆå…ˆã«å®Ÿæ–½ã—ã¦ãƒ­ã‚°ã™ã‚‹ï¼‰---
          LOG.app("[EXIF] start parse (pre-upload)", { name: file.name, size: file.size, type: file.type });
          try {
            const exifDate = await extractExifDate(file);
            const exifGps  = await extractExifGps(file);
            LOG.app("[EXIF] raw extracted", { exifDate, exifGps });
            console.log("[EXIF] æŠ½å‡ºã—ãŸæ—¥æ™‚ã¨å ´æ‰€:", { exifDate, exifGps });

            // æ™‚åˆ»ï¼šãƒ•ã‚©ãƒ¼ãƒ æœªå…¥åŠ›ï¼ˆcatchForm.timestamp ãŒ falsyï¼‰ãªã‚‰ EXIF ã‹ã‚‰è£œå®Œ
            if (!catchForm.timestamp && exifDate) {
              const jstIso = exifDateToJstIso(exifDate);
              if (jstIso) {
                catchForm.timestamp = jstIso;
                whenLocal = jstIso;  // â˜…è¿½åŠ ï¼šwhenLocal ã‚‚æ›´æ–°
                LOG.app("[EXIF] timestamp set from EXIF", { exifDate, jstIso });
              } else {
                console.warn("[EXIF] jstIso conversion failed:", exifDate);
              }
            }

            // ä½ç½®ï¼šé‡£æœå€‹ç¥¨ãƒ¬ãƒ™ãƒ«ã«ä¿å­˜ï¼ˆä»£è¡¨ä½ç½®è£œå®Œãƒ­ã‚¸ãƒƒã‚¯ãŒæ‹¾ã†ï¼‰
            if (exifGps && typeof exifGps.lat === 'number' && typeof exifGps.lng === 'number') {
              catchForm.exif_lat = exifGps.lat;
              catchForm.exif_lng = exifGps.lng;
              LOG.app("[EXIF] GPS set on catchForm", { lat: catchForm.exif_lat, lng: catchForm.exif_lng });

              // â˜…è¿½åŠ ï¼šæ‰‹å‹•é–‹å§‹ä¸­ã§ draft ã®ä»£è¡¨ä½ç½®ãŒæœªè¨­å®šãªã‚‰ã€EXIFåº§æ¨™ã‚’å³åæ˜ 
              if (draft.manualStarted && !(typeof draft.lat==='number' && typeof draft.lng==='number')) {
                draft.lat = exifGps.lat;
                draft.lng = exifGps.lng;
                LOG.app("[EXIFâ†’Trip] representative position set on draft", { lat: draft.lat, lng: draft.lng });
                saveDraft(draft);
              }
            }
          } catch (ex) {
            console.warn("[EXIF] parse failed:", ex?.message || ex);
          }

          // --- ãƒ‰ãƒ©ã‚¤ãƒ–ã¸ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ï¼ˆæ—¢å­˜ï¼‰---
          const up = await uploadPhotoToDrive(file);
          catchForm.photoFileId = up.fileId || '';
          catchForm.photoDriveUrl = up.viewUrl || '';
          catchForm.photoDriveThumbUrl = up.thumbUrl || '';
          LOG.app("[PhotoUpload] done", { fileId: catchForm.photoFileId });

        } catch (e) {
          console.warn("[PhotoUpload] failed:", e?.message || e);
        }
      } else {
        // å†™çœŸãªã—ã®æ™‚ã®è¦³æ¸¬ãƒ­ã‚°
        LOG.app("[EXIF] skip (no photo selected). catch timestamp?", { hasTimestamp: !!catchForm.timestamp });
      }

      // â˜…ä¿®æ­£å¾Œï¼šEXIFè£œå®Œå¾Œã«æ½®æ±ãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè¡Œ
      // --- æ½®ä½/å‚¾å‘/æ¸¯å/æº€æ½®ãƒ»å¹²æ½® ---
      catchForm.tide_level_cm    = null;
      catchForm.tide_trend       = null;
      catchForm.tide_name        = null;
      catchForm.tide_harbor_name = null;
      catchForm.tide_high_times  = null;
      catchForm.tide_low_times   = null;

      // â˜…ä¿®æ­£ï¼šEXIFã‹ã‚‰åº§æ¨™ãŒæŠ½å‡ºã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ãã®åº§æ¨™ã‚’å„ªå…ˆçš„ã«ä½¿ç”¨
      const tideCalcLat = typeof catchForm.exif_lat === 'number' ? catchForm.exif_lat : draft.lat;
      const tideCalcLng = typeof catchForm.exif_lng === 'number' ? catchForm.exif_lng : draft.lng;
      LOG.app("[Tide] using position for calc", { tideCalcLat, tideCalcLng, hasExif: !!(catchForm.exif_lat && catchForm.exif_lng), hasDraft: !!(draft.lat && draft.lng) });

      if (whenLocal && typeof tideCalcLat === 'number' && typeof tideCalcLng === 'number'){
        const dkey = dateKeyFromIso(whenLocal);
        let dayChart = null;

        if (draft.tide_daily_cache?.[dkey]?.chart){
          const chart = draft.tide_daily_cache[dkey].chart;
          const info = tideInfoFromChart(chart, whenLocal);
          catchForm.tide_level_cm    = info.level_cm;
          catchForm.tide_trend       = info.trend_text;
          catchForm.tide_name        = draft.start_tide?.tideName || null;
          catchForm.tide_harbor_name =
            draft.tide_daily_cache[dkey]?.harbor?. hn
            ?? draft.start_tide?.harbor?.hn
            ?? null;
          dayChart = chart;

        } else {
          const startKey = draft.start_tide?.chartDateKey;
          if (startKey && startKey === dkey && draft.start_tide?.chart){
            const chart = draft.start_tide.chart;
            const info = tideInfoFromChart(chart, whenLocal);
            catchForm.tide_level_cm    = info.level_cm;
            catchForm.tide_trend       = info.trend_text;
            catchForm.tide_name        = draft.start_tide?.tideName || null;
            catchForm.tide_harbor_name = draft.start_tide?.harbor?.hn ?? null;

            draft.tide_daily_cache = draft.tide_daily_cache || {};
            draft.tide_daily_cache[dkey] = {
              harbor: draft.start_tide?.harbor || null,
              chart
            };
            dayChart = chart;

          } else {
            try{
              const pack = await getTideChartForDate(tideCalcLat, tideCalcLng, whenLocal);
              if (pack?.chart){
                draft.tide_daily_cache = draft.tide_daily_cache || {};
                draft.tide_daily_cache[dkey] = { harbor: pack.harbor || null, chart: pack.chart };
                const info = tideInfoFromChart(pack.chart, whenLocal);
                catchForm.tide_level_cm    = info.level_cm;
                catchForm.tide_trend       = info.trend_text;
                catchForm.tide_name        = pack.chart?.moon?.title || null;
                catchForm.tide_harbor_name = pack.harbor?.hn ?? draft.start_tide?.harbor?.hn ?? null;
                dayChart = pack.chart;
                LOG.app("[Tide] fetched from Tide736", { lat: tideCalcLat, lng: tideCalcLng, dkey });
              }
            }catch(ex){
              console.warn("[Tide] getTideChartForDate failed:", ex?.message || ex);
            }
          }
        }

        // æº€æ½®/å¹²æ½®ï¼ˆæœ€å¤§2ã¤ï¼‰ã‚’ dayChart ã‹ã‚‰ç¢ºå®š
        if (dayChart){
          const hl = summarizeHighLowTimesFromChart(dayChart);
          catchForm.tide_high_times = hl.high;  // ä¾‹ "04:31ï¼16:52"
          catchForm.tide_low_times  = hl.low;   // ä¾‹ "10:12ï¼22:27"
        }
      }

      // â˜…è¿½åŠ : Catch ã«æ°´æ¸©ã‚’ä»˜ä¸ï¼ˆé–‹å§‹æ™‚ã«å–å¾—æ¸ˆã¿ã®æ°´æ¸©ã‚’ãã®ã¾ã¾æ¡ç”¨ï¼‰
      // å½¢å¼: { temperature_c:number|null, point_name:string|null, date:string|null } ã¾ãŸã¯ null
      catchForm.water_temp = draft.start_water_temp || null;

      // â˜…è¿½åŠ : æ‰‹å‹•å…¥åŠ›ã‹ã‚‰ã®ä¿å­˜æ™‚ã«â€œé‡£è¡Œä¸­â€ã¸è‡ªå‹•é·ç§» & é–‹å§‹æ™‚åˆ»è£œå®Œ
     // â˜…å¤‰æ›´: æ‰‹å‹•å…¥åŠ›ã®ä¿å­˜æ™‚ã¯ start æ™‚åˆ»ã‚’ã“ã“ã§ã¯å…¥ã‚Œãªã„ï¼ˆå¾Œã§è£œå®Œãƒ­ã‚¸ãƒƒã‚¯ã«ä»»ã›ã‚‹ï¼‰
      if (draft.status !== 'active') {
        draft.status = 'active';
        // draft.startedAt ã¯ç©ºã®ã¾ã¾ç¶­æŒï¼ˆnull/undefinedï¼‰
        draft.manualStarted = true;  // æ‰‹å‹•é–‹å§‹ãƒ•ãƒ©ã‚°ã®ã¿è¨­å®š
      }

      LOG.app("Catch (to be saved & uploaded)", {
        id: catchForm.id,
        timestamp: catchForm.timestamp,
        species: catchForm.species,
        size_cm: catchForm.size_cm,
        tide_cm: catchForm.tide_level_cm,
        trend: catchForm.tide_trend,
        tide_name: catchForm.tide_name,
        harbor: catchForm.tide_harbor_name,
        tide_high_times: catchForm.tide_high_times,
        tide_low_times: catchForm.tide_low_times,
        photoFileId: catchForm.photoFileId,
      });

      if (editMode && editingId) {
        const i = draft.catches.findIndex(x => x.id === editingId);
        if (i >= 0) { draft.catches[i] = { ...catchForm, id: editingId }; }
      } else {
        draft.catches.push({ ...catchForm });
      }
      saveDraft(draft);
      closeCatchModal();

      // â˜…ä¿®æ­£â‘ : æ‰‹å‹•é‡£è¡Œæ™‚ã«ç™»éŒ²é‡£æœã‹ã‚‰é–‹å§‹/çµ‚äº†æ™‚åˆ»ã‚’ç®—å‡ºï¼ˆrenderå‰ã«å®Ÿè¡Œï¼‰
      if (manualCatchMode || !!draft.manualStarted) {
        const validTimes = draft.catches
          .map(c => c.timestamp)
          .filter(ts => !!ts);
        
        if (validTimes.length > 0) {
          // â˜…é‡£æœãŒã‚ã‚‹å ´åˆï¼šé‡£æœã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‹ã‚‰æ™‚åˆ»ã‚’è¨­å®š
          const earliestTime = validTimes.reduce((a, b) => a < b ? a : b);
          const latestTime = validTimes.reduce((a, b) => a > b ? a : b);
          
          draft.startedAt = earliestTime;
          draft.endedAt = latestTime;
          saveDraft(draft);
          console.log('[submitCatch] Auto-calculated times from catches:', { startedAt: draft.startedAt, endedAt: draft.endedAt });
        }
        // â˜…é‡£æœãŒãªã„å ´åˆã¯ä½•ã‚‚ã—ãªã„ï¼ˆæ—¢å­˜ã® draft.startedAt/endedAt ã‚’ä¿æŒï¼‰
      }

      render();

      if (!editMode){
        // â˜…å¤‰æ›´ï¼šæ‰‹å‹•é‡£è¡Œä¸­ã¯ timestamp ã‚’ nullï¼ˆæ™‚åˆ»å…¥åŠ›ã¯ç©ºæ¬„ã®ã¾ã¾ï¼‰
        if (manualCatchMode || !!draft.manualStarted) {
          catchForm = { id: uuid(), timestamp: null, species:'', size_cm:null, weight_g:null, method:'', photoPreviewUrl: undefined };
        } else {
          catchForm = { id: uuid(), timestamp: nowIsoLocal(), species:'', size_cm:null, weight_g:null, method:'', photoPreviewUrl: undefined };
        }
      }

      // â˜…å¤‰æ›´ï¼šæ‰‹å‹•ãƒ¢ãƒ¼ãƒ‰æ™‚ã¯ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤ºãªã—ã§è£œå®Œãƒ­ã‚¸ãƒƒã‚¯ã®ã¿ã‚’å®Ÿè¡Œ
      if (manualCatchMode || !!draft.manualStarted) {
        // â˜…ä¿®æ­£ï¼šæ‰‹å‹•é‡£è¡Œãƒ¢ãƒ¼ãƒ‰æ™‚ã¯è£œå®Œå®Œäº†å¾Œã«ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’æ¶ˆã™ï¼ˆã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç¢ºèªã¯è¡¨ç¤ºã—ãªã„ï¼‰
        await _complementTripDataOnly();   // â† ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç”»é¢æ›´æ–°ã®ã¿ã€ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤ºãªã—
        hideUploadingOverlay();
      } else if (!editMode) {
        // â˜…ä¿®æ­£ï¼šé€šå¸¸ã®é‡£æœç™»éŒ²æ™‚ã¯ãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤ºå¾Œã«ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’æ¶ˆã™
        openUploadReview();
        hideUploadingOverlay();
      } else {
        // â˜…ä¿®æ­£ï¼šç·¨é›†ãƒ¢ãƒ¼ãƒ‰æ™‚ã¯å³åº§ã«ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’æ¶ˆã™
        hideUploadingOverlay();
      }
      } catch (e) {
        // â˜…è¿½åŠ ï¼šã‚¨ãƒ©ãƒ¼æ™‚ã‚‚ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’æ¶ˆã™
        hideUploadingOverlay();
        console.error('[submitCatch] error:', e);
      }
    }

    // â˜…è¿½åŠ : JPEG EXIF ã‹ã‚‰ DateTimeOriginal ã‚’èª­ã¿å‡ºã™ï¼ˆ"YYYY:MM:DD HH:mm:ss" ã‚’è¿”ã™ï¼‰
    async function extractExifDate(file) {
      return new Promise((resolve, reject) => {
        try {
          const reader = new FileReader();
          reader.onload = function(e) {
            try {
              const view = new DataView(e.target.result);
              // ---- JPEG APP1 (EXIF) ã‚’æ¢ç´¢ ----
              let offset = 2; // SOI(0xFFD8)å¾Œã‹ã‚‰
              while (offset < view.byteLength) {
                if (view.getUint16(offset) === 0xFFE1) { // APP1
                  // APP1 é•·ã•
                  const len = view.getUint16(offset + 2);
                  // "Exif\0\0" ãƒã‚§ãƒƒã‚¯
                  const exifHeader = offset + 4;
                  if (
                    view.getUint8(exifHeader) === 0x45 && // E
                    view.getUint8(exifHeader + 1) === 0x78 && // x
                    view.getUint8(exifHeader + 2) === 0x69 && // i
                    view.getUint8(exifHeader + 3) === 0x66 && // f
                    view.getUint8(exifHeader + 4) === 0x00 &&
                    view.getUint8(exifHeader + 5) === 0x00
                  ) {
                    const tiff = exifHeader + 6;
                    const little = view.getUint16(tiff) === 0x4949; // "II" or "MM"
                    const get16 = (p)=> view.getUint16(p, little);
                    const get32 = (p)=> view.getUint32(p, little);

                    // 0th IFD
                    const ifd0 = tiff + get32(tiff + 4);
                    const entries0 = get16(ifd0);
                    let exifIFDOffset = 0;

                    // 0th IFD ã®ä¸­ã‹ã‚‰ ExifIFDPointer (0x8769) ã‚’æ¢ã™
                    for (let i=0; i<entries0; i++) {
                      const ent = ifd0 + 2 + 12 * i;
                      const tag = get16(ent);
                      if (tag === 0x8769) { // ExifIFDPointer
                        exifIFDOffset = get32(ent + 8);
                        break;
                      }
                    }
                    if (exifIFDOffset) {
                      const exifIFD = tiff + exifIFDOffset;
                      const exifEntries = get16(exifIFD);
                      for (let i=0; i<exifEntries; i++) {
                        const ent = exifIFD + 2 + 12 * i;
                        const tag = get16(ent);
                        if (tag === 0x9003) { // DateTimeOriginal
                          const type = get16(ent + 2);   // ASCII=2
                          const count = get32(ent + 4);  // é€šå¸¸ 20 ç¨‹åº¦
                          const valOff = get32(ent + 8);
                          const strOff = tiff + valOff;
                          let s = "";
                          for (let j=0; j<count && (strOff + j) < view.byteLength; j++) {
                            const code = view.getUint8(strOff + j);
                            if (code === 0) break;
                            s += String.fromCharCode(code);
                          }
                          resolve(s.trim() || null);
                          return;
                        }
                      }
                    }
                  }
                  offset += 2 + len;
                } else if (view.getUint16(offset) === 0xFFD9) { // EOI
                  break;
                } else {
                  offset += 2 + view.getUint16(offset + 2);
                }
              }
              resolve(null);
            } catch (err) { reject(err); }
          };
          reader.onerror = () => reject(reader.error);
          // å…ˆé ­ 256KB ã¾ã§ã‚’èª­ã‚ã° EXIF ã¯ååˆ†
          reader.readAsArrayBuffer(file.slice(0, 262144));
        } catch (err) { reject(err); }
      });
    }

    // â˜…è¿½åŠ : JPEG EXIF ã‹ã‚‰ GPS ç·¯åº¦çµŒåº¦ã‚’èª­ã¿å‡ºã™ï¼ˆ{lat, lng} ã‚’è¿”ã™ / ãªã‘ã‚Œã° nullï¼‰
    async function extractExifGps(file) {
      return new Promise((resolve, reject) => {
        try {
          const reader = new FileReader();
          reader.onload = function(e) {
            try {
              const view = new DataView(e.target.result);

              let offset = 2;
              while (offset < view.byteLength) {
                if (view.getUint16(offset) === 0xFFE1) { // APP1 EXIF
                  const len = view.getUint16(offset + 2);
                  const exifHeader = offset + 4;
                  const isExif =
                    view.getUint8(exifHeader) === 0x45 &&
                    view.getUint8(exifHeader + 1) === 0x78 &&
                    view.getUint8(exifHeader + 2) === 0x69 &&
                    view.getUint8(exifHeader + 3) === 0x66 &&
                    view.getUint8(exifHeader + 4) === 0x00 &&
                    view.getUint8(exifHeader + 5) === 0x00;

                  if (isExif) {
                    const tiff = exifHeader + 6;
                    const little = view.getUint16(tiff) === 0x4949;
                    const get16 = (p)=> view.getUint16(p, little);
                    const get32 = (p)=> view.getUint32(p, little);

                    // 0th IFD
                    const ifd0 = tiff + get32(tiff + 4);
                    const entries0 = get16(ifd0);
                    let gpsIFDOffset = 0;

                    // 0th IFD å†…ã® GPSIFDPointer (0x8825) ã‚’æ¢ã™
                    for (let i=0; i<entries0; i++) {
                      const ent = ifd0 + 2 + 12 * i;
                      const tag = get16(ent);
                      if (tag === 0x8825) {
                        gpsIFDOffset = get32(ent + 8);
                        break;
                      }
                    }
                    if (!gpsIFDOffset) { resolve(null); return; }

                    // GPS IFD
                    const gpsIFD = tiff + gpsIFDOffset;
                    const gpsEntries = get16(gpsIFD);

                    let latRef = null, lngRef = null;
                    let latArr = null, lngArr = null;

                    const readRational = (base, count=1) => {
                      // numerator/denominator ã®é…åˆ—ã‚’è¿”ã™
                      const arr = [];
                      for (let i=0; i<count; i++) {
                        const num = get32(base + i*8);
                        const den = get32(base + i*8 + 4);
                        arr.push({num, den});
                      }
                      return arr;
                    };

                    for (let i=0; i<gpsEntries; i++) {
                      const ent = gpsIFD + 2 + 12 * i;
                      const tag = get16(ent);
                      const type = get16(ent + 2);
                      const count = get32(ent + 4);
                      const valOff = get32(ent + 8);

                      // ASCII=2, RATIONAL=5
                      if (tag === 0x0001 && type === 2) { // LatitudeRef: "N" / "S"
                        const off = (count <= 4) ? (ent + 8) : (tiff + valOff);
                        latRef = String.fromCharCode(view.getUint8(off)).toUpperCase();
                      }
                      if (tag === 0x0003 && type === 2) { // LongitudeRef: "E" / "W"
                        const off = (count <= 4) ? (ent + 8) : (tiff + valOff);
                        lngRef = String.fromCharCode(view.getUint8(off)).toUpperCase();
                      }
                      if (tag === 0x0002 && type === 5) { // Latitude: 3 rationals
                        const off = tiff + valOff;
                        latArr = readRational(off, 3);
                      }
                      if (tag === 0x0004 && type === 5) { // Longitude: 3 rationals
                        const off = tiff + valOff;
                        lngArr = readRational(off, 3);
                      }
                    }

                    // å¤‰æ›ï¼šåº¦åˆ†ç§’ â†’ 10 é€²
                    const toDeg = (arr, ref) => {
                      if (!arr || arr.length < 3) return null;
                      const d = arr[0].den ? arr[0].num / arr[0].den : 0;
                      const m = arr[1].den ? arr[1].num / arr[1].den : 0;
                      const s = arr[2].den ? arr[2].num / arr[2].den : 0;
                      let v = d + (m / 60) + (s / 3600);
                      if (ref === 'S' || ref === 'W') v = -v;
                      return isFinite(v) ? v : null;
                    };

                    const lat = toDeg(latArr, latRef);
                    const lng = toDeg(lngArr, lngRef);

                    resolve((typeof lat === 'number' && typeof lng === 'number') ? {lat, lng} : null);
                    return;
                  }

                  offset += 2 + len;
                } else if (view.getUint16(offset) === 0xFFD9) { // EOI
                  break;
                } else {
                  offset += 2 + view.getUint16(offset + 2);
                }
              }
              resolve(null);
            } catch (err) { reject(err); }
          };
          reader.onerror = () => reject(reader.error);
          reader.readAsArrayBuffer(file.slice(0, 262144));
        } catch (err) { reject(err); }
      });
    }

    // ===== ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ« =====
    const uploadReviewModal = document.getElementById('uploadReviewModal');
    const uploadReviewBody  = document.getElementById('uploadReviewBody');
    const btnCloseUploadReview = document.getElementById('btnCloseUploadReview');
    const btnCancelUpload = document.getElementById('btnCancelUpload');
    const btnConfirmUpload = document.getElementById('btnConfirmUpload');
    
    // â˜…è¿½åŠ : é‡£è¡Œç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«è¦ç´ 
    const tripEditModal = document.getElementById('tripEditModal');
    const btnCloseTripEdit = document.getElementById('btnCloseTripEdit');
    const btnCancelTripEdit = document.getElementById('btnCancelTripEdit');
    const btnSaveTripEdit = document.getElementById('btnSaveTripEdit');
    const btnAddCatchInEdit = document.getElementById('btnAddCatchInEdit');
    const btnRefetchCompData = document.getElementById('btnRefetchCompData');
    const editTripStarted = document.getElementById('editTripStarted');
    const editTripEnded = document.getElementById('editTripEnded');
    const editTripLat = document.getElementById('editTripLat');
    const editTripLng = document.getElementById('editTripLng');
    const editTripWeather = document.getElementById('editTripWeather');
    const editTripTide = document.getElementById('editTripTide');
    const editTripWaterTemp = document.getElementById('editTripWaterTemp');
    const editCatchList = document.getElementById('editCatchList');
    const editCatchCount = document.getElementById('editCatchCount');
    
    // â˜…è¿½åŠ : æ‰‹å‹•é‡£è¡Œãƒ¢ãƒ¼ãƒ€ãƒ«è¦ç´ 
    const tripModal   = document.getElementById('tripModal');
    const inpTripStart= document.getElementById('inpTripStart');
    const inpTripLat  = document.getElementById('inpTripLat');
    const inpTripLng  = document.getElementById('inpTripLng');
    const btnCloseTripModal = document.getElementById('btnCloseTripModal');
    const btnCancelTripModal = document.getElementById('btnCancelTripModal');
    const btnSaveTrip   = document.getElementById('btnSaveTrip');

    // â˜…ä¿®æ­£ï¼šé‡£è¡Œãƒ¢ãƒ¼ãƒ€ãƒ«ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒœã‚¿ãƒ³
    if (btnCloseTripModal) btnCloseTripModal.onclick = ()=> {
      // â˜…ä¿®æ­£: é‡£è¡Œã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã§åˆ†å²
      if (draft.status === 'active') {
        // é‡£è¡Œä¸­: å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã¿ã‚¯ãƒªã‚¢ â†’ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç”»é¢
        inpTripStart.value = '';
        inpTripLat.value = '';
        inpTripLng.value = '';
        tripModal && tripModal.classList.add('hidden');
        render();
      } else {
        // é‡£è¡Œæœªé–‹å§‹ï¼ˆidleï¼‰: å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼‹å…¨ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢ â†’ ãƒ›ãƒ¼ãƒ 
        inpTripStart.value = '';
        inpTripLat.value = '';
        inpTripLng.value = '';
        draft = { tripId: uuid(), status: 'idle', catches: [], tide_daily_cache: {}, start_water_temp: null, memo: null };
        manualCatchMode = false;
        saveDraft(draft);
        tripModal && tripModal.classList.add('hidden');
        showView('home');
      }
    };
    
    // â˜…è¿½åŠ ï¼šé‡£è¡Œãƒ¢ãƒ¼ãƒ€ãƒ«ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒœã‚¿ãƒ³ï¼ˆãƒ¢ãƒ¼ãƒ€ãƒ«ä¸‹éƒ¨ï¼‰
    if (btnCancelTripModal) btnCancelTripModal.onclick = ()=> {
      // â˜…ä¿®æ­£: é‡£è¡Œã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã§åˆ†å²ï¼ˆÃ—ãƒœã‚¿ãƒ³ã¨åŒã˜å‹•ä½œï¼‰
      if (draft.status === 'active') {
        // é‡£è¡Œä¸­: å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®ã¿ã‚¯ãƒªã‚¢ â†’ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç”»é¢
        inpTripStart.value = '';
        inpTripLat.value = '';
        inpTripLng.value = '';
        tripModal && tripModal.classList.add('hidden');
        render();
      } else {
        // é‡£è¡Œæœªé–‹å§‹ï¼ˆidleï¼‰: å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼‹å…¨ãƒ‡ãƒ¼ã‚¿ã‚¯ãƒªã‚¢ â†’ ãƒ›ãƒ¼ãƒ 
        inpTripStart.value = '';
        inpTripLat.value = '';
        inpTripLng.value = '';
        draft = { tripId: uuid(), status: 'idle', catches: [], tide_daily_cache: {}, start_water_temp: null, memo: null };
        manualCatchMode = false;
        saveDraft(draft);
        tripModal && tripModal.classList.add('hidden');
        showView('home');
      }
    };
    
    // â˜…è¿½åŠ ï¼šrecordView ä¸‹éƒ¨ãƒãƒ¼ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒœã‚¿ãƒ³ï¼ˆé‡£è¡Œä¸­ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«ï¼‰
    const btnCancelTrip = document.getElementById('btnCancelTrip');
    if (btnCancelTrip) {
      btnCancelTrip.onclick = cancelTripAndReturnHome;
    };
    
    if (btnSaveTrip)   btnSaveTrip.onclick   = submitManualTrip;

    btnCloseUploadReview.onclick = () => { pendingEnd=null; uploadReviewModal.classList.add('hidden'); };
    btnCancelUpload.onclick      = () => { 
      isUploading = false;
      pendingEnd=null; 
      uploadReviewModal.classList.add('hidden'); 
    };

    btnConfirmUpload.onclick = async ()=>{
      // â˜…è¿½åŠ ï¼šå¤šé‡ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰é˜²æ­¢
      if (isUploading) return;
      
      // â˜…ä¿®æ­£ï¼šå…±é€šé–¢æ•°ã§ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’è¡¨ç¤ºï¼ˆã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸­ãƒ†ã‚­ã‚¹ãƒˆï¼‰
      showUploadingOverlay('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸­...');

      const enqueue = async (payload) => {
        // IndexedDB ãŒåˆ©ç”¨å¯èƒ½ãªã‚‰å„ªå…ˆ
        if (db) {
          try {
            const tx = db.transaction(UPLOAD_QUEUE_STORE, 'readwrite');
            const store = tx.objectStore(UPLOAD_QUEUE_STORE);
            const item = {
              tripId: draft.tripId,
              payload: payload,
              timestamp: Date.now(),
              retries: 0
            };
            const req = store.add(item);
            req.onsuccess = () => {
              console.log('[Upload] Queued to IndexedDB:', item);
            };
            req.onerror = () => {
              console.warn('[Upload] IndexedDB queue failed, trying localStorage');
              // IndexedDB å¤±æ•—æ™‚ã®ã¿ localStorage ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
              try {
                const key = 'fishlog_upload_queue_v1';
                const q = JSON.parse(localStorage.getItem(key) || '[]');
                q.push({ t: Date.now(), payload });
                localStorage.setItem(key, JSON.stringify(q));
                console.log('[Upload] Queued locally (localStorage fallback)');
              } catch (lsError) {
                console.warn('[Upload] Both IndexedDB and localStorage failed:', lsError.message);
                // ä¸¡æ–¹å¤±æ•—ã—ãŸå ´åˆã¯ãƒ¡ãƒ¢ãƒªã®ã¿
              }
            };
          } catch (e) {
            console.warn('[Upload] IndexedDB transaction error:', e.message);
            // IndexedDB ã‚¨ãƒ©ãƒ¼æ™‚ã¯ localStorage ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
            try {
              const key = 'fishlog_upload_queue_v1';
              const q = JSON.parse(localStorage.getItem(key) || '[]');
              q.push({ t: Date.now(), payload });
              localStorage.setItem(key, JSON.stringify(q));
              console.log('[Upload] Queued locally (localStorage fallback)');
            } catch (lsError) {
              console.warn('[Upload] localStorage also unavailable:', lsError.message);
            }
          }
        } else {
          // db ãŒãªã„å ´åˆã¯ localStorage ã®ã¿è©¦è¡Œï¼ˆå¤±æ•—ã—ã¦ã‚‚ç„¡è¦–ï¼‰
          try {
            const key = 'fishlog_upload_queue_v1';
            const q = JSON.parse(localStorage.getItem(key) || '[]');
            q.push({ t: Date.now(), payload });
            localStorage.setItem(key, JSON.stringify(q));
            console.log('[Upload] Queued locally (localStorage, no IndexedDB)');
          } catch (e) {
            console.warn('[Upload] localStorage unavailable, queue will be lost:', e.message);
            // localStorage ã‚‚ãªã„å ´åˆã¯ã‚­ãƒ¥ãƒ¼ãŒå¤±ã‚ã‚Œã‚‹ï¼ˆã“ã‚Œã¯æœŸå¾…å‹•ä½œï¼‰
          }
        }
      };
      const clearDraftAndUI = ()=>{
        // â˜…ä¿®æ­£ï¼šå…±é€šé–¢æ•°ã§ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’æ¶ˆã™
        hideUploadingOverlay();
        uploadReviewModal.classList.add('hidden');
        pendingEnd = null;
        draft = { tripId: uuid(), status: 'idle', catches: [], tide_daily_cache: {}, start_water_temp: null, memo: null };
        saveDraft(draft);

        // â˜…è¿½åŠ ï¼šæ‰‹å‹•ãƒ¢ãƒ¼ãƒ‰è§£é™¤
        manualCatchMode = false;

        render();
        showView('home');
        alert('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ãŒå®Œäº†ã—ã¾ã—ãŸã€‚');
      };

      try{
        if (pendingEnd){
          draft.status = 'ended';
          draft.endedAt = pendingEnd.endedAt;
          draft.end_weather = pendingEnd.end_weather || null;
          saveDraft(draft);
        }
        
        // â˜…è¿½åŠ ï¼šãƒ¡ãƒ¢ã‚’draftã«ä¿å­˜ï¼ˆã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç›´å‰ï¼‰
        const tripMemoInput = document.getElementById('tripMemoInput');
        if (tripMemoInput) {
          draft.memo = tripMemoInput.value.trim() || null;
          saveDraft(draft);
        }
        
        const payload = buildTripPayload(draft);

        // ãƒ‡ãƒãƒƒã‚°ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆæ—¢å­˜ï¼‰
        try {
          const preview = (payload.catches || []).map(c => ({
            id: c.id, ts: c.timestamp, sp: c.species, size: c.size_cm,
            tide_cm: c.tide_level_cm, trend: c.tide_trend, tide_name: c.tide_name,
            harbor: c.tide_harbor_name, tide_high_times: c.tide_high_times, tide_low_times: c.tide_low_times, photoId: c.photoFileId
          }));
          LOG.app("Upload payload (Catches preview)", preview);
          if (console?.table) console.table(preview);
        } catch(_){}

        const res = await fetch(CONFIG.API.FISHING_TRIP_API_WORKER + '/api/upload', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', 'X-Auth-Token': CONFIG.API.WORKERS_AUTH_TOKEN },
          body: JSON.stringify(payload)
        });
        const text = await res.text();
        if (!res.ok) throw new Error(`HTTP ${res.status}: ${text.slice(0,200)}`);

        // æˆåŠŸ
        clearDraftAndUI();

      }catch(e){
        // å¤±æ•— â†’ ã‚­ãƒ¥ãƒ¼ä¿å­˜
        try{
          const payload = buildTripPayload(draft);
          enqueue(payload);
          clearDraftAndUI();
          alert('ã‚ªãƒ•ãƒ©ã‚¤ãƒ³/ã‚¨ãƒ©ãƒ¼ã®ãŸã‚é€ä¿¡å¾…ã¡ã‚­ãƒ¥ãƒ¼ã«ä¿å­˜ã—ã¾ã—ãŸã€‚ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å¾©å¸°å¾Œã«è‡ªå‹•å†é€ã—ã¾ã™ã€‚');
        }catch{
          isUploading = false;
          uploadingOverlay.classList.add('hidden');
          alert('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯/ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
        }
      }
    };

    function buildTripPayload(d, action = 'create'){
      // â˜…ä¿®æ­£ï¼šspecies ãŒç©ºã®é‡£æœï¼ˆæœªå…¥åŠ›ï¼‰ã¯ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
      const validCatches = (d.catches||[]).filter(c => c.species && String(c.species).trim());
      
      return {
        action: action,  // â˜…è¿½åŠ ï¼šã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆ'create' ã¾ãŸã¯ 'update'ï¼‰
        tripId: d.tripId,
        status: d.status,
        startedAt: d.startedAt,
        endedAt: d.endedAt,
        position: (typeof d.lat==='number' && typeof d.lng==='number') ? {lat:d.lat, lng:d.lng} : null,
        start_weather: d.start_weather || null,
        end_weather: d.end_weather || null,
        start_tide: d.start_tide || null,
        water_temp_c: d.start_water_temp?.temperature_c ?? null,
        water_temp_point: d.start_water_temp?.point_name ?? null,
        water_temp_time: d.start_water_temp?.date ?? null,
        memo: d.memo || null,  // â˜…è¿½åŠ ï¼šãƒ¡ãƒ¢
        catches: validCatches.map(c => {
          // â˜…è£œå®Œï¼šæ—¢å­˜é‡£æœã‹ã‚‰ä¸è¶³ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è£œå®Œ
          const sw = c.weather || d.start_weather || {};
          const tide = c.tide_name && c.tide_harbor_name ? {
            tide_name: c.tide_name,
            tide_harbor_name: c.tide_harbor_name,
            tide_high_times: c.tide_high_times,
            tide_low_times: c.tide_low_times
          } : null;
          
          return {
            id: c.id || uuid(),  // â˜…è¿½åŠ ï¼šid ãŒç„¡ã„å ´åˆã¯ç”Ÿæˆ
            timestamp: c.timestamp,
            species: c.species,
            size_cm: c.size_cm,
            weight_g: c.weight_g,
            method: c.method,
            
            // â˜…è¿½åŠ ï¼šå¤©æ°—æƒ…å ±ï¼ˆé‡£è¡Œã®é–‹å§‹å¤©æ°—ã‹ã‚‰è£œå®Œï¼‰
            wx_temp: (c.wx_temp !== undefined && c.wx_temp !== null) ? c.wx_temp : (sw.temp ?? null),
            wx_wind_speed: (c.wx_wind_speed !== undefined && c.wx_wind_speed !== null) ? c.wx_wind_speed : (sw.wind_speed ?? null),
            wx_wind_deg: (c.wx_wind_deg !== undefined && c.wx_wind_deg !== null) ? c.wx_wind_deg : (sw.wind_deg ?? null),
            wx_main: c.wx_main || (sw.weather_main ?? null),
            wx_desc: c.wx_desc || (sw.weather_description ?? null),
            
            // â˜…è¿½åŠ ï¼šæ½®æ±æƒ…å ±
            tide_level_cm: c.tide_level_cm ?? null,
            tide_trend: c.tide_trend ?? null,
            tide_name: c.tide_name ?? (d.start_tide?.tideName ?? null),
            tide_harbor_name: c.tide_harbor_name ?? (d.start_tide?.harbor?.hn ?? null),
            tide_high_times: c.tide_high_times ?? (d.start_tide?.high_times ?? null),
            tide_low_times: c.tide_low_times ?? (d.start_tide?.low_times ?? null),
            
            // â˜…è¿½åŠ ï¼šæ°´æ¸©æƒ…å ±
            water_temp_c: (c.water_temp_c !== undefined && c.water_temp_c !== null) ? c.water_temp_c : (d.start_water_temp?.temperature_c ?? null),
            water_temp_point: c.water_temp_point || (d.start_water_temp?.point_name ?? null),
            water_temp_time: c.water_temp_time || (d.start_water_temp?.date ?? null),
            
            // å†™çœŸæƒ…å ±
            photoFileId: c.photoFileId || null,
            photoDriveUrl: c.photoDriveUrl || null,
            photoDriveThumbUrl: c.photoDriveThumbUrl || null,
            
            // å¾Œæ–¹äº’æ›ã‚­ãƒ¼
            weather: c.weather || null,
            water_temp: c.water_temp ?? null
          };
        }),
        
        // â˜…è¿½åŠ ï¼šæ½®æ±ãƒãƒ£ãƒ¼ãƒˆç”»åƒæƒ…å ±
        tide_chart_images: d.tide_chart_images || []
      };
    }

    // çµ‚äº†å‰ãƒ¬ãƒ“ãƒ¥ãƒ¼
    function openUploadReview(){
      const cts = draft.catches||[];
      const sum = document.createElement('div');
      sum.className = 'space-y-3';

        // â˜…ç¢ºèªç”¨ãƒ­ã‚°
      LOG.app("[UploadReview] snapshot", {
        hasStartWeather: !!draft.start_weather,
        hasStartTide: !!draft.start_tide,
        startedAt: draft.startedAt || null,
        lat: draft.lat, lng: draft.lng
      });

      const endAtDisplay = pendingEnd?.endedAt ? new Date(pendingEnd.endedAt).toLocaleString() : (draft.endedAt ? new Date(draft.endedAt).toLocaleString() : 'â€”');
      const head = document.createElement('div');
      head.innerHTML =
        `<div class="text-slate-300">Trip ID: <span class="text-slate-100">${draft.tripId.slice(0,8)}</span></div>
        <div class="text-slate-300">é–‹å§‹: <span class="text-slate-100">${draft.startedAt?new Date(draft.startedAt).toLocaleString():'â€”'}</span></div>
        <div class="text-slate-300">çµ‚äº†: <span class="text-slate-100">${endAtDisplay}</span></div>
        <div class="text-slate-300">ä»¶æ•°: <span class="text-slate-100">${cts.length}</span></div>`;
      sum.appendChild(head);

      const wx = document.createElement('div');
      wx.className='grid grid-cols-1 sm:grid-cols-2 gap-2';
      const boxWx = (label, val) => {
        const d=document.createElement('div'); d.className='rounded-xl bg-slate-800/40 p-3';
        d.innerHTML = `<div class="text-xs text-slate-400">${label}</div>
                      <div class="text-sm text-slate-200 mt-0.5">${val||'â€”'}</div>`;
        return d;
      };
      const sw = draft.start_weather ? formatWeatherBrief(draft.start_weather) : null;
      const ew = pendingEnd?.end_weather || draft.end_weather ? formatWeatherBrief(pendingEnd?.end_weather || draft.end_weather) : null;
      const st = draft.start_tide ? `${draft.start_tide.tideName} / ${draft.start_tide.trendText}` : null;
      const wt = draft.start_water_temp && draft.start_water_temp.temperature_c!=null
        ? `${draft.start_water_temp.temperature_c}â„ƒ${draft.start_water_temp.point_name?`ï¼ˆ${draft.start_water_temp.point_name}ï¼‰`:''}`
        : null;

      wx.appendChild(boxWx('é–‹å§‹æ™‚ã®å¤©æ°—', sw));
      wx.appendChild(boxWx('çµ‚äº†æ™‚ã®å¤©æ°—', ew));
      wx.appendChild(boxWx('é–‹å§‹æ™‚ã®æ½®', st));
      wx.appendChild(boxWx('å½“æ—¥ã®æ°´æ¸©', wt));
      sum.appendChild(wx);

      if (draft.start_tide?.chart){
        const tideWrap = document.createElement('div');
        tideWrap.className = 'rounded-2xl border border-slate-800 bg-slate-900 p-3';
        const harborName = draft.start_tide?.harbor?.hn || '';
        const dateKey    = draft.start_tide?.chartDateKey || '';
        const title = document.createElement('div');
        title.className = 'text-sm text-slate-300 mb-2';
        title.textContent = `é–‹å§‹æ—¥ã®æ½®æ±ã‚°ãƒ©ãƒ• ${harborName ? `ï¼ˆ${harborName}ï¼‰` : ''} ${dateKey ? `- ${dateKey}`:''}`;
        tideWrap.appendChild(title);
        const canvas = document.createElement('canvas');
        canvas.className = 'w-full h-[260px] bg-slate-950 rounded-lg';
        tideWrap.appendChild(canvas);
        sum.appendChild(tideWrap);
        setTimeout(()=> drawTideChartOnCanvas(canvas, draft.start_tide.chart), 0);
      }

      const list = document.createElement('div');
      list.className='divide-y divide-slate-800 rounded-xl border border-slate-800';
      cts.forEach((c, idx)=>{
        const row=document.createElement('div'); row.className='p-3 text-sm';
        const t   = c.timestamp? new Date(c.timestamp).toLocaleString(): '';
        const wxs = c.weather? formatWeatherBrief(c.weather): '';
        row.innerHTML =
          `<div class="font-semibold text-slate-100">${c.species||'(é­šç¨®æœªè¨­å®š)'} <span class="text-slate-400 text-xs ml-2">${t}</span></div>
          <div class="text-slate-300 mt-1">${[c.size_cm!=null?`ã‚µã‚¤ã‚º:${c.size_cm}cm`:null, c.weight_g!=null?`é‡é‡:${c.weight_g}g`:null, c.method||null].filter(Boolean).join(' / ')}</div>
          <div class="text-slate-400 text-xs mt-1">${wxs}</div>`;
      list.appendChild(row);
      });
      sum.appendChild(list);

      uploadReviewBody.innerHTML=''; uploadReviewBody.appendChild(sum);
      
      // â˜…è¿½åŠ ï¼šãƒ¡ãƒ¢å…¥åŠ›æ¬„ã‚’åˆæœŸåŒ–ï¼ˆæ—¢å­˜ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Œã°è¡¨ç¤ºï¼‰
      const tripMemoInput = document.getElementById('tripMemoInput');
      if (tripMemoInput) {
        tripMemoInput.value = draft.memo || '';
      }
      
      uploadReviewModal.classList.remove('hidden');
    }

    // â˜…è¿½åŠ : ä¸è¶³æƒ…å ±ã®ä¿ç®¡ï¼ˆæœ€å°å®Ÿè£…ï¼‰
    //  - ä½ç½®æƒ…å ±: EXIFã®ã‚ã‚‹é‡£æœã‹ã‚‰åˆå›ã®ç·¯åº¦çµŒåº¦ã‚’æ¡ç”¨
    //  - ï¼ˆå¤©å€™/æ½®æ±/æ°´æ¸©ã¯æ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯æº–æ‹ ã€‚å¿…è¦ã«å¿œã˜ã¦æ‹¡å¼µäºˆå®šï¼‰
    function completeMissingTripInfoIfNeeded() {
      try {
        const needPos = !(typeof draft.lat === 'number' && typeof draft.lng === 'number');
        if (needPos && Array.isArray(draft.catches)) {
          const base = draft.catches.find(c =>
            typeof c.exif_lat === 'number' && typeof c.exif_lng === 'number'
          );
          if (base) {
            draft.lat = base.exif_lat;
            draft.lng = base.exif_lng;
            LOG.app("[Complete] ä½ç½®æƒ…å ±ã‚’EXIFã‹ã‚‰è£œå®Œ:", { lat: draft.lat, lng: draft.lng });
          }
        }
      } finally {
        saveDraft(draft);
      }
    }

    // â˜…æ–°è¦è¿½åŠ : è£œå®Œãƒ­ã‚¸ãƒƒã‚¯ã®ã¿ã‚’å®Ÿè¡Œï¼ˆãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤ºãªã—ï¼‰
    // submitCatch() ã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã€ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç”»é¢ã®æ›´æ–°ã®ã¿ã‚’è¡Œã†
    async function _complementTripDataOnly(){
      // â˜…ä¿®æ­£ï¼šCONFIGåˆæœŸåŒ–å®Œäº†ã‚’å¾…æ©Ÿï¼ˆAPIå‘¼ã³å‡ºã—å‰ã®å¿…é ˆå‡¦ç†ï¼‰
      await configInitPromise;
      
      try {
        completeMissingTripInfoIfNeeded();

        LOG.app("[TripData] calling complementTripFromCatches(force=true)");
        await complementTripFromCatches(true);

        // â˜…è¿½åŠ ï¼šæ‰‹å‹•é‡£æœãƒ¢ãƒ¼ãƒ‰æ™‚ã€å…¨ã¦ã®é‡£æœã«å¯¾ã—ã¦æ½®æ±æƒ…å ±ã‚’è£œå®Œ
        if ((manualCatchMode || draft.manualStarted) && Array.isArray(draft.catches)) {
          LOG.app("[TripData] è£œå®Œæœªæ¸ˆã®é‡£æœã«å¯¾ã—ã¦æ½®æ±æƒ…å ±ã‚’è£œå®Œé–‹å§‹", {
            catches: draft.catches.length,
            hasPos: (typeof draft.lat === 'number' && typeof draft.lng === 'number')
          });
          
          for (let i = 0; i < draft.catches.length; i++) {
            const catch_rec = draft.catches[i];
            
            // æ—¢ã«æ½®æ±æƒ…å ±ãŒã‚ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
            if (catch_rec.tide_level_cm != null && catch_rec.tide_trend != null) {
              LOG.app("[TripData] é‡£æœ[" + i + "]ã¯æ—¢ã«æ½®æ±æƒ…å ±ã‚ã‚Šã€ã‚¹ã‚­ãƒƒãƒ—");
              continue;
            }
            
            // æ½®æ±è¨ˆç®—ã«å¿…è¦ãªæƒ…å ±ã‚’ç¢ºèª
            if (!catch_rec.timestamp) {
              LOG.app("[TripData] é‡£æœ[" + i + "]ã¯ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ãªã—ã€ã‚¹ã‚­ãƒƒãƒ—");
              continue;
            }
            
            // ä½ç½®æƒ…å ±ï¼šEXIFå„ªå…ˆã€ãªã‘ã‚Œã°ä»£è¡¨ä½ç½®
            let calc_lat = null, calc_lng = null;
            if (typeof catch_rec.exif_lat === 'number' && typeof catch_rec.exif_lng === 'number') {
              calc_lat = catch_rec.exif_lat;
              calc_lng = catch_rec.exif_lng;
            } else if (typeof draft.lat === 'number' && typeof draft.lng === 'number') {
              calc_lat = draft.lat;
              calc_lng = draft.lng;
            }
            
            if (calc_lat == null || calc_lng == null) {
              LOG.app("[TripData] é‡£æœ[" + i + "]ã¯ä½ç½®æƒ…å ±ãªã—ã€ã‚¹ã‚­ãƒƒãƒ—");
              continue;
            }
            
            // æ½®æ±ãƒ‡ãƒ¼ã‚¿å–å¾—
            try {
              const dkey = dateKeyFromIso(catch_rec.timestamp);
              let chart_data = null;
              
              // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç¢ºèª
              if (draft.tide_daily_cache?.[dkey]?.chart) {
                chart_data = draft.tide_daily_cache[dkey].chart;
                LOG.app("[TripData] é‡£æœ[" + i + "]ã¯æ½®æ±ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å–å¾—");
              } else {
                // Tide736ã‹ã‚‰å–å¾—
                const pack = await getTideChartForDate(calc_lat, calc_lng, catch_rec.timestamp);
                if (pack?.chart) {
                  chart_data = pack.chart;
                  draft.tide_daily_cache = draft.tide_daily_cache || {};
                  draft.tide_daily_cache[dkey] = { harbor: pack.harbor || null, chart: pack.chart };
                  LOG.app("[TripData] é‡£æœ[" + i + "]ã¯ Tide736 ã‹ã‚‰æ–°è¦å–å¾—", { lat: calc_lat, lng: calc_lng });
                }
              }
              
              if (chart_data) {
                const info = tideInfoFromChart(chart_data, catch_rec.timestamp);
                catch_rec.tide_level_cm    = info.level_cm;
                catch_rec.tide_trend       = info.trend_text;
                catch_rec.tide_name        = chart_data?.moon?.title || null;
                
                // æ¸¯åã‚’è£œå®Œ
                if (!catch_rec.tide_harbor_name) {
                  catch_rec.tide_harbor_name = 
                    draft.tide_daily_cache?.[dkey]?.harbor?.hn 
                    ?? draft.start_tide?.harbor?.hn 
                    ?? null;
                }
                
                // æº€æ½®/å¹²æ½®ã‚¿ã‚¤ãƒ ã‚¹
                const hl = summarizeHighLowTimesFromChart(chart_data);
                catch_rec.tide_high_times = hl.high;
                catch_rec.tide_low_times  = hl.low;
                
                LOG.app("[TripData] é‡£æœ[" + i + "]ã«æ½®æ±æƒ…å ±ã‚’è£œå®Œ", {
                  tide_level_cm: catch_rec.tide_level_cm,
                  tide_trend: catch_rec.tide_trend,
                  harbor: catch_rec.tide_harbor_name
                });
              }
            } catch (ex) {
              console.warn("[TripData] é‡£æœ[" + i + "]ã®æ½®æ±è£œå®Œå¤±æ•—:", ex?.message || ex);
            }
          }
          
          saveDraft(draft);
          LOG.app("[TripData] å…¨é‡£æœã®æ½®æ±è£œå®Œå®Œäº†");
        }

        LOG.app("[TripData] complementTripFromCatches completed", {
          startedAt: draft.startedAt || null,
          endedAt: draft.endedAt || null,
          lat: draft.lat, lng: draft.lng,
          hasStartTide: !!draft.start_tide
        });
      } catch(e) {
        console.warn("[TripData] complement failed:", e?.message || e);
      }

      // â˜…ä¿®æ­£â‘¡: é‡£è¡Œçµ‚äº†ãƒœã‚¿ãƒ³æŠ¼ä¸‹æ™‚ã€é‡£æœãŒã‚ã‚‹å ´åˆã®ã¿æ™‚åˆ»ã‚’å†è¨ˆç®—
      // â˜…é‡è¦: render() ã® BEFORE ã«å®Ÿè¡Œã—ã€æ­£ç¢ºãªæ™‚åˆ»ã‚’ draft ã«è¨­å®šã—ã¦ã‹ã‚‰ç”»é¢ã‚’æç”»
      if (draft.manualStarted) {
        const validTimes = draft.catches && Array.isArray(draft.catches)
          ? draft.catches.map(c => c.timestamp).filter(ts => !!ts)
          : [];
        
        if (validTimes.length > 0) {
          // â˜…é‡£æœãŒã‚ã‚‹å ´åˆã®ã¿ã€æ™‚åˆ»ã‚’å†è¨ˆç®—ãƒ»ä¸Šæ›¸ã
          const earliestTime = validTimes.reduce((a, b) => a < b ? a : b);
          const latestTime = validTimes.reduce((a, b) => a > b ? a : b);
          draft.startedAt = earliestTime;
          draft.endedAt = latestTime;
          console.log('[TripData] Auto-calculated from catches:', { startedAt: draft.startedAt, endedAt: draft.endedAt });
        }
        // â˜…é‡£æœãŒãªã„å ´åˆã¯ã€æ—¢ã«è¨­å®šã•ã‚Œã¦ã„ã‚‹ draft.startedAt/endedAt ã‚’ãã®ã¾ã¾ä¿æŒ
        saveDraft(draft);
      }

      // â˜…æ–°è¦è¿½åŠ : è£œå®Œå®Œäº†å¾Œã€å…¨ã¦ã®æƒ…å ±ãŒæƒã£ã¦ã‹ã‚‰ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç”»é¢ã‚’å†æç”»
      render();
    }

    async function openTripReview(){
      // â˜…ä¿®æ­£ï¼šCONFIGåˆæœŸåŒ–å®Œäº†ã‚’å¾…æ©Ÿï¼ˆAPIå‘¼ã³å‡ºã—å‰ã®å¿…é ˆå‡¦ç†ï¼‰
      await configInitPromise;
      
      // â˜…è¿½åŠ ï¼šå¤šé‡å‘¼ã³å‡ºã—é˜²æ­¢
      if (isUploading) {
        alert('å‡¦ç†ã¯æ—¢ã«é€²è¡Œä¸­ã§ã™ã€‚ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„ã€‚');
        return;
      }
      
      // â˜…ä¿®æ­£ï¼šå…±é€šé–¢æ•°ã§ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’è¡¨ç¤ºï¼ˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æŒ‡å®šï¼‰
      showUploadingOverlay('ãƒ‡ãƒ¼ã‚¿ã‚’æº–å‚™ä¸­...');

      // â˜…ãƒ­ã‚°è¿½åŠ ï¼šopenTripReview ã®å‘¼ã³å‡ºã—ã‚’è¨˜éŒ²
      LOG.app("[TripReview] openTripReview called", {
        manualCatchMode,
        manualStarted: !!draft.manualStarted,
        status: draft.status,
        catches: Array.isArray(draft.catches) ? draft.catches.length : 0,
        startedAt: draft.startedAt || null,
        endedAt: draft.endedAt || null
      });

      // â˜…ä¿®æ­£: è£œå®Œãƒ­ã‚¸ãƒƒã‚¯ã‚’ _complementTripDataOnly() ã«çµ±åˆ
      await _complementTripDataOnly();

      // â˜…ä¿®æ­£ï¼šæ‰‹å‹•é‡£è¡Œã§ã‚‚çµ‚äº†å¤©æ°—ã‚’å–å¾—ã—ã¦ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç¢ºèªã¸
      if (draft.manualStarted) {
        let endWx = null;
        if (typeof draft.lat === 'number' && typeof draft.lng === 'number'){
          try { endWx = await fetchWeather(draft.lat, draft.lng, draft.endedAt); } catch(e){ console.error('[4747] fetchWeather error:', e); }
        }
        draft.end_weather = endWx || null;
        
        // â˜…è¿½åŠ ï¼šæ½®æ±ãƒãƒ£ãƒ¼ãƒˆç”»åƒã‚’å–å¾—ãƒ»ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
        console.log('[openTripReview] Fetching tide images for manual trip');
        try {
          const tideResult = await fetchAndUploadTideImages(draft.startedAt, draft.endedAt);
          console.log('[openTripReview] Tide image fetch completed:', tideResult);
          if (tideResult.ok && tideResult.images.length > 0) {
            draft.tide_chart_images = tideResult.images;
            console.log('[openTripReview] Stored', tideResult.images.length, 'tide chart images');
          }
        } catch (err) {
          console.warn('[openTripReview] Tide image fetch error:', err);
        }
        
        saveDraft(draft);

        // â˜…ä¿®æ­£â‘¢: openUploadReview()å‘¼ã³å‡ºã—å‰ã«ç™»éŒ²é‡£æœã®ãƒ‡ãƒ¼ã‚¿ã§ç”»é¢ã‚’æ›´æ–°
        // ãƒ¢ãƒ¼ãƒ€ãƒ«ãŒæ—¢ã«è¡¨ç¤ºä¸­ã§ã‚‚ã€æœ€æ–°ã®ç™»éŒ²é‡£æœãƒ‡ãƒ¼ã‚¿ã§å†…å®¹ã‚’ä¸Šæ›¸ãæ›´æ–°
        const cts_manual = draft.catches||[];
        const sum_manual = document.createElement('div');
        sum_manual.className = 'space-y-3';

        const endAtDisplay_manual = draft.endedAt ? new Date(draft.endedAt).toLocaleString() : 'â€”';
        const head_manual = document.createElement('div');
        head_manual.innerHTML =
          `<div class="text-slate-300">Trip ID: <span class="text-slate-100">${draft.tripId.slice(0,8)}</span></div>
          <div class="text-slate-300">é–‹å§‹: <span class="text-slate-100">${draft.startedAt?new Date(draft.startedAt).toLocaleString():'â€”'}</span></div>
          <div class="text-slate-300">çµ‚äº†: <span class="text-slate-100">${endAtDisplay_manual}</span></div>
          <div class="text-slate-300">ä»¶æ•°: <span class="text-slate-100">${cts_manual.length}</span></div>`;
        sum_manual.appendChild(head_manual);

        const wx_manual = document.createElement('div');
        wx_manual.className='grid grid-cols-1 sm:grid-cols-2 gap-2';
        const boxWx_manual = (label, val) => {
          const d=document.createElement('div'); d.className='rounded-xl bg-slate-800/40 p-3';
          d.innerHTML = `<div class="text-xs text-slate-400">${label}</div>
                        <div class="text-sm text-slate-200 mt-0.5">${val||'â€”'}</div>`;
          return d;
        };
        const sw_manual = draft.start_weather ? formatWeatherBrief(draft.start_weather) : null;
        const ew_manual = draft.end_weather ? formatWeatherBrief(draft.end_weather) : null;
        const st_manual = draft.start_tide ? `${draft.start_tide.tideName} / ${draft.start_tide.trendText}` : null;
        const wt_manual = draft.start_water_temp && draft.start_water_temp.temperature_c!=null
          ? `${draft.start_water_temp.temperature_c}â„ƒ${draft.start_water_temp.point_name?`ï¼ˆ${draft.start_water_temp.point_name}ï¼‰`:''}`
          : null;

        wx_manual.appendChild(boxWx_manual('é–‹å§‹æ™‚ã®å¤©æ°—', sw_manual));
        wx_manual.appendChild(boxWx_manual('çµ‚äº†æ™‚ã®å¤©æ°—', ew_manual));
        wx_manual.appendChild(boxWx_manual('é–‹å§‹æ™‚ã®æ½®', st_manual));
        wx_manual.appendChild(boxWx_manual('å½“æ—¥ã®æ°´æ¸©', wt_manual));
        sum_manual.appendChild(wx_manual);

        if (draft.start_tide?.chart){
          const tideWrap_manual = document.createElement('div');
          tideWrap_manual.className = 'rounded-2xl border border-slate-800 bg-slate-900 p-3';
          const harborName_manual = draft.start_tide?.harbor?.hn || '';
          const dateKey_manual    = draft.start_tide?.chartDateKey || '';
          const title_manual = document.createElement('div');
          title_manual.className = 'text-sm text-slate-300 mb-2';
          title_manual.textContent = `é–‹å§‹æ—¥ã®æ½®æ±ã‚°ãƒ©ãƒ• ${harborName_manual ? `ï¼ˆ${harborName_manual}ï¼‰` : ''} ${dateKey_manual ? `- ${dateKey_manual}`:''}`;
          tideWrap_manual.appendChild(title_manual);
          const canvas_manual = document.createElement('canvas');
          canvas_manual.className = 'w-full h-[260px] bg-slate-950 rounded-lg';
          tideWrap_manual.appendChild(canvas_manual);
          sum_manual.appendChild(tideWrap_manual);
          setTimeout(()=> drawTideChartOnCanvas(canvas_manual, draft.start_tide.chart), 0);
        }

        const list_manual = document.createElement('div');
        list_manual.className='divide-y divide-slate-800 rounded-xl border border-slate-800';
        cts_manual.forEach((c, idx)=>{
          const row_manual=document.createElement('div'); row_manual.className='p-3 text-sm';
          const t_manual   = c.timestamp? new Date(c.timestamp).toLocaleString(): '';
          const wxs_manual = c.weather? formatWeatherBrief(c.weather): '';
          row_manual.innerHTML =
            `<div class="font-semibold text-slate-100">${c.species||'(é­šç¨®æœªè¨­å®š)'} <span class="text-slate-400 text-xs ml-2">${t_manual}</span></div>
            <div class="text-slate-300 mt-1">${[c.size_cm!=null?`ã‚µã‚¤ã‚º:${c.size_cm}cm`:null, c.weight_g!=null?`é‡é‡:${c.weight_g}g`:null, c.method||null].filter(Boolean).join(' / ')}</div>
            <div class="text-slate-400 text-xs mt-1">${wxs_manual}</div>`;
          list_manual.appendChild(row_manual);
        });
        sum_manual.appendChild(list_manual);

        uploadReviewBody.innerHTML=''; uploadReviewBody.appendChild(sum_manual);
        uploadReviewModal.classList.remove('hidden');

        pendingEnd = null;
        // â˜…ä¿®æ­£ï¼šå…±é€šé–¢æ•°ã§ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’æ¶ˆã™
        hideUploadingOverlay();
        return;
      }

      // å¾“æ¥ã®çµ‚äº†æ™‚å¤©æ°—å–å¾—
      let endWx = null;
      const endedAtTime = nowIsoLocal();
      if (typeof draft.lat === 'number' && typeof draft.lng === 'number'){
        try { endWx = await fetchWeather(draft.lat, draft.lng, new Date(endedAtTime)); } catch(e){ console.error('[4775] fetchWeather error:', e); }
      }
      pendingEnd = { endedAt: endedAtTime, end_weather: endWx };

      // â˜…è¿½åŠ ï¼šæ½®æ±ãƒãƒ£ãƒ¼ãƒˆç”»åƒã‚’å–å¾—ãƒ»ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰
      console.log('[openTripReview] Fetching tide images');
      try {
        const tideResult = await fetchAndUploadTideImages(draft.startedAt, pendingEnd.endedAt);
        console.log('[openTripReview] Tide image fetch completed:', tideResult);
        if (tideResult.ok && tideResult.images.length > 0) {
          draft.tide_chart_images = tideResult.images;
          console.log('[openTripReview] Stored', tideResult.images.length, 'tide chart images');
        }
      } catch (err) {
        console.warn('[openTripReview] Tide image fetch error:', err);
      }

      // å¾“æ¥ã©ãŠã‚Šã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ç¢ºèªãƒ¢ãƒ¼ãƒ€ãƒ«ã¸
      openUploadReview();
      
      // â˜…ä¿®æ­£ï¼šå…±é€šé–¢æ•°ã§ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’æ¶ˆã™
      hideUploadingOverlay();
    }

    // â˜…è¿½åŠ : EXIFæ—¥æ™‚â†’JSTå›ºå®šISOï¼ˆ+09:00ï¼‰ã¸æ­£è¦åŒ–ï¼ˆEXIFãƒ­ã‚¸ãƒƒã‚¯å´ã‹ã‚‰å‘¼ã³å‡ºã—æƒ³å®šï¼‰
    function exifDateToJstIso(exifLocal) {
      // exifLocal: "YYYY:MM:DD HH:mm:ss" ãªã©ï¼ˆä¸€èˆ¬çš„ãªEXIFè¡¨è¨˜ï¼‰
      if (!exifLocal || typeof exifLocal !== 'string') return null;
      const m = exifLocal.match(/^(\d{4}):?(\d{2}):?(\d{2})[ T](\d{2}):(\d{2}):(\d{2})$/);
      if (!m) return null;
      const [_, y, mo, d, hh, mi, ss] = m;
      // JSTå›ºå®šã®ISOæ‹¡å¼µ
      return `${y}-${mo}-${d}T${hh}:${mi}:${ss}+09:00`;
    }

    // â˜…è¿½åŠ : ä»£è¡¨ä½ç½®ã‚’ã€Œé‡£æœã®æœ€åˆã®å†™çœŸEXIFï¼ˆlat/lngï¼‰ã€å„ªå…ˆã§æ±ºã‚ã‚‹
    function pickRepresentativePositionFromCatches(catches) {
      if (!Array.isArray(catches) || !catches.length) return null;

      // ã€Œæœ€åˆã«ç™»éŒ²ã•ã‚ŒãŸé‡£æœã€ã‚’å„ªå…ˆã—ã€å†™çœŸEXIFãŒãªã„å ´åˆã¯æ¬¡ã®é‡£æœã¸â€¦
      for (let i = 0; i < catches.length; i++) {
        const c = catches[i];
        // EXIFãƒ­ã‚¸ãƒƒã‚¯ã§ c.exif_lat / c.exif_lng ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å‰æï¼ˆã€Œç¢ºç«‹æ¸ˆã€ã¨ã®ã“ã¨ï¼‰
        const lat = (typeof c.exif_lat === 'number') ? c.exif_lat : null;
        const lng = (typeof c.exif_lng === 'number') ? c.exif_lng : null;
        if (lat != null && lng != null && isFinite(lat) && isFinite(lng)) {
          return { lat, lng, from: 'catch_exif', index: i };
        }
      }
      return null;
    }

    // â˜…è¿½åŠ : çµ‚äº†ãƒœã‚¿ãƒ³æŠ¼ä¸‹æ™‚ã«ã€ä¸è¶³é …ç›®ï¼ˆé–‹å§‹/çµ‚äº†æ™‚åˆ»ãƒ»ä»£è¡¨ä½ç½®ãƒ»é–‹å§‹æ™‚æ½®æ±ï¼‰ã‚’è£œå®Œ
    async function complementTripFromCatches(force = false) {
      if (!draft) return;
      const cts = Array.isArray(draft.catches) ? draft.catches.slice() : [];
      
      // â˜…è¿½åŠ ï¼šé–‹å§‹æ—¥æ™‚ã®å‰ã®å€¤ã‚’è¨˜éŒ²ï¼ˆå¤‰æ›´æ¤œå‡ºç”¨ï¼‰
      const previousStartedAt = draft.startedAt;

      // â˜…ãƒ­ã‚°è¿½åŠ ï¼šé–¢æ•°ã®ç™ºç«ã‚’è¨˜éŒ²
      LOG.app("[Complement] start", {
        force,
        catches: cts.length,
        hasStartedAt: !!draft.startedAt,
        hasEndedAt: !!draft.endedAt,
        hasPos: (typeof draft.lat === 'number' && typeof draft.lng === 'number'),
        hasStartTide: !!draft.start_tide
      });

      // startedAt å†è©•ä¾¡
      // â˜…ä¿®æ­£ï¼šæ‰‹å‹•é‡£è¡Œã¨è‡ªå‹•é‡£è¡Œã®ä¸¡æ–¹ã§ã€æœ€åˆã«è¨­å®šã•ã‚ŒãŸé–‹å§‹æ—¥æ™‚ã‚’ä¿æŒã™ã‚‹
      if (cts.length) {
        // é€šå¸¸é‡£è¡ŒãŒé‡£è¡Œå®Œäº†æ™‚ï¼šæœ€åˆã®é‡£æœã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã§ startedAt ã‚’å†è¨ˆç®—
        // æ‰‹å‹•é‡£è¡Œï¼šstartedAt ã‚’ä¿è­·ï¼ˆå¤‰æ›´ã—ãªã„ï¼‰
        const shouldComplementStartedAt = !draft.startedAt || 
          (!draft.manualStarted && draft.status === 'ended');
        
        if (shouldComplementStartedAt) {
          const xs = cts
            .filter(c => c.timestamp != null)
            .map(c => ({ t: new Date(c.timestamp).getTime(), raw: c.timestamp }))
            .filter(x => isFinite(x.t));
          if (xs.length) {
            const min = xs.reduce((a,b)=> a.t<b.t ? a : b);
            draft.startedAt = toOffsetIsoLocal(new Date(min.t));
            LOG.app("[Complement] decided startedAt", { startedAt: draft.startedAt, sample: xs[0]?.raw || null, manualStarted: draft.manualStarted });
          } else {
            LOG.app("[Complement] startedAt not decided (no valid timestamps)");
          }
        } else {
          LOG.app("[Complement] skipped startedAt (startedAt already set)", { manualStarted: draft.manualStarted, startedAt: draft.startedAt });
        }
      }
      
      // â˜…è¿½åŠ ï¼šé–‹å§‹æ—¥æ™‚ãŒå¤‰æ›´ã•ã‚ŒãŸã‹åˆ¤å®š
      const startedAtChanged = previousStartedAt !== draft.startedAt;
      LOG.app("[Complement] startedAtChanged check", { previous: previousStartedAt, current: draft.startedAt, changed: startedAtChanged });

      // endedAt å†è©•ä¾¡ï¼ˆæ‰‹å‹•é–‹å§‹ã§ã‚‚â€œæœªè¨­å®šãªã‚‰â€è£œå®ŒOKï¼‰
      if ( ( (!draft.endedAt && cts.length) || (force && !draft.manualStarted) ) ) {
        const xs = cts
          .filter(c => c.timestamp != null)
          .map(c => ({ t: new Date(c.timestamp).getTime(), raw: c.timestamp }))
          .filter(x => isFinite(x.t));
        if (xs.length) {
          const max = xs.reduce((a,b)=> a.t>b.t ? a : b);
          draft.endedAt = toOffsetIsoLocal(new Date(max.t));
          LOG.app("[Complement] decided endedAt", { endedAt: draft.endedAt, sample: xs[0]?.raw || null });
        } else {
          LOG.app("[Complement] endedAt not decided (no valid timestamps)");
        }
      }

      // ä»£è¡¨ä½ç½®ï¼ˆEXIFï¼‰å†è©•ä¾¡ï¼ˆæ‰‹å‹•é–‹å§‹ã‚’å°Šé‡ã—ã¦ä¸Šæ›¸ãã—ãªã„ï¼‰
      if (!draft.manualStarted && ( force || !(typeof draft.lat === 'number' && typeof draft.lng === 'number') )) {
        const pick = pickRepresentativePositionFromCatches(cts);
        if (pick && pick.lat != null && pick.lng != null) {
          draft.lat = pick.lat;
          draft.lng = pick.lng;
          LOG.app("[Complement] decided position from EXIF", { lat: draft.lat, lng: draft.lng, index: pick.index });
        } else {
          LOG.app("[Complement] position not decided (no EXIF lat/lng in catches)");
        }
      }

      if ((force || !draft.start_tide) &&
          typeof draft.lat === 'number' && typeof draft.lng === 'number' && draft.startedAt) {
        try {
          LOG.app("[Complement] fetching start_tide...", { lat: draft.lat, lng: draft.lng, startedAt: draft.startedAt });
          const tide = await fetchTideForStart(draft.lat, draft.lng, draft.startedAt);
          draft.start_tide = tide || null;
          if (tide?.chart && tide?.chartDateKey) {
            draft.tide_daily_cache = draft.tide_daily_cache || {};
            draft.tide_daily_cache[tide.chartDateKey] = {
              harbor: tide.harbor || null,
              chart: tide.chart
            };
          }
          // â˜…ãƒ­ã‚°è¿½åŠ ï¼šæ½®æ±æ±ºå®š
          LOG.app("[Complement] decided start_tide", {
            hasTide: !!draft.start_tide,
            harbor: draft.start_tide?.harbor?.hn || null,
            dateKey: draft.start_tide?.chartDateKey || null
          });
        } catch (e) {
          console.warn("[complementTripFromCatches] tide fetch failed:", e?.message || e);
          LOG.app("[Complement] start_tide fetch failed", { error: e?.message || String(e) });
        }
      } else {
        LOG.app("[Complement] skip tide (insufficient lat/lng or startedAt)", {
          hasPos: (typeof draft.lat === 'number' && typeof draft.lng === 'number'),
          hasStartedAt: !!draft.startedAt
        });
      }

      // â˜…è¿½è¨˜ï¼ˆç§»å‹•å…ˆï¼‰: é–‹å§‹å¤©æ°—ã®è£œå®Œã‚’æ½®æ±ã®ç›´å¾Œã«å®Ÿè¡Œã—ã€æœ€åˆã® save å‰ã«ç¢ºå®šã•ã›ã‚‹
      // â˜…ä¿®æ­£ï¼šé–‹å§‹æ—¥æ™‚ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆã‚‚å†å–å¾—
      if ((force || !draft.start_weather || startedAtChanged) &&
          typeof draft.lat === 'number' && typeof draft.lng === 'number' &&
          draft.startedAt) {
        try {
          LOG.app("[Complement] fetching start_weather...", { lat: draft.lat, lng: draft.lng, startedAt: draft.startedAt });
          draft.start_weather = await fetchWeather(draft.lat, draft.lng, draft.startedAt);
          LOG.app("[Complement] decided start_weather", { ok: !!draft.start_weather });
        } catch (e) {
          console.warn("[Complement] start_weather fetch failed:", e?.message || e);
          LOG.app("[Complement] start_weather fetch failed", { error: e?.message || String(e) });
        }
      }

      // â˜…è¿½åŠ ï¼šæ‰‹å‹•è¿½åŠ æ™‚ã®æ°´æ¸©è£œå®Œï¼ˆé–‹å§‹æ—¥ãŒä»Šæ—¥ä»¥å¤–ãªã‚‰éå»ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å–å¾—ï¼‰
      // â˜…ä¿®æ­£ï¼šé–‹å§‹æ—¥æ™‚ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆã‚‚å†å–å¾—
      if ((force || !draft.start_water_temp || (startedAtChanged && draft.manualStarted)) &&
          typeof draft.lat === 'number' && typeof draft.lng === 'number' &&
          draft.startedAt && draft.manualStarted) {
        try {
          LOG.app("[Complement] fetching water temp for manual entry", { 
            lat: draft.lat, lng: draft.lng, startedAt: draft.startedAt 
          });
          
          // é–‹å§‹æ—¥ãŒä»Šæ—¥ä»¥å¤–ãªã‚‰éå»ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å–å¾—
          let waterTemp = await getWaterTempForManualEntry(draft.lat, draft.lng, draft.startedAt, true);
          
          // éå»ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ç¾åœ¨ã®æ°´æ¸©ã‚’å–å¾—
          if (!waterTemp) {
            waterTemp = await fetchTodayWaterTempByNearest(draft.lat, draft.lng);
          }
          
          draft.start_water_temp = waterTemp;
          LOG.app("[Complement] decided start_water_temp", { 
            hasData: !!draft.start_water_temp,
            temperature_c: draft.start_water_temp?.temperature_c || null
          });
        } catch (e) {
          console.warn("[Complement] start_water_temp fetch failed:", e?.message || e);
          LOG.app("[Complement] start_water_temp fetch failed", { error: e?.message || String(e) });
        }
      }

      // ã“ã“ã¾ã§ã§ startedAt / endedAt / ä»£è¡¨ä½ç½® / start_tide / start_weather / start_water_temp ã‚’ç¢ºå®šæ¸ˆã¿
      saveDraft(draft);
      LOG.app("[Complement] saved", {
        startedAt: draft.startedAt || null,
        endedAt: draft.endedAt || null,
        lat: draft.lat, lng: draft.lng,
        hasStartTide: !!draft.start_tide,
        hasStartWeather: !!draft.start_weather
      });
    }
    
    // ===== Catches ã‚­ãƒ£ãƒƒã‚·ãƒ¥ =====
    async function ensureCatchesCache(){
      if (catchesCache) return catchesCache;
      catchesCache = await loadSheetViaGAS(SHEET_NAME, SHEET_ID);
      return catchesCache;
    }

    // â˜…è¿½è¨˜: ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å†é€ï¼ˆã‚ªãƒ³ãƒ©ã‚¤ãƒ³/èµ·å‹•æ™‚ï¼‰
    async function retryUploadQueue(){
      let q = [];
      let idbItems = [];
      let idbIds = [];
      
      // ã€1ã€‘IndexedDB ã‹ã‚‰ã‚­ãƒ¥ãƒ¼ã‚’å–å¾—
      if (db) {
        try {
          const tx = db.transaction(UPLOAD_QUEUE_STORE, 'readonly');
          const store = tx.objectStore(UPLOAD_QUEUE_STORE);
          idbItems = await new Promise((resolve) => {
            const req = store.getAll();
            req.onsuccess = () => resolve(req.result || []);
            req.onerror = () => resolve([]);
          });
          idbIds = idbItems.map(item => item.id);
          console.log('[UploadQueue] Loaded from IndexedDB:', idbItems.length, 'items');
          q = [...idbItems];
        } catch (e) {
          console.warn('[UploadQueue] IndexedDB load failed:', e.message);
          // IndexedDB å¤±æ•—æ™‚ã¯ localStorage ã‹ã‚‰å–å¾—
          try {
            const key = 'fishlog_upload_queue_v1';
            q = JSON.parse(localStorage.getItem(key) || '[]');
          } catch {
            q = [];
          }
        }
      } else {
        // db ãŒãªã„å ´åˆã¯ localStorage ã‹ã‚‰å–å¾—
        try {
          const key = 'fishlog_upload_queue_v1';
          q = JSON.parse(localStorage.getItem(key) || '[]');
        } catch {
          q = [];
        }
      }
      
      if (!Array.isArray(q) || !q.length) {
        console.log('[UploadQueue] No pending items');
        return;
      }

      // â˜…è¿½åŠ ï¼šå¤šé‡å®Ÿè¡Œé˜²æ­¢
      if (isUploading) return;
      
      // â˜…ä¿®æ­£ï¼šå…±é€šé–¢æ•°ã§ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’è¡¨ç¤ºï¼ˆã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸­ãƒ†ã‚­ã‚¹ãƒˆï¼‰
      showUploadingOverlay('ä¿ç•™ä¸­ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚’å†é€ä¸­...');

      const remain = [];
      const successIds = [];
      
      for (const item of q) {
        try {
          const payload = item.payload || item; // å¤ã„å½¢å¼ã¨æ–°å½¢å¼ã®ä¸¡æ–¹ã«å¯¾å¿œ
          const res = await fetch(CONFIG.API.FISHING_TRIP_API_WORKER + '/api/upload', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'X-Auth-Token': CONFIG.API.WORKERS_AUTH_TOKEN },
            body: JSON.stringify(payload)
          });
          if (!res.ok) {
            remain.push(item);
            continue;
          }
          await res.text(); // æ¶ˆè²»
          
          // IndexedDB ã‚¢ã‚¤ãƒ†ãƒ ã®å ´åˆã¯ ID ã‚’è¨˜éŒ²
          if (item.id) {
            successIds.push(item.id);
          }
        } catch (e) {
          console.warn('[UploadQueue] Send failed:', e.message);
          remain.push(item);
        }
      }
      
      // ã€2ã€‘æˆåŠŸã—ãŸã‚¢ã‚¤ãƒ†ãƒ ã‚’ IndexedDB ã‹ã‚‰å‰Šé™¤
      if (successIds.length > 0 && db) {
        try {
          const tx = db.transaction(UPLOAD_QUEUE_STORE, 'readwrite');
          const store = tx.objectStore(UPLOAD_QUEUE_STORE);
          for (const id of successIds) {
            store.delete(id);
          }
          console.log('[UploadQueue] Deleted from IndexedDB:', successIds.length, 'items');
        } catch (e) {
          console.warn('[UploadQueue] IndexedDB delete failed:', e.message);
        }
      }
      
      // ã€3ã€‘æ®‹ã‚Šã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ›´æ–°
      // æ®‹ã‚Šã®ã‚¢ã‚¤ãƒ†ãƒ ãŒ IndexedDB ã‹ã‚‰æ¥ãŸã‚‚ã®ã®å ´åˆã€IndexedDB ã«æ®‹ã™
      if (idbIds.length > 0 && db && remain.length > 0) {
        // IndexedDB ã‚¢ã‚¤ãƒ†ãƒ ã®æ®‹ã‚Šã¯æ—¢ã« DB ã«æ®‹ã£ã¦ã„ã‚‹ã®ã§ OK
        console.log('[UploadQueue] Remaining items stay in IndexedDB:', remain.length);
      } else if (remain.length > 0) {
        // localStorage ã«æ®‹ã‚Šã‚’ä¿å­˜
        try {
          const key = 'fishlog_upload_queue_v1';
          localStorage.setItem(key, JSON.stringify(remain));
          console.log('[UploadQueue] Updated localStorage with remaining:', remain.length, 'items');
        } catch (e) {
          console.warn('[UploadQueue] Failed to update localStorage:', e.message);
        }
      } else {
        // æ®‹ã‚ŠãŒãªã„å ´åˆã¯ localStorage ã‚’ã‚¯ãƒªã‚¢
        try {
          const key = 'fishlog_upload_queue_v1';
          localStorage.removeItem(key);
          console.log('[UploadQueue] Cleared localStorage (all sent)');
        } catch (e) {
          // ç„¡è¦–
        }
      }
      
      // â˜…ä¿®æ­£ï¼šå®Œäº†æ™‚ã«å…±é€šé–¢æ•°ã§ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’æ¶ˆã™
      hideUploadingOverlay();
      if (q.length && !remain.length) {
        try {
          alert('ä¿ç•™ä¸­ã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚’å†é€ã—ã€ã™ã¹ã¦å®Œäº†ã—ã¾ã—ãŸã€‚');
        } catch {}
      }
    }
    window.addEventListener('online', () => retryUploadQueue());
    // åˆæœŸè¡¨ç¤ºå¾Œã«ä¸€åº¦ã ã‘è©¦è¡Œ
    setTimeout(() => retryUploadQueue(), 1000);

    function openManualTripForm(){
      // â˜…è¿½åŠ : ãƒ¢ãƒ¼ãƒ€ãƒ«è¦ªã® recordView ã‚’è¡¨ç¤ºã•ã›ã‚‹ï¼ˆè¦ªã® hidden ã‚’å¤–ã™ï¼‰
      showView('record');

      // å…¥åŠ›åˆæœŸåŒ–
      try {
        inpTripStart.value = '';
        inpTripLat.value   = (typeof draft.lat==='number') ? String(draft.lat) : '';
        inpTripLng.value   = (typeof draft.lng==='number') ? String(draft.lng) : '';
      } catch(_) {}

      // å…¥åŠ›åˆæœŸåŒ–
      try {
        inpTripStart.value = '';
        inpTripLat.value   = (typeof draft.lat==='number') ? String(draft.lat) : '';
        inpTripLng.value   = (typeof draft.lng==='number') ? String(draft.lng) : '';
      } catch(_) {}

      // â˜…ä¿®æ­£ï¼šå¹´ã¯4æ¡ã«å³å¯†ã«åˆ¶é™ï¼ˆkeydown + input ã§ç¢ºå®Ÿã«åˆ¶å¾¡ï¼‰
      if (inpTripStart) {
        // å¤ã„ãƒãƒ³ãƒ‰ãƒ©ã‚’ã‚¯ãƒªã‚¢
        if (inpTripStart._inputHandler) {
          inpTripStart.removeEventListener('input', inpTripStart._inputHandler);
        }
        if (inpTripStart._keydownHandler) {
          inpTripStart.removeEventListener('keydown', inpTripStart._keydownHandler);
        }
        
        // keydownï¼š5æ–‡å­—ç›®å…¥åŠ›ã‚’æ¤œçŸ¥ã—ã¦ã€å¹´ã‚’åˆ‡ã‚Šè©°ã‚ã‚‹
        inpTripStart._keydownHandler = (evt) => {
          if (evt.key.match(/[0-9]/)) {
            const digits = inpTripStart.value.replace(/\D/g, '');
            // å¹´ãŒæ—¢ã«4æ¡ã‚ã‚Šã€5æ–‡å­—ç›®ä»¥é™ã‚’å…¥åŠ›ã—ã‚ˆã†ã¨ã—ã¦ã„ã‚‹ãªã‚‰è¨±å¯ã—ãªã„
            if (digits.length >= 4) {
              // 5æ–‡å­—ç›®ã‚’å…¥åŠ›ã™ã‚‹éš›ã¯ã€ã‚¤ãƒ™ãƒ³ãƒˆç›´å¾Œã«å€¤ã‚’æ›¸ãç›´ã™
              setTimeout(() => {
                const newDigits = inpTripStart.value.replace(/\D/g, '');
                if (newDigits.length > 4) {
                  // å¹´ã‚’4æ¡ã«åˆ¶é™ã—ã€5æ–‡å­—ç›®ä»¥é™ã‚’æœˆãƒ»æ—¥ãƒ»æ™‚ãƒ»åˆ†ã«æŒ¯ã‚Šåˆ†ã‘ã‚‹
                  const y  = newDigits.slice(0, 4);
                  const mo = newDigits.slice(4, 6);
                  const d  = newDigits.slice(6, 8);
                  const hh = newDigits.slice(8, 10);
                  const mm = newDigits.slice(10, 12);

                  let formatted = y;
                  if (mo) formatted += '-' + mo;
                  if (d)  formatted += '-' + d;
                  if (hh) formatted += 'T' + hh;
                  if (mm) formatted += ':' + mm;

                  inpTripStart.value = formatted;
                }
              }, 0);
            }
          }
        };

        inpTripStart._inputHandler = () => {
          const digits = inpTripStart.value.replace(/\D/g, '');
          
          if (!digits) {
            inpTripStart.value = '';
            return;
          }

          const y  = digits.slice(0, 4);
          const mo = digits.slice(4, 6);
          const d  = digits.slice(6, 8);
          const hh = digits.slice(8, 10);
          const mm = digits.slice(10, 12);

          let formatted = y;
          if (mo) formatted += '-' + mo;
          if (d)  formatted += '-' + d;
          if (hh) formatted += 'T' + hh;
          if (mm) formatted += ':' + mm;

          if (formatted !== inpTripStart.value) {
            inpTripStart.value = formatted;
          }
        };

        inpTripStart.addEventListener('keydown', inpTripStart._keydownHandler);
        inpTripStart.addEventListener('input', inpTripStart._inputHandler);
      }

      // â˜…è¿½åŠ : è¦ç´ æœªæŒ¿å…¥æ™‚ã®å®‰å…¨å¯¾ç­–
      if (!tripModal) { alert('é‡£è¡Œå…¥åŠ›ãƒ¢ãƒ¼ãƒ€ãƒ«ã®HTMLï¼ˆid="tripModal"ï¼‰ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚HTMLã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚'); return; }

      tripModal.classList.remove('hidden');
    }

    // â˜…è¿½è¨˜: æ‰‹å‹•é‡£æœãƒ•ã‚©ãƒ¼ãƒ ï¼ˆæœ€å°é …ç›®ï¼‰
    function openManualCatchForm(){
      // é‡£è¡Œã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã«é–¢ä¿‚ãªãã€æ—¢å­˜ã®é‡£æœè¿½åŠ ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’ãã®ã¾ã¾ä½¿ã†
      showView('record');                       // è¨˜éŒ²ãƒ“ãƒ¥ãƒ¼ã¸
      editMode = false; 
      editingId = null; 
      modalTitle.textContent = 'æ‰‹å‹•ã§é‡£æœã‚’è¿½åŠ ';
      manualCatchMode = true;

      // â˜…è¿½åŠ ï¼šæ‰‹å‹•ãƒ¢ãƒ¼ãƒ‰ãƒ•ãƒ©ã‚°ã‚’æ˜ç¤ºçš„ã«ã‚ªãƒ³
      manualCatchMode = true;

      // æ—¢å­˜ openAddCatch ã¨åŒç­‰ã®åˆæœŸåŒ–ï¼ˆstatus ãƒã‚§ãƒƒã‚¯ã¯ã—ãªã„ï¼‰
      catchForm = { 
        id: uuid(),
        timestamp: null,                        // â† æ™‚åˆ»ã¯å…¥ã‚Œãªã„ï¼ˆnullï¼‰
        species:'', 
        size_cm:null, 
        weight_g:null, 
        method:'', 
        photoPreviewUrl: undefined 
      };

      // â† å…¥åŠ›æ¬„ã¯ç©ºã®ã¾ã¾
      inpCatchTime.value = '';
      inpSpecies.value   = '';
      inpSize.value      = '';
      inpWeight.value    = '';
      inpMethod.value    = '';
      inpPhoto.value     = '';
      imgPreview.src     = '';
      imgPreview.classList.add('hidden');

      // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
      catchModal.classList.remove('hidden');
    }

    // â˜…å¤‰æ›´: æ‰‹å‹•é‡£è¡Œã®ç™»éŒ²ï¼ˆå†™çœŸãƒ»ç¾åœ¨åœ°ã®å–å¾—ã¯è¡Œã‚ãšã€ãƒ¢ãƒ¼ãƒ€ãƒ«å…¥åŠ›ã ã‘ã§ç¢ºå®šã€‚ç™»éŒ²æ™‚ã«ä¸è¶³è£œå®Œã‚’å®Ÿè¡Œï¼‰
    async function submitManualTrip(){
      // â˜…ä¿®æ­£ï¼šCONFIGåˆæœŸåŒ–å®Œäº†ã‚’å¾…æ©Ÿï¼ˆAPIå‘¼ã³å‡ºã—å‰ã®å¿…é ˆå‡¦ç†ï¼‰
      await configInitPromise;
      
      let startedIso = null;
      let lat = null, lng = null;

      // 1) ãƒ¢ãƒ¼ãƒ€ãƒ«å…¥åŠ›ã®ã¿æ¡ç”¨ï¼ˆæœªå…¥åŠ›ã¯æœªè¨­å®šã®ã¾ã¾ï¼‰
      if (inpTripStart && inpTripStart.value) {
        try {
          startedIso = toOffsetIsoLocal(new Date(inpTripStart.value));
        } catch(e) {
          console.warn("[TripManual] Failed to parse start time:", e);
          startedIso = null;
        }
      }
      if (inpTripLat && inpTripLat.value)     lat = Number(inpTripLat.value);
      if (inpTripLng && inpTripLng.value)     lng = Number(inpTripLng.value);

      // 2) â˜…ä¿®æ­£: å…¥åŠ›ãŒãªã„ãªã‚‰ startedIso ã¯ null ã®ã¾ã¾ï¼ˆè‡ªå‹•è£œå®Œãªã—ï¼‰

      // 3) draft ã«åæ˜ ï¼ˆä½ç½®ã¯å…¥åŠ›ãŒä¸¡æ–¹ã‚ã‚‹ã¨ãã®ã¿æ¡ç”¨ï¼‰
      draft.status        = 'active';
      draft.startedAt     = startedIso;  // â˜…ä¿®æ­£: null ã®å ´åˆã¯ null ã®ã¾ã¾
      draft.manualStarted = true; // â˜…è¿½åŠ ï¼šæ‰‹å‹•é–‹å§‹ãƒ•ãƒ©ã‚°ã‚’æ˜ç¤ºçš„ã«ON
      
      // â˜…ä¿®æ­£â‘ : é‡£æœãŒãªã„å ´åˆã«å‚™ãˆã¦ã€endedAt ã‚’ç¾åœ¨æ™‚åˆ»ã§åˆæœŸåŒ–
      if (!draft.endedAt) {
        draft.endedAt = nowIsoLocal();  // é‡£è¡Œçµ‚äº†æ™‚åˆ»ã®åˆæœŸå€¤
      }
      
      if (typeof lat === 'number' && typeof lng === 'number' && isFinite(lat) && isFinite(lng)) {
        draft.lat = lat;
        draft.lng = lng;
      } else {
        LOG.app("[TripManual] position not provided; skip weather/tide/water completion at this time");
      }

      // 4) æœªå…¥åŠ›æƒ…å ±ã®è£œå®Œï¼ˆã“ã®ç™»éŒ²ãƒœã‚¿ãƒ³æŠ¼ä¸‹æ™‚ã«å®Ÿè¡Œï¼‰
      try{
        if (typeof draft.lat === 'number' && typeof draft.lng === 'number'){
          // å¤©æ°—
          try { draft.start_weather = await fetchWeather(draft.lat, draft.lng); }
          catch(e){ console.warn("[Weather] manualTrip fetch failed:", e?.message||e); }

          // æ½®ï¼ˆé–‹å§‹æ™‚ï¼‰
          try{
            const tide = await fetchTideForStart(draft.lat, draft.lng, draft.startedAt);
            draft.start_tide = tide || null;
            if (tide?.chart && tide?.chartDateKey){
              draft.tide_daily_cache = draft.tide_daily_cache || {};
              draft.tide_daily_cache[tide.chartDateKey] = {
                harbor: tide.harbor || null, chart: tide.chart
              };
            }
          }catch(e){ console.warn("[Tide] manualTrip fetch failed:", e?.message||e); }

          // æ°´æ¸©ï¼ˆå½“æ—¥ãƒ»æœ€å¯„ã‚Šã€ã¾ãŸã¯é–‹å§‹æ—¥ã®éå»ãƒ‡ãƒ¼ã‚¿ï¼‰
          try{
            if (DEBUG_WATER) LOG.wt("manualTrip: fetch water temp", { lat: draft.lat, lng: draft.lng, startedAt: draft.startedAt });
            
            let waterTemp = null;
            
            // â˜…ä¿®æ­£ï¼šæ‰‹å‹•è¿½åŠ ã‹ã¤é–‹å§‹æ—¥ãŒä»Šæ—¥ä»¥å¤–ãªã‚‰éå»ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å–å¾—ã‚’è©¦ã¿ã‚‹
            if (draft.manualStarted && draft.startedAt) {
              waterTemp = await getWaterTempForManualEntry(draft.lat, draft.lng, draft.startedAt, true);
            }
            
            // éå»ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚‰ãªã„ã€ã¾ãŸã¯é–‹å§‹æ—¥ãŒä»Šæ—¥ã®å ´åˆã¯ç¾åœ¨ã®æ°´æ¸©ã‚’å–å¾—
            if (!waterTemp) {
              waterTemp = await fetchTodayWaterTempByNearest(draft.lat, draft.lng);
            }
            
            draft.start_water_temp = waterTemp;
            if (DEBUG_WATER) LOG.wt("manualTrip: water temp result", draft.start_water_temp);
          }catch(e){ console.warn("[WaterTemp] manualTrip failed:", e?.message||e); }
        }
      }catch(e){
        console.warn("[TripManual] unexpected:", e?.message||e);
      }

      // 5) ä¿å­˜ã¨UI
      saveDraft(draft);
      LOG.app("[TripManual] saved (no photo, no geolocation)", {
        startedAt: draft.startedAt,
        lat: draft.lat, lng: draft.lng,
        hasStartWeather: !!draft.start_weather,
        hasStartTide: !!draft.start_tide,
        hasWater: !!(draft.start_water_temp && draft.start_water_temp.temperature_c!=null)
      });

      tripModal && tripModal.classList.add('hidden');
      
      // â˜…ä¿®æ­£â‘ : openTripReview() â†’ _complementTripDataOnly() ã«å¤‰æ›´ï¼ˆãƒ¢ãƒ¼ãƒ€ãƒ«è¡¨ç¤ºãªã—ï¼‰
      await _complementTripDataOnly();
    }

    // â˜…è¿½åŠ ï¼šã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¨­å®šã—ã¦è¡¨ç¤ºã™ã‚‹å…±é€šé–¢æ•°
    function showUploadingOverlay(message = 'ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸­...') {
      console.log('[showUploadingOverlay] START', { message, isUploading });
      uploadingMessage = message;
      const messageEl = document.getElementById('uploadingMessage');
      if (messageEl) messageEl.textContent = message;
      
      isUploading = true;
      const uploadingOverlay = document.getElementById('uploadingOverlay');
      console.log('[showUploadingOverlay] element found:', !!uploadingOverlay);
      
      if (!uploadingOverlay) {
        console.error('[showUploadingOverlay] uploadingOverlay NOT FOUND!');
        return;
      }
      
      // â˜…é¢…æ–¼ï¼šhiddenã‚¯ãƒ©ã‚¹ã‚’æ˜ç¤ºçš„ã«å‰Šé™¤
      if (uploadingOverlay.classList.contains('hidden')) {
        console.log('[showUploadingOverlay] removing hidden class');
        uploadingOverlay.classList.remove('hidden');
      }
      uploadingOverlay.style.display = 'flex';
      uploadingOverlay.style.visibility = 'visible';
      uploadingOverlay.style.opacity = '1';
      uploadingOverlay.style.pointerEvents = 'auto';
      
      console.log('[showUploadingOverlay] styles applied:', {
        display: uploadingOverlay.style.display,
        computed: window.getComputedStyle(uploadingOverlay).display
      });
      console.log('[showUploadingOverlay] END');
    }

    function hideUploadingOverlay() {
      console.log('[hideUploadingOverlay] START');
      isUploading = false;
      const uploadingOverlay = document.getElementById('uploadingOverlay');
      if (!uploadingOverlay) {
        console.error('[hideUploadingOverlay] uploadingOverlay NOT FOUND!');
        return;
      }
      uploadingOverlay.classList.add('hidden');
      uploadingOverlay.style.display = 'none';
      uploadingOverlay.style.visibility = 'hidden';
      uploadingOverlay.style.opacity = '0';
      uploadingOverlay.style.pointerEvents = 'none';
      console.log('[hideUploadingOverlay] END');
    }

    // ===== ãƒ¢ãƒ¼ãƒ€ãƒ«æ“ä½œ =====
    const uploadReviewModalEl = document.getElementById('uploadReviewModal');
    document.getElementById('btnCloseModal').onclick  = ()=> cancelAndReturnHome();
    document.getElementById('btnCancelCatch').onclick = ()=> cancelAndReturnHome();
    document.getElementById('btnSaveCatch').onclick   = async (e) => {
      // â˜…è¿½åŠ ï¼šãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æ™‚ã«æœ€åˆã«æ“ä½œãƒ–ãƒ­ãƒƒã‚¯ï¼†ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤è¡¨ç¤º
      if (isUploading) return;
      isUploading = true;
      showUploadingOverlay('é‡£æœã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸­...');
      await new Promise(resolve => requestAnimationFrame(resolve));
      
      // ãã®å¾Œã§å®Ÿéš›ã®å‡¦ç†ã‚’å®Ÿè¡Œ
      try {
        await submitCatch();
      } catch (e) {
        console.error('[btnSaveCatch] error:', e);
      }
    };
    catchModal.addEventListener('click', (e)=>{ if (e.target === catchModal) cancelAndReturnHome(); });

    // ä¸‹éƒ¨ãƒãƒ¼
    btnAddCatchBottom.onclick=openAddCatch;
    btnEndBottom.onclick = openTripReview;

    // åˆæœŸè¡¨ç¤º
    render();
    // â˜…è¿½åŠ ï¼šé‡£è¡Œç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
    // â˜…è¿½åŠ ï¼šè£œå®Œãƒ‡ãƒ¼ã‚¿ã‚’ UI ã«åæ˜ ã™ã‚‹é–¢æ•°
    function updateEditModalCompData() {
      editTripWeather.textContent = draft.start_weather ? formatWeatherBrief(draft.start_weather) : 'æœªè¨­å®š';
      editTripTide.textContent = draft.start_tide 
        ? `${draft.start_tide.tideName || ''} / ${draft.start_tide.trendText || ''}`
        : 'æœªè¨­å®š';
      editTripWaterTemp.textContent = draft.start_water_temp && draft.start_water_temp.temperature_c != null
        ? `${draft.start_water_temp.temperature_c}â„ƒ${draft.start_water_temp.point_name ? `ï¼ˆ${draft.start_water_temp.point_name}ï¼‰` : ''}`
        : 'æœªè¨­å®š';
    }

    function openTripEditModal(catchIndexToSelect = -1) {
      if (!draft) {
        alert('ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
        return;
      }

      // é‡£è¡ŒåŸºæœ¬æƒ…å ±ã‚’å…¥åŠ›æ¬„ã«åæ˜ 
      if (draft.startedAt) {
        const d = new Date(draft.startedAt);
        editTripStarted.value = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
      } else {
        editTripStarted.value = '';
      }

      if (draft.endedAt) {
        const d = new Date(draft.endedAt);
        editTripEnded.value = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')} ${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
      } else {
        editTripEnded.value = '';
      }

      editTripLat.value = typeof draft.lat === 'number' ? draft.lat : '';
      editTripLng.value = typeof draft.lng === 'number' ? draft.lng : '';

      // â˜…è¿½åŠ ï¼šãƒ¡ãƒ¢ã‚’åæ˜ 
      const editTripMemo = document.getElementById('editTripMemo');
      if (editTripMemo) {
        editTripMemo.value = draft.memo || '';
      }

      // è£œå®Œãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ç¤º
      updateEditModalCompData();
      
      // é‡£æœãƒªã‚¹ãƒˆã‚’è¡¨ç¤º
      renderEditCatchList();

      // ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¡¨ç¤º
      uploadReviewModal.classList.add('hidden');
      tripEditModal.classList.remove('hidden');

      LOG.app('[TripEdit] opened', { catchCount: draft.catches?.length || 0 });
    }

    // â˜…ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¹ã‚³ãƒ¼ãƒ—ã«ã‚¢ã‚µã‚¤ãƒ³ï¼ˆtrips ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‹ã‚‰å‘¼ã³å‡ºã›ã‚‹ã‚ˆã†ã«ã™ã‚‹ï¼‰
    window._openTripEditModal = openTripEditModal;

    // â˜…è¿½åŠ ï¼šé‡£è¡Œç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã®é‡£æœãƒªã‚¹ãƒˆã‚’æç”»
    function renderEditCatchList() {
      const cts = draft.catches || [];
      editCatchList.innerHTML = '';
      editCatchCount.textContent = cts.length;

      // â˜…ä¿®æ­£ï¼šã‚«ãƒ©ãƒ ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ãƒ«ãƒ¼ãƒ—ã®å¤–ã§ä½œæˆ
      const catchHeaders = (catchesCache || [])[0] || [];
      const colCatch = {};
      for (let i = 0; i < catchHeaders.length; i++) {
        colCatch[String(catchHeaders[i]).trim()] = i;
      }
      console.log('[renderEditCatchList] colCatch mapping:', colCatch);

      cts.forEach((c, idx) => {
        // é…åˆ—è¡Œãƒ‡ãƒ¼ã‚¿ã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›
        const catchObj = {
          species: c[colCatch.species] || '',
          size_cm: parseFloat(c[colCatch.size_cm]) || null,
          weight_g: parseFloat(c[colCatch.weight_g]) || null,
          method: c[colCatch.method] || '',
          timestamp: c[colCatch.timestamp] || ''
        };
        
        console.log(`[renderEditCatchList] catch[${idx}]:`, { raw: c, converted: catchObj });

        const item = document.createElement('div');
        item.className = 'bg-slate-800 rounded-lg p-3 flex items-start justify-between';

        const content = document.createElement('div');
        content.className = 'flex-1 cursor-pointer hover:bg-slate-700/30 rounded p-1 transition';
        content.innerHTML = `
          <div class="font-semibold text-slate-100 text-sm">${catchObj.species || '(é­šç¨®æœªè¨­å®š)'}</div>
          <div class="text-slate-300 text-xs mt-1">${[
            catchObj.size_cm != null ? `ã‚µã‚¤ã‚º: ${catchObj.size_cm}cm` : null,
            catchObj.weight_g != null ? `é‡é‡: ${catchObj.weight_g}g` : null,
            catchObj.method || null
          ].filter(Boolean).join(' / ')}</div>
          <div class="text-slate-400 text-xs mt-1">${catchObj.timestamp ? new Date(catchObj.timestamp).toLocaleString() : ''}</div>
        `;
        content.onclick = () => {
          // é‡£æœç·¨é›†ãƒ•ã‚©ãƒ¼ãƒ ã‚’é–‹ãï¼ˆåŒã˜ãƒ•ã‚©ãƒ¼ãƒ ä½¿ç”¨ï¼‰
          editCatchForm(idx);
        };

        const btnDelete = document.createElement('button');
        btnDelete.className = 'text-xs py-1 px-2 rounded bg-red-900 hover:bg-red-800 text-red-200 ml-2';
        btnDelete.textContent = 'å‰Šé™¤';
        btnDelete.onclick = () => {
          if (confirm('ã“ã®é‡£æœã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
            draft.catches.splice(idx, 1);
            saveDraft(draft);
            renderEditCatchList();
          }
        };

        item.appendChild(content);
        item.appendChild(btnDelete);
        editCatchList.appendChild(item);
      });
    }

    // â˜…è¿½åŠ ï¼šé‡£è¡Œç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«å†…ã§é‡£æœã‚’ç·¨é›†
    function editCatchForm(catchIndex) {
      // æ—¢å­˜ã®é‡£æœãƒ•ã‚©ãƒ¼ãƒ ã‚’ä½¿ç”¨
      if (catchIndex >= 0 && catchIndex < draft.catches.length) {
        catchForm = { ...draft.catches[catchIndex] };
        LOG.app('[EditCatch] editing catch', { index: catchIndex });
      } else {
        catchForm = { timestamp: null, species: '', size_cm: null, weight_g: null, method: '', photoPreviewUrl: undefined };
        LOG.app('[EditCatch] adding new catch');
      }

      // å…¥åŠ›æ¬„ã«åæ˜ 
      if (catchForm.timestamp) {
        const d = new Date(catchForm.timestamp);
        inpCatchTime.value = `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}T${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`;
      } else {
        inpCatchTime.value = '';
      }
      inpSpecies.value = catchForm.species || '';
      inpSize.value = catchForm.size_cm ?? '';
      inpWeight.value = catchForm.weight_g ?? '';
      inpMethod.value = catchForm.method || '';
      
      if (catchForm.photoPreviewUrl) {
        imgPreview.src = catchForm.photoPreviewUrl;
        imgPreview.classList.remove('hidden');
      } else {
        imgPreview.src = '';
        imgPreview.classList.add('hidden');
      }
      inpPhoto.value = '';

      // é‡£è¡Œç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã€é‡£æœãƒ•ã‚©ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‹ã
      tripEditModal.classList.add('hidden');
      catchModal.classList.remove('hidden');

      // submitCatchå¾Œã«é‡£è¡Œç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«ã«æˆ»ã‚‹ãƒ•ãƒ©ã‚°ã‚’è¨­å®š
      window._returnToTripEditAfterCatch = true;
    }

    // é‡£æœä¿å­˜å¾Œã«é‡£è¡Œç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«ã«æˆ»ã‚‹ãŸã‚ã®ä¿®æ­£
    const originalSubmitCatch = submitCatch;
    submitCatch = function() {
      originalSubmitCatch.call(this);
      if (window._returnToTripEditAfterCatch) {
        window._returnToTripEditAfterCatch = false;
        setTimeout(() => {
          catchModal.classList.add('hidden');
          tripEditModal.classList.remove('hidden');
          renderEditCatchList();
        }, 100);
      }
    };

    // â˜…è¿½åŠ ï¼šé‡£è¡Œç·¨é›†ãƒ¢ãƒ¼ãƒ€ãƒ«ã®ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆ
    console.log('[ModalSetup] Setting up trip edit modal buttons', { 
      btnCloseTripEdit: !!btnCloseTripEdit, 
      btnCancelTripEdit: !!btnCancelTripEdit,
      tripEditModal: !!tripEditModal 
    });
    if (btnCloseTripEdit) {
      btnCloseTripEdit.onclick = () => {
        console.log('[ModalButton] Close button clicked');
        tripEditModal.style.display = 'none';
        tripEditModal.classList.add('hidden');
      };
    }
    if (btnCancelTripEdit) {
      btnCancelTripEdit.onclick = () => {
        // â˜…è¿½åŠ ï¼šã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ä¸­ã¯ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã§ããªã„
        if (isUploading) return;
        
        console.log('[ModalButton] Cancel button clicked');
        tripEditModal.style.display = 'none';
        tripEditModal.classList.add('hidden');
      };
    }
    if (btnAddCatchInEdit) {
      btnAddCatchInEdit.onclick = () => {
        console.log('[EditModal] Add catch button clicked');
        // é‡£æœè¿½åŠ ãƒ•ã‚©ãƒ¼ãƒ ã‚’è¡¨ç¤º
        const formSection = document.getElementById('editCatchFormSection');
        if (formSection) {
          formSection.classList.remove('hidden');
          document.getElementById('editFormCatchTime').focus();
        }
      };
    }
    
    // â˜…è¿½åŠ ï¼šãƒ‡ãƒ¼ã‚¿å†å–å¾—ãƒœã‚¿ãƒ³ã®ãƒãƒ³ãƒ‰ãƒ©
    if (btnRefetchCompData) {
      btnRefetchCompData.onclick = async () => {
        // â˜…ä¿®æ­£ï¼šCONFIGåˆæœŸåŒ–å®Œäº†ã‚’å¾…æ©Ÿï¼ˆAPIå‘¼ã³å‡ºã—å‰ã®å¿…é ˆå‡¦ç†ï¼‰
        await configInitPromise;
        
        console.log('[btnRefetchCompData] clicked');
        
        // å…¥åŠ›å€¤ã‹ã‚‰æ—¥æ™‚ã¨ä½ç½®ã‚’å–å¾—
        let startedAt = null;
        if (editTripStarted.value) {
          try {
            const dt = new Date(editTripStarted.value.replace(' ', 'T'));
            startedAt = toOffsetIsoLocal(dt);
          } catch (e) {
            alert('é–‹å§‹æ—¥æ™‚ã®å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“');
            return;
          }
        }
        
        let lat = parseFloat(editTripLat.value);
        let lng = parseFloat(editTripLng.value);
        
        if (!isFinite(lat) || !isFinite(lng)) {
          // å…¥åŠ›ãŒãªã‘ã‚Œã° draft ã‹ã‚‰å–å¾—
          lat = parseFloat(draft.lat);
          lng = parseFloat(draft.lng);
        }
        
        if (!isFinite(lat) || !isFinite(lng)) {
          alert('ä½ç½®æƒ…å ±ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
          return;
        }
        
        if (!startedAt) {
          alert('é–‹å§‹æ—¥æ™‚ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
          return;
        }
        
        console.log('[btnRefetchCompData] refetching with:', { lat, lng, startedAt });
        
        try {
          // ãƒœã‚¿ãƒ³ã‚’ç„¡åŠ¹åŒ–
          btnRefetchCompData.disabled = true;
          btnRefetchCompData.style.opacity = '0.5';
          
          // å¤©æ°—ã‚’å†å–å¾—
          try {
            const weatherTargetDate = new Date(startedAt);
            const weather = await fetchWeather(lat, lng, weatherTargetDate);
            draft.start_weather = weather;
            console.log('[btnRefetchCompData] Weather refetched:', weather);
          } catch (weatherErr) {
            console.error('[btnRefetchCompData] Weather fetch error:', weatherErr);
            draft.start_weather = null;
          }
          
          // æ½®æ±ã‚’å†å–å¾—ï¼ˆé‡è¦ï¼šæ–°ã—ã„æ½®æ±ãƒ‡ãƒ¼ã‚¿ã§ä¸Šæ›¸ãï¼‰
          try {
            const tide = await fetchTideForStart(lat, lng, startedAt);
            draft.start_tide = tide || null;
            console.log('[btnRefetchCompData] Tide refetched:', tide);
            
            // æ½®æ±ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚‚æ›´æ–°
            if (tide?.chart && tide?.chartDateKey) {
              draft.tide_daily_cache = draft.tide_daily_cache || {};
              draft.tide_daily_cache[tide.chartDateKey] = {
                harbor: tide.harbor || null,
                chart: tide.chart
              };
              console.log('[btnRefetchCompData] Tide cache updated');
            }
          } catch (tideErr) {
            console.error('[btnRefetchCompData] Tide fetch error:', tideErr);
            draft.start_tide = null;
          }
          
          // draft ã‚’ä¿å­˜
          saveDraft(draft);
          
          // UI ã‚’æ›´æ–°ï¼ˆeditTripWeather, editTripTide ã‚’æ›´æ–°ï¼‰
          updateEditModalCompData();
          
          alert('ãƒ‡ãƒ¼ã‚¿ã‚’å†å–å¾—ã—ã¾ã—ãŸ');
        } catch (e) {
          console.error('[btnRefetchCompData] error:', e);
          alert('å†å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + (e?.message || e));
        } finally {
          // ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–
          btnRefetchCompData.disabled = false;
          btnRefetchCompData.style.opacity = '1';
        }
      };
    }
    
    // å†™çœŸãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ + EXIF ã‹ã‚‰æ—¥æ™‚ã‚’è£œå®Œ
    const editFormCatchPhoto = document.getElementById('editFormCatchPhoto');
    if (editFormCatchPhoto) {
      editFormCatchPhoto.addEventListener('change', async (e) => {
        const file = e.target.files[0];
        const preview = document.getElementById('editFormCatchPhotoPreview');
        if (file && preview) {
          const reader = new FileReader();
          reader.onload = (ev) => {
            preview.src = ev.target.result;
            preview.classList.remove('hidden');
          };
          reader.readAsDataURL(file);
          
          // EXIF ã‹ã‚‰æ—¥æ™‚ã‚’æŠ½å‡ºã—ã¦æ—¥æ™‚ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«è£œå®Œ
          try {
            const exifDate = await extractExifDate(file);
            console.log('[EditModal] EXIF date extracted:', exifDate);
            if (exifDate) {
              // EXIF æ—¥æ™‚å½¢å¼: "YYYY:MM:DD HH:MM:SS" â†’ "YYYY-MM-DDTHH:MM"
              const [datePart, timePart] = exifDate.split(' ');
              if (datePart && timePart) {
                const [y, mo, d] = datePart.split(':');
                const [hh, mm] = timePart.split(':');
                const formattedDateTime = `${y}-${mo}-${d}T${hh}:${mm}`;
                const timeInput = document.getElementById('editFormCatchTime');
                if (timeInput && !timeInput.value) {
                  timeInput.value = formattedDateTime;
                }
              }
            }
          } catch (err) {
            console.warn('[EditModal] Failed to extract EXIF date:', err);
          }
        }
      });
    }
    
    // é‡£æœè¿½åŠ ãƒ•ã‚©ãƒ¼ãƒ ã®ã‚¯ãƒ­ãƒ¼ã‚ºãƒœã‚¿ãƒ³
    const btnCloseCatchFormInEdit = document.getElementById('btnCloseCatchFormInEdit');
    if (btnCloseCatchFormInEdit) {
      btnCloseCatchFormInEdit.onclick = () => {
        const formSection = document.getElementById('editCatchFormSection');
        if (formSection) {
          formSection.classList.add('hidden');
        }
      };
    }
    
    // é‡£æœè¿½åŠ ãƒ•ã‚©ãƒ¼ãƒ ã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒœã‚¿ãƒ³
    const btnCancelCatchFormInEdit = document.getElementById('btnCancelCatchFormInEdit');
    if (btnCancelCatchFormInEdit) {
      btnCancelCatchFormInEdit.onclick = () => {
        const formSection = document.getElementById('editCatchFormSection');
        if (formSection) {
          // â˜…ä¿®æ­£ï¼šç·¨é›†çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
          formSection.dataset.isEditing = 'false';
          formSection.dataset.editingIndex = '-1';
          formSection.classList.add('hidden');
          
          // ãƒ•ã‚©ãƒ¼ãƒ ã‚’ã‚¯ãƒªã‚¢
          document.getElementById('editFormCatchTime').value = '';
          document.getElementById('editFormCatchSpecies').value = '';
          document.getElementById('editFormCatchSize').value = '';
          document.getElementById('editFormCatchWeight').value = '';
          document.getElementById('editFormCatchMethod').value = '';
          document.getElementById('editFormCatchPhoto').value = '';
          document.getElementById('editFormCatchPhotoPreview').classList.add('hidden');
          
          // â˜…ä¿®æ­£ï¼šå†™çœŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å†è¡¨ç¤ºï¼ˆè¿½åŠ ãƒ¢ãƒ¼ãƒ‰ç”¨ï¼‰
          const photoLabel = document.querySelector('label:has(#editFormCatchPhoto)');
          if (photoLabel) photoLabel.classList.remove('hidden');
          
          // ãƒœã‚¿ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
          document.getElementById('btnSaveCatchFormInEdit').textContent = 'è¿½åŠ ';
        }
      };
    }
    
    // é‡£æœè¿½åŠ ãƒ•ã‚©ãƒ¼ãƒ ã®ä¿å­˜ãƒœã‚¿ãƒ³
    const btnSaveCatchFormInEdit = document.getElementById('btnSaveCatchFormInEdit');
    if (btnSaveCatchFormInEdit) {
      btnSaveCatchFormInEdit.onclick = async () => {
        // â˜…ä¿®æ­£ï¼šCONFIGåˆæœŸåŒ–å®Œäº†ã‚’å¾…æ©Ÿï¼ˆAPIå‘¼ã³å‡ºã—å‰ã®å¿…é ˆå‡¦ç†ï¼‰
        await configInitPromise;
        
        const timeInput = document.getElementById('editFormCatchTime').value.trim();
        const species = document.getElementById('editFormCatchSpecies').value.trim();
        const size = document.getElementById('editFormCatchSize').value.trim();
        const weight = document.getElementById('editFormCatchWeight').value.trim();
        const method = document.getElementById('editFormCatchMethod').value.trim();
        const photoInput = document.getElementById('editFormCatchPhoto');
        
        if (!species) {
          alert('é­šç¨®ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
          return;
        }
        
        // æ–°ã—ã„é‡£æœã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
        const newCatch = {
          id: uuid(),  // â˜…è¿½åŠ ï¼šcatchId ã‚’ç”Ÿæˆ
          tripId: draft.tripId,
          timestamp: null,
          species: species,
          size_cm: size ? parseFloat(size) : null,
          weight_g: weight ? parseFloat(weight) : null,
          method: method || '',
          
          // â˜…è¿½åŠ ï¼šå¤©æ°—æƒ…å ±ï¼ˆé‡£è¡Œã®é–‹å§‹å¤©æ°—ã‹ã‚‰åˆæœŸè¨­å®šï¼‰
          wx_temp: draft.start_weather?.temp ?? null,
          wx_wind_speed: draft.start_weather?.wind_speed ?? null,
          wx_wind_deg: draft.start_weather?.wind_deg ?? null,
          wx_main: draft.start_weather?.weather_main ?? null,
          wx_desc: draft.start_weather?.weather_description ?? null,
          
          // â˜…è¿½åŠ ï¼šæ½®æ±æƒ…å ±ï¼ˆå¾Œã§è£œå®Œï¼‰
          tide_trend: null,  // â˜…æ½®æ±ãƒ­ã‚¸ãƒƒã‚¯ã§è£œå®Œäºˆå®š
          tide_level_cm: null,  // â˜…æ½®æ±ãƒ­ã‚¸ãƒƒã‚¯ã§è£œå®Œäºˆå®š
          tide_name: draft.start_tide?.tideName ?? null,
          tide_harbor_name: draft.start_tide?.harbor?.hn ?? null,
          tide_high_times: draft.start_tide?.high_times ?? null,
          tide_low_times: draft.start_tide?.low_times ?? null,
          
          // â˜…è¿½åŠ ï¼šæ°´æ¸©æƒ…å ±ï¼ˆé‡£è¡Œã®é–‹å§‹æ°´æ¸©ã‹ã‚‰åˆæœŸè¨­å®šï¼‰
          water_temp_c: draft.start_water_temp?.temperature_c ?? null,
          water_temp_point: draft.start_water_temp?.point_name ?? null,
          water_temp_time: draft.start_water_temp?.date ?? null,
          
          // å†™çœŸ
          weather: draft.weather || null,
          photoFileId: null,
          photoDriveUrl: null,
          photoDriveThumbUrl: null
        };
        
        // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’è¨­å®š
        const editFormSection = document.getElementById('editCatchFormSection');
        const isEditing = editFormSection?.dataset.isEditing === 'true';
        const editingIndex = parseInt(editFormSection?.dataset.editingIndex) || -1;
        
        if (isEditing && editingIndex >= 0 && editingIndex < draft.catches.length) {
          // â˜…ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ï¼šç·¨é›†å…ƒã®é‡£æœãŒã‚ã‚Œã°ãã®timestampã‚’ä¿æŒ
          const existingCatch = draft.catches[editingIndex];
          if (timeInput) {
            // timeInputãŒå…¥åŠ›ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯æ–°ã—ã„å€¤ã‚’ä½¿ã†
            if (timeInput.includes('T')) {
              newCatch.timestamp = new Date(timeInput).toISOString();
            } else if (timeInput.includes(':')) {
              const [hh, mm, ss] = timeInput.split(':').map(x => parseInt(x) || 0);
              const now = new Date();
              newCatch.timestamp = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hh, mm, ss).toISOString();
            }
          } else {
            // timeInputãŒç©ºã®å ´åˆã¯ç·¨é›†å…ƒã®æ™‚åˆ»ã‚’ä¿æŒ
            newCatch.timestamp = existingCatch.timestamp;
          }
        } else {
          // â˜…è¿½åŠ ãƒ¢ãƒ¼ãƒ‰ï¼šé€šå¸¸ã®ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—è¨­å®š
          if (timeInput) {
            // YYYY-MM-DDTHH:MMå½¢å¼ã¾ãŸã¯HH:MM:SSå½¢å¼ã«å¯¾å¿œ
            if (timeInput.includes('T')) {
              // YYYY-MM-DDTHH:MMå½¢å¼
              newCatch.timestamp = new Date(timeInput).toISOString();
            } else if (timeInput.includes(':')) {
              // HH:MM:SSå½¢å¼ â†’ ä»Šæ—¥ã®æ—¥ä»˜ + æŒ‡å®šæ™‚é–“
              const [hh, mm, ss] = timeInput.split(':').map(x => parseInt(x) || 0);
              const now = new Date();
              newCatch.timestamp = new Date(
                now.getFullYear(), 
                now.getMonth(), 
                now.getDate(), 
                hh, 
                mm, 
                ss
              ).toISOString();
            }
          } else {
            newCatch.timestamp = new Date().toISOString();
          }
        }
        
        // â˜…ä¿®æ­£ï¼šå†™çœŸã®ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å‡¦ç†ï¼ˆæ–°è¦ä½œæˆæ™‚ã€ç·¨é›†æ™‚ã®ä¸¡æ–¹ã§å†™çœŸå¤‰æ›´å¯èƒ½ï¼‰
        if (photoInput && photoInput.files && photoInput.files.length > 0) {
          // æ–°è¦ä½œæˆã¾ãŸã¯ç·¨é›†æ™‚ã«æ–°ã—ã„å†™çœŸãŒé¸æŠã•ã‚Œã¦ã„ã‚‹å ´åˆ
          const file = photoInput.files[0];
          try {
            const photoResult = await uploadPhotoToDrive(file);
            if (photoResult) {
              newCatch.photoFileId = photoResult.fileId || null;
              newCatch.photoDriveUrl = photoResult.viewUrl || null;
              newCatch.photoDriveThumbUrl = photoResult.thumbUrl || null;
              console.log('[EditModal] Photo uploaded:', photoResult);
            }
          } catch (ex) {
            console.warn('[EditModal] Photo upload failed:', ex?.message || ex);
          }
        } else if (isEditing && editingIndex >= 0 && editingIndex < draft.catches.length) {
          // ç·¨é›†æ™‚ã§æ–°ã—ã„å†™çœŸãŒé¸æŠã•ã‚Œã¦ã„ãªã„å ´åˆã¯æ—¢å­˜å†™çœŸã‚’ä¿æŒ
          const existingCatch = draft.catches[editingIndex];
          newCatch.photoFileId = existingCatch.photoFileId;
          newCatch.photoDriveUrl = existingCatch.photoDriveUrl;
          newCatch.photoDriveThumbUrl = existingCatch.photoDriveThumbUrl;
        }
        
        // â˜…æ½®æ±æƒ…å ±ã‚’è£œå®Œã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆsubmitCatch ã¨åŒã˜ï¼‰
        if (newCatch.timestamp && typeof draft.lat === 'number' && typeof draft.lng === 'number') {
          const dkey = dateKeyFromIso(newCatch.timestamp);
          
          try {
            let dayChart = null;
            // draft.tide_daily_cache ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒã‚ã‚‹ã‹ç¢ºèª
            if (draft.tide_daily_cache?.[dkey]?.chart) {
              dayChart = draft.tide_daily_cache[dkey].chart;
              const info = tideInfoFromChart(dayChart, newCatch.timestamp);
              newCatch.tide_level_cm = info.level_cm;
              newCatch.tide_trend = info.trend_text;
              console.log('[EditModal] Tide from cache:', info);
            } else {
              // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã«ãªã‘ã‚Œã° API ã‹ã‚‰å–å¾—
              const pack = await getTideChartForDate(draft.lat, draft.lng, newCatch.timestamp);
              if (pack?.chart) {
                dayChart = pack.chart;
                draft.tide_daily_cache = draft.tide_daily_cache || {};
                draft.tide_daily_cache[dkey] = { harbor: pack.harbor || null, chart: pack.chart };
                const info = tideInfoFromChart(pack.chart, newCatch.timestamp);
                newCatch.tide_level_cm = info.level_cm;
                newCatch.tide_trend = info.trend_text;
                // â˜…æ½®æ±ãƒãƒ£ãƒ¼ãƒˆã‹ã‚‰æº€æ½®ãƒ»å¹²æ½®æ™‚åˆ»ã‚’è¨ˆç®—
                const hl = summarizeHighLowTimesFromChart(dayChart);
                newCatch.tide_high_times = hl.high;
                newCatch.tide_low_times = hl.low;
                console.log('[EditModal] Tide from API:', info, 'high/low:', hl);
              }
            }
            
            // â˜…ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å–å¾—ã—ãŸå ´åˆã‚‚æº€æ½®ãƒ»å¹²æ½®ã‚’è¨ˆç®—
            if (dayChart && !newCatch.tide_high_times && !newCatch.tide_low_times) {
              const hl = summarizeHighLowTimesFromChart(dayChart);
              newCatch.tide_high_times = hl.high;
              newCatch.tide_low_times = hl.low;
            }
            
            // â˜…æ½®æ±åã¨æ¸¯åã‚’è¨­å®š
            if (dayChart) {
              newCatch.tide_name = dayChart?.moon?.title || draft.start_tide?.tideName || null;
              if (draft.tide_daily_cache?.[dkey]?.harbor) {
                newCatch.tide_harbor_name = draft.tide_daily_cache[dkey].harbor.hn || null;
              } else {
                newCatch.tide_harbor_name = draft.start_tide?.harbor?.hn || null;
              }
            }
          } catch (ex) {
            console.warn('[EditModal] Tide calculation failed:', ex?.message || ex);
          }
        }
        
        // â˜…å¤©æ°—æƒ…å ±ã‚’è£œå®Œã™ã‚‹ãƒ­ã‚¸ãƒƒã‚¯ï¼ˆsubmitCatch ã¨åŒã˜ï¼‰
        console.log('[EditModal] Weather check - draft.lat:', draft.lat, 'draft.lng:', draft.lng, 'type check:', typeof draft.lat === 'number' && typeof draft.lng === 'number');
        if (typeof draft.lat === 'number' && typeof draft.lng === 'number') {
          console.log('[EditModal] Entering weather fetch block, lat:', draft.lat, 'lng:', draft.lng);
          try {
            console.log('[EditModal] About to call fetchWeather...');
            const wx = await fetchWeather(draft.lat, draft.lng);
            console.log('[EditModal] fetchWeather returned:', wx);
            if (wx) {
              console.log('[EditModal] Weather object is truthy, assigning fields...');
              newCatch.wx_temp = wx.temp ?? null;
              console.log('[EditModal] Assigned wx_temp:', newCatch.wx_temp, '(from wx.temp:', wx.temp, ')');
              newCatch.wx_wind_speed = wx.wind_speed ?? null;
              console.log('[EditModal] Assigned wx_wind_speed:', newCatch.wx_wind_speed, '(from wx.wind_speed:', wx.wind_speed, ')');
              newCatch.wx_wind_deg = wx.wind_deg ?? null;
              console.log('[EditModal] Assigned wx_wind_deg:', newCatch.wx_wind_deg, '(from wx.wind_deg:', wx.wind_deg, ')');
              newCatch.wx_main = wx.weather_main ?? null;
              console.log('[EditModal] Assigned wx_main:', newCatch.wx_main, '(from wx.weather_main:', wx.weather_main, ')');
              newCatch.wx_desc = wx.weather_description ?? null;
              console.log('[EditModal] Assigned wx_desc:', newCatch.wx_desc, '(from wx.weather_description:', wx.weather_description, ')');
              console.log('[EditModal] Weather fields assignment complete. newCatch weather fields:', {
                wx_temp: newCatch.wx_temp,
                wx_wind_speed: newCatch.wx_wind_speed,
                wx_wind_deg: newCatch.wx_wind_deg,
                wx_main: newCatch.wx_main,
                wx_desc: newCatch.wx_desc
              });
            } else {
              console.warn('[EditModal] fetchWeather returned falsy:', wx);
            }
          } catch (ex) {
            console.warn('[EditModal] Weather fetch failed:', ex?.message || ex);
          }
        } else {
          console.log('[EditModal] Skipping weather fetch - lat or lng not a number');
        }
        console.log('[EditModal] Before draft.catches.push, newCatch:', newCatch);
        
        // â˜…ä¿®æ­£ï¼šå‰ã§æ—¢ã«å®šç¾©ã—ãŸ editFormSection, isEditing, editingIndex ã‚’ä½¿ç”¨
        // (å†å®šç¾©ã—ãªã„)
        
        if (isEditing && editingIndex >= 0 && editingIndex < draft.catches.length) {
          // â˜…ç·¨é›†ãƒ¢ãƒ¼ãƒ‰ï¼šæ—¢å­˜é‡£æœã‚’ä¸Šæ›¸ã
          const existingCatch = draft.catches[editingIndex];
          newCatch.id = existingCatch.id;  // IDã¯ä¿æŒ
          draft.catches[editingIndex] = newCatch;
          console.log('[EditModal] Catch updated at index:', editingIndex, newCatch);
        } else {
          // â˜…è¿½åŠ ãƒ¢ãƒ¼ãƒ‰ï¼šæ–°è¦é‡£æœã‚’è¿½åŠ 
          draft.catches.push(newCatch);
          console.log('[EditModal] Catch added with tide completion:', newCatch);
        }
        
        saveDraft(draft);
        
        // â˜…ä¿®æ­£ï¼šç·¨é›†ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆï¼ˆæ¬¡å›ä½œæˆã‚’é˜²ãï¼‰
        const formSection = document.getElementById('editCatchFormSection');
        if (formSection) {
          formSection.dataset.isEditing = 'false';
          formSection.dataset.editingIndex = '-1';
        }
        
        // ãƒ•ã‚©ãƒ¼ãƒ ã‚’ã‚¯ãƒªã‚¢ã—ã¦éš ã™
        document.getElementById('editFormCatchTime').value = '';
        document.getElementById('editFormCatchSpecies').value = '';
        document.getElementById('editFormCatchSize').value = '';
        document.getElementById('editFormCatchWeight').value = '';
        document.getElementById('editFormCatchMethod').value = '';
        document.getElementById('editFormCatchPhoto').value = '';
        const photoPreview = document.getElementById('editFormCatchPhotoPreview');
        if (photoPreview) {
          photoPreview.classList.add('hidden');
          photoPreview.src = '';
        }
        if (formSection) {
          formSection.classList.add('hidden');
        }
        
        // é‡£æœãƒªã‚¹ãƒˆã‚’å†æç”»
        const renderEditCatchListLocal = () => {
          const cts = draft.catches || [];
          const editCatchList = document.getElementById('editCatchList');
          const editCatchCount = document.getElementById('editCatchCount');
          editCatchList.innerHTML = '';
          editCatchCount.textContent = cts.length;

          cts.forEach((c, i) => {
            // â˜…ä¿®æ­£ï¼šæ—¢ã«æ­£è¦åŒ–ã•ã‚ŒãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå½¢å¼ãªã®ã§ç›´æ¥ä½¿ç”¨
            const catchObjTemp = c;

            const itemTemp = document.createElement('div');
            itemTemp.className = 'bg-slate-800 rounded-lg p-3 flex items-start justify-between';

            const contentTemp = document.createElement('div');
            contentTemp.className = 'flex-1 cursor-pointer hover:bg-slate-700/30 rounded p-1 transition';
            
            let timeStrTemp = '';
            if (catchObjTemp.timestamp) {
              const d = new Date(catchObjTemp.timestamp);
              timeStrTemp = `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}:${String(d.getSeconds()).padStart(2,'0')}`;
            }
            
            const tideInfoTemp = [];
            if (catchObjTemp.tide_trend) tideInfoTemp.push(catchObjTemp.tide_trend);
            if (catchObjTemp.tide_level_cm != null) tideInfoTemp.push(catchObjTemp.tide_level_cm + ' cm');
            const tideStrTemp = tideInfoTemp.length > 0 ? tideInfoTemp.join(' ') : '';
            
            contentTemp.innerHTML = `
              <div class="font-semibold text-slate-100 text-sm">${catchObjTemp.species || '(é­šç¨®æœªè¨­å®š)'} ${catchObjTemp.size_cm ? catchObjTemp.size_cm + ' cm' : ''}</div>
              <div class="text-slate-400 text-xs mt-1">${timeStrTemp}</div>
              ${tideStrTemp ? `<div class="text-slate-300 text-xs mt-1">${tideStrTemp}</div>` : ''}
            `;

            // â˜…è¿½åŠ ï¼šç·¨é›†ãƒœã‚¿ãƒ³
            const btnEditTemp = document.createElement('button');
            btnEditTemp.className = 'text-xs py-1 px-2 rounded bg-blue-900 hover:bg-blue-800 text-blue-200 ml-2';
            btnEditTemp.textContent = 'ç·¨é›†';
            btnEditTemp.onclick = (e) => {
              e.stopPropagation();
              // ç·¨é›†ãƒ•ã‚©ãƒ¼ãƒ ã«ãƒ‡ãƒ¼ã‚¿ã‚’å±•é–‹
              const editFormSection = document.getElementById('editCatchFormSection');
              const editFormTime = document.getElementById('editFormCatchTime');
              const editFormSpecies = document.getElementById('editFormCatchSpecies');
              const editFormSize = document.getElementById('editFormCatchSize');
              const editFormWeight = document.getElementById('editFormCatchWeight');
              const editFormMethod = document.getElementById('editFormCatchMethod');
              
              // â˜…è¿½åŠ ï¼šç·¨é›†ä¸­ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä¿å­˜ï¼ˆæ›´æ–°æ™‚ã«ä½¿ç”¨ï¼‰
              editFormSection.dataset.editingIndex = i;
              editFormSection.dataset.isEditing = 'true';
              
              // æ—¢å­˜ãƒ‡ãƒ¼ã‚¿ã‚’å±•é–‹
              if (catchObjTemp.timestamp) {
                // â˜…ä¿®æ­£ï¼štoLocalInputValue é–¢æ•°ã‚’ä½¿ç”¨ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³å¯¾å¿œï¼‰
                try {
                  const dt = new Date(catchObjTemp.timestamp);
                  editFormTime.value = toLocalInputValue(dt);
                  console.log('[TripEdit] timestamp converted:', {
                    original: catchObjTemp.timestamp,
                    formatted: editFormTime.value
                  });
                } catch (e) {
                  console.warn('[TripEdit] timestamp parse failed:', e);
                  editFormTime.value = '';
                }
              } else {
                editFormTime.value = '';
              }
              editFormSpecies.value = catchObjTemp.species || '';
              editFormSize.value = catchObjTemp.size_cm ? String(catchObjTemp.size_cm) : '';
              editFormWeight.value = catchObjTemp.weight_g ? String(catchObjTemp.weight_g) : '';
              editFormMethod.value = catchObjTemp.method || '';
              
                // â˜…è¿½åŠ ï¼šå†™çœŸãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’è¡¨ç¤ºï¼ˆç·¨é›†æ™‚ã§ã‚‚å†™çœŸå¤‰æ›´å¯èƒ½ã«ï¼‰
                const photoLabel = document.querySelector('label:has(#editFormCatchPhoto)');
                if (photoLabel) photoLabel.classList.remove('hidden');
                
                // ãƒ•ã‚©ãƒ¼ãƒ ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¡¨ç¤º
                editFormSection.classList.remove('hidden');
              // ä¿å­˜ãƒœã‚¿ãƒ³ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’å¤‰æ›´
              document.getElementById('btnSaveCatchFormInEdit').textContent = 'æ›´æ–°';
              
              // ãƒ•ã‚©ãƒ¼ãƒ ã«ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«
              editFormSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
              
              console.log('[TripEdit] Editing catch at index:', i, 'data:', catchObjTemp);
            };

            const btnDeleteTemp = document.createElement('button');
            btnDeleteTemp.className = 'text-xs py-1 px-2 rounded bg-red-900 hover:bg-red-800 text-red-200 ml-2';
            btnDeleteTemp.textContent = 'å‰Šé™¤';
            btnDeleteTemp.onclick = (e) => {
              e.stopPropagation();
              if (confirm('ã“ã®é‡£æœã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ')) {
                draft.catches.splice(i, 1);
                saveDraft(draft);
                renderEditCatchListLocal();
              }
            };

            itemTemp.appendChild(contentTemp);
            itemTemp.appendChild(btnEditTemp);
            itemTemp.appendChild(btnDeleteTemp);
            editCatchList.appendChild(itemTemp);
          });
        };
        renderEditCatchListLocal();
      };
    }
    if (btnSaveTripEdit) {
      btnSaveTripEdit.onclick = async (e) => {
        console.log('[btnSaveTripEdit] clicked', { isUploading });
        // â˜…ä¿®æ­£ï¼šãƒœã‚¿ãƒ³ã‚¯ãƒªãƒƒã‚¯æ™‚ã«æœ€åˆã«æ“ä½œãƒ–ãƒ­ãƒƒã‚¯ï¼†ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤è¡¨ç¤º
        if (isUploading) {
          console.log('[btnSaveTripEdit] already uploading, returning');
          return;
        }
        
        console.log('[btnSaveTripEdit] calling showUploadingOverlay');
        showUploadingOverlay('ä¿å­˜ä¸­...');
        
        // â˜…ä¿®æ­£ï¼šæ±ç”¨é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ãƒœã‚¿ãƒ³ã‚’ç„¡åŠ¹åŒ–
        setTripEditModalElementsEnabled(false);
        
        console.log('[btnSaveTripEdit] waiting for requestAnimationFrame');
        await new Promise(resolve => requestAnimationFrame(resolve));
        
        console.log('[btnSaveTripEdit] calling submitTripEditData');
        // ãã®å¾Œã§å®Ÿéš›ã®å‡¦ç†ã‚’å®Ÿè¡Œ
        try {
          await submitTripEditData();
          console.log('[btnSaveTripEdit] submitTripEditData completed');
        } catch (e) {
          console.error('[btnSaveTripEdit] error:', e);
          hideUploadingOverlay();
          // â˜…ä¿®æ­£ï¼šæ±ç”¨é–¢æ•°ã‚’ä½¿ç”¨ã—ã¦ãƒœã‚¿ãƒ³ã‚’æœ‰åŠ¹åŒ–
          setTripEditModalElementsEnabled(true);
        }
      };
    }

    // â˜…è¿½åŠ ï¼šé‡£è¡Œç·¨é›†ãƒ‡ãƒ¼ã‚¿ã‚’ä¸Šæ›¸ãä¿å­˜
    async function submitTripEditData() {
      // â˜…è¿½åŠ ï¼šHarbor ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’äº‹å‰ãƒ­ãƒ¼ãƒ‰ï¼ˆç·¨é›†æ™‚ã®éåŒæœŸé…å»¶é˜²æ­¢ï¼‰
      try {
        await ensureHarborCache();
      } catch (e) {
        LOG.tide('[submitTripEditData] Warning: Harbor cache load failed:', e?.message);
        // è­¦å‘Šã®ã¿ã€å‡¦ç†ã¯ç¶šè¡Œ
      }
      
      // â˜…è¿½åŠ ï¼šä¿å­˜æ™‚ã« Trips ã‚·ãƒ¼ãƒˆã‹ã‚‰å…¨ãƒ‡ãƒ¼ã‚¿ã‚’å†åº¦å–å¾—ã—ã¦ draft ã«åæ˜ ï¼ˆæœªç·¨é›†ãƒ‡ãƒ¼ã‚¿ã®å–ªå¤±ã‚’é˜²ãï¼‰
      try {
        const headers = tripsCache[0];
        const col = {};
        for (let i = 0; i < headers.length; i++) {
          col[String(headers[i]).trim()] = i;
        }
        const tripRow = tripsCache.find((t, idx) => idx > 0 && String(t[col.tripId]) === String(draft.tripId));
        
        if (tripRow) {
          // â˜…è¿½åŠ ï¼šæ—¥æ™‚ãƒ‡ãƒ¼ã‚¿ã‚’å¾©å…ƒï¼ˆTrips ã‚·ãƒ¼ãƒˆã‹ã‚‰ï¼‰
          if (tripRow[col.startedAt]) {
            draft.startedAt = tripRow[col.startedAt];
          }
          if (tripRow[col.endedAt]) {
            draft.endedAt = tripRow[col.endedAt];
          }
          
          // â˜…è¿½åŠ ï¼šä½ç½®æƒ…å ±ã‚’å¾©å…ƒ
          if (tripRow[col.lat]) draft.lat = parseFloat(tripRow[col.lat]) || draft.lat;
          if (tripRow[col.lng]) draft.lng = parseFloat(tripRow[col.lng]) || draft.lng;
          
          // å…ƒãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å…¨ã‚«ãƒ©ãƒ ã‚’ draft ã«åæ˜ 
          draft.status = tripRow[col.status] || draft.status || 'ended';
          
          // å¤©æ°—ãƒ‡ãƒ¼ã‚¿ï¼ˆé–‹å§‹ãƒ»çµ‚äº†ï¼‰ã‚’å…¨ã¦å¼•ãç¶™ã
          if (tripRow[col.start_weather_main]) {
            draft.start_weather = {
              temp: parseFloat(tripRow[col.start_temp]) || null,
              wind_speed: parseFloat(tripRow[col.start_wind_speed]) || null,
              wind_deg: parseFloat(tripRow[col.start_wind_deg]) || null,
              weather_main: tripRow[col.start_weather_main] || '',
              weather_description: tripRow[col.start_weather_desc] || ''
            };
          }
          if (tripRow[col.end_weather_main]) {
            draft.end_weather = {
              temp: parseFloat(tripRow[col.end_temp]) || null,
              wind_speed: parseFloat(tripRow[col.end_wind_speed]) || null,
              wind_deg: parseFloat(tripRow[col.end_wind_deg]) || null,
              weather_main: tripRow[col.end_weather_main] || '',
              weather_description: tripRow[col.end_weather_desc] || ''
            };
          }
          
          // æ°´æ¸©ãƒ‡ãƒ¼ã‚¿ã‚’å¼•ãç¶™ã
          if (tripRow[col.water_temp_c]) {
            draft.start_water_temp = {
              temperature_c: parseFloat(tripRow[col.water_temp_c]) || null,
              point_name: String(tripRow[col.water_temp_point] || '') || null,
              date: tripRow[col.water_temp_time] || null
            };
          }
          
          // æ½®æ±ãƒ‡ãƒ¼ã‚¿ã‚’å¼•ãç¶™ã
          let start_tide = null;
          if (col.raw_json >= 0) {
            const rawJson = tripRow[col.raw_json];
            try {
              if (rawJson) {
                const raw = typeof rawJson === 'string' ? JSON.parse(rawJson) : rawJson;
                start_tide = raw?.start_tide || null;
              }
            } catch (e) {
              // ãƒ‘ãƒ¼ã‚¹å¤±æ•—æ™‚ã¯ start_tide = null
            }
          }
          if (start_tide) {
            draft.start_tide = start_tide;
          }
          
          // ãã®ä»–ã®è£œå®Œç”¨ã‚«ãƒ©ãƒ 
          draft.weather = tripRow[col.start_weather_main] || draft.weather || null;
          draft.tide_trend = tripRow[col.tide_trend] || draft.tide_trend || null;
          draft.tide_level_cm = tripRow[col.tide_level_cm] ? parseFloat(tripRow[col.tide_level_cm]) : (draft.tide_level_cm || null);
          draft.memo = tripRow[col.memo] || draft.memo || null;
          
          // moon ãƒ‡ãƒ¼ã‚¿ã‚’å¼•ãç¶™ã
          if (tripRow[col.moon_v]) draft.moon_v = tripRow[col.moon_v];
          if (tripRow[col.moon_a]) draft.moon_a = tripRow[col.moon_a];
          if (tripRow[col.sunrise]) draft.sunrise = tripRow[col.sunrise];
          if (tripRow[col.sunset]) draft.sunset = tripRow[col.sunset];
        }
      } catch (e) {
        console.error('[TripEdit] Error restoring full trip data:', e);
      }
      
      // å…¥åŠ›å€¤ã‹ã‚‰é‡£è¡Œãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ï¼ˆå…¥åŠ›ãŒã‚ã£ãŸå ´åˆã®ã¿æ›´æ–°ï¼‰
      if (editTripStarted.value) {
        try {
          const dt = new Date(editTripStarted.value.replace(' ', 'T'));
          draft.startedAt = toOffsetIsoLocal(dt);
        } catch (e) {
          alert('é–‹å§‹æ—¥æ™‚ã®å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“');
          return;
        }
      }
      // â˜…ä¿®æ­£ï¼šeditTripStarted ãŒç©ºã®å ´åˆã€Trips ã‚·ãƒ¼ãƒˆã‹ã‚‰å¾©å…ƒã—ãŸå€¤ã‚’ä¿æŒï¼ˆä¸Šæ›¸ãã—ãªã„ï¼‰

      if (editTripEnded.value) {
        try {
          const dt = new Date(editTripEnded.value.replace(' ', 'T'));
          draft.endedAt = toOffsetIsoLocal(dt);
        } catch (e) {
          alert('çµ‚äº†æ—¥æ™‚ã®å½¢å¼ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“');
          return;
        }
      }
      // â˜…ä¿®æ­£ï¼šeditTripEnded ãŒç©ºã®å ´åˆã€Trips ã‚·ãƒ¼ãƒˆã‹ã‚‰å¾©å…ƒã—ãŸå€¤ã‚’ä¿æŒï¼ˆä¸Šæ›¸ãã—ãªã„ï¼‰

      let lat = parseFloat(editTripLat.value);
      let lng = parseFloat(editTripLng.value);
      if (isFinite(lat) && isFinite(lng)) {
        draft.lat = lat;
        draft.lng = lng;
      }
      // â˜…ä¿®æ­£ï¼šlat/lng ãŒæœ‰åŠ¹ã§ãªã„å ´åˆã€Trips ã‚·ãƒ¼ãƒˆã‹ã‚‰å¾©å…ƒã—ãŸå€¤ã‚’ä¿æŒ

      // â˜…è¿½åŠ ï¼šãƒ¡ãƒ¢ã‚’ draft ã«åæ˜ 
      const editTripMemo = document.getElementById('editTripMemo');
      if (editTripMemo) {
        draft.memo = editTripMemo.value || null;
      }

      // â˜…ä¿®æ­£ï¼šå¸¸ã«è£œå®Œãƒ‡ãƒ¼ã‚¿ã‚’å†å–å¾—ï¼ˆä½ç½®æƒ…å ±ã®æœ‰ç„¡ã«é–¢ã‚ã‚‰ãšï¼‰
      const hasPosition = isFinite(lat) && isFinite(lng);
      if (!hasPosition && isFinite(parseFloat(draft.lat)) && isFinite(parseFloat(draft.lng))) {
        lat = parseFloat(draft.lat);
        lng = parseFloat(draft.lng);
      }

      // æœ‰åŠ¹ãªä½ç½®æƒ…å ±ãŒã‚ã‚‹å ´åˆã¯è£œå®Œãƒ‡ãƒ¼ã‚¿ã‚’å†å–å¾—
      if (isFinite(lat) && isFinite(lng)) {
        // â˜…ä¿®æ­£ï¼šæ°´æ¸©ã‚’ä¿æŒã—ã¦ã‹ã‚‰ãƒªã‚»ãƒƒãƒˆ
        const preservedWaterTemp = draft.start_water_temp;
        
        // è£œå®Œãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆ
        draft.start_weather = null;
        draft.start_tide = null;
        draft.start_water_temp = null;
        draft.tide_daily_cache = {};
        
        try {
          // å¤©æ°—ã‚’å†å–å¾—ï¼ˆé–‹å§‹æ™‚åˆ»ãŒã‚ã‚‹å ´åˆã¯ãã®æ—¥ä»˜ã§ï¼‰
          try {
            const weatherTargetDate = draft.startedAt ? new Date(draft.startedAt) : null;
            draft.start_weather = await fetchWeather(lat, lng, weatherTargetDate);
          } catch (weatherErr) {
            draft.start_weather = null;
          }
          
          // â˜…ä¿®æ­£ï¼šæ½®æ±ã‚’å†å–å¾—ï¼ˆé–‹å§‹æ™‚åˆ»ãŒã‚ã‚‹å ´åˆï¼‰- Harbor ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç¢ºä¿å¾Œã«å®Ÿè¡Œ
          if (draft.startedAt) {
            try {
              // Harbor ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒç¢ºä¿ã•ã‚ŒãŸã“ã¨ã‚’ç¢ºèª
              if (harborCache && harborCache.mapped && harborCache.mapped.length > 0) {
                LOG.tide('[submitTripEditData] Harbor cache confirmed before fetchTideForStart');
              }
              const tide = await fetchTideForStart(lat, lng, draft.startedAt);
              draft.start_tide = tide || null;
              if (tide?.chart && tide?.chartDateKey) {
                draft.tide_daily_cache = draft.tide_daily_cache || {};
                draft.tide_daily_cache[tide.chartDateKey] = {
                  harbor: tide.harbor || null,
                  chart: tide.chart
                };
              }
              LOG.tide('[submitTripEditData] Tide refetched successfully');
            } catch (tideErr) {
              LOG.tide('[submitTripEditData] Tide refetch error:', tideErr?.message || tideErr);
              draft.start_tide = null;
            }
          }
          
          // â˜…ä¿®æ­£ï¼šæ°´æ¸©ã¯å†å–å¾—ã›ãšã€ä¿æŒã—ãŸå€¤ã‚’å¾©å…ƒ
          draft.start_water_temp = preservedWaterTemp;
        } catch (e) {
          // Refetch error - continue with whatever data is available
        }
      }

      saveDraft(draft);
      LOG.app('[TripEdit] saved', { tripId: draft.tripId, catches: draft.catches?.length || 0 });

      // â˜…ä¿®æ­£ï¼šãƒœã‚¿ãƒ³ãƒãƒ³ãƒ‰ãƒ©å†…ã§ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã¯æ—¢ã«è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ã“ã“ã‹ã‚‰ã¯ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰å‡¦ç†ã®ã¿å®Ÿè¡Œ
      try {
        await uploadTripToSpreadsheet(draft);
        alert('é‡£è¡Œãƒ‡ãƒ¼ã‚¿ã‚’ä¸Šæ›¸ãä¿å­˜ã—ã¾ã—ãŸ');
        
        tripEditModal.style.display = 'none';
        tripEditModal.classList.add('hidden');
        
        showView('trips');
        loadTrips();
        
        draft = { tripId: uuid(), status: 'idle', catches: [], tide_daily_cache: {}, start_water_temp: null, memo: null };
        saveDraft(draft);
        
        // â˜…ä¿®æ­£ï¼šãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’å®Œå…¨ã«é–‰ã˜ãŸå¾Œã«ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’éš ã™
        hideUploadingOverlay();
        
        // â˜…ä¿®æ­£ï¼šæˆåŠŸæ™‚ã‚‚ãƒœã‚¿ãƒ³ã‚’å†æœ‰åŠ¹åŒ–ï¼ˆæ±ç”¨é–¢æ•°ã‚’ä½¿ç”¨ï¼‰
        setTripEditModalElementsEnabled(true);
      } catch (e) {
        // â˜…ä¿®æ­£ï¼šã‚¨ãƒ©ãƒ¼æ™‚ã‚‚ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’éš ã™
        hideUploadingOverlay();
        alert('ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + (e?.message || e));
        
        // â˜…ä¿®æ­£ï¼šã‚¨ãƒ©ãƒ¼æ™‚ã‚‚ãƒœã‚¿ãƒ³ã‚’å†åº¦æœ‰åŠ¹åŒ–ï¼ˆæ±ç”¨é–¢æ•°ã‚’ä½¿ç”¨ï¼‰
        setTripEditModalElementsEnabled(true);
      }
    }

    // â˜…ä¿®æ­£ï¼šé‡£è¡Œãƒ‡ãƒ¼ã‚¿æ›´æ–°ç”¨ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰é–¢æ•°
    async function uploadTripToSpreadsheet(tripData) {
      try {
        LOG.app('[Upload] starting trip data upload', { 
          tripId: tripData.tripId, 
          catches: Array.isArray(tripData.catches) ? tripData.catches.length : 0 
        });

        // æ—¢å­˜ãƒˆãƒªãƒƒãƒ—ã®æ›´æ–°ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’æŒ‡å®š
        const payload = buildTripPayload(tripData, 'update');

        LOG.app('[Upload] payload ready', { 
          action: payload.action,
          payloadSize: JSON.stringify(payload).length 
        });

        // â˜…ä¿®æ­£ï¼šæ‰‹å‹•ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã¨åŒã˜æ–¹å¼ã§ Worker çµŒç”±ã§é€ä¿¡ï¼ˆsecrets ä¿è­·ï¼‰
        const workerUrl = CONFIG.API.FISHING_TRIP_API_WORKER + '/api/upload';
        const response = await fetch(workerUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Auth-Token': CONFIG.API.WORKERS_AUTH_TOKEN
          },
          body: JSON.stringify(payload)
        });

        const text = await response.text();
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${text.slice(0,200)}`);
        }

        let result = {};
        try { result = JSON.parse(text); } catch(pe) {}
        
        LOG.app('[Upload] response received', { 
          status: response.status, 
          saved: result.saved,
          images: result.saved?.images || 0
        });

        return { ok: true, message: 'Upload successful', ...result };

      } catch (err) {
        LOG.app('[Upload] error', { error: err?.message || String(err) });
        throw err;
      }
    }

    // â˜…ä¿®æ­£: ãƒ›ãƒ¼ãƒ ãƒœã‚¿ãƒ³ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
    (function setupHomeButtons(){
      const btnManualTrip = document.getElementById('btnManualTripHome');
      const btnAddManualCatch = document.getElementById('homeAddManualCatch');
      
      if (btnManualTrip) {
        btnManualTrip.onclick = openManualTripForm;
      }
      if (btnAddManualCatch) {
        btnAddManualCatch.onclick = openManualCatchForm;
      }
    })();
  </script>
</body>
</html>
